<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Polarisのblog</title>
  
  
  <link href="http://polaris3003.github.io/atom.xml" rel="self"/>
  
  <link href="http://polaris3003.github.io/"/>
  <updated>2025-03-06T03:05:36.000Z</updated>
  <id>http://polaris3003.github.io/</id>
  
  <author>
    <name>Polaris</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>茶-2025-03</title>
    <link href="http://polaris3003.github.io/2025/03/03/Tea202503/"/>
    <id>http://polaris3003.github.io/2025/03/03/Tea202503/</id>
    <published>2025-03-03T03:38:51.000Z</published>
    <updated>2025-03-06T03:05:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tea">Tea</h1><h2 id="section">20250303</h2><h3 id="problem">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1420/B">Rock andLever</a></p><p>输入 T(≤10) 表示 T 组数据。所有数据的 n 之和 ≤1e5。<br>每组数据输入 n(1≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>输出有多少对 (i, j)，满足 i &lt; j 且 (a[i] &amp; a[j]) &gt;= (a[i] ^a[j])。</p><h3 id="example">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-number">1</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>3<br>2<br>0<br>0<br></code></pre></td></tr></table></figure><h3 id="solution">Solution</h3><p>分析：如果a[i]和a[j]的最高位都为1,那么a[i]&amp;a[j]严格大于a[i]<sup>a</sup>[j]。若一个为0一个为1，此时a[i]^ a[j]严格大于a[i]&amp;a[j].</p><p>所以使用map维护数组a相同最高位的个数，使用组合加起来即位为答案。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">lowbits</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br><span class="hljs-keyword">return</span> x &amp; -x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">reverse</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>x = ((x &gt;&gt; <span class="hljs-number">1</span>)  &amp; <span class="hljs-number">0x55555555</span>) | ((x &amp; <span class="hljs-number">0x55555555</span>) &lt;&lt; <span class="hljs-number">1</span>);<br>x = ((x &gt;&gt; <span class="hljs-number">2</span>)  &amp; <span class="hljs-number">0x33333333</span>) | ((x &amp; <span class="hljs-number">0x33333333</span>) &lt;&lt; <span class="hljs-number">2</span>);<br>x = ((x &gt;&gt; <span class="hljs-number">4</span>)  &amp; <span class="hljs-number">0x0f0f0f0f</span>) | ((x &amp; <span class="hljs-number">0x0f0f0f0f</span>) &lt;&lt; <span class="hljs-number">4</span>);<br>x = ((x &gt;&gt; <span class="hljs-number">8</span>)  &amp; <span class="hljs-number">0x00ff00ff</span>) | ((x &amp; <span class="hljs-number">0x00ff00ff</span>) &lt;&lt; <span class="hljs-number">8</span>);<br>x = ((x &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0x0000ffff</span>) | ((x &amp; <span class="hljs-number">0x0000ffff</span>) &lt;&lt; <span class="hljs-number">16</span>);<br><span class="hljs-keyword">return</span> x;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">highbit</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">lowbits</span>(<span class="hljs-built_in">reverse</span>(x)));<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>        m[<span class="hljs-built_in">highbit</span>(a[i])]++;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : m) &#123;<br>        <span class="hljs-keyword">if</span> (it.second&gt;=<span class="hljs-number">2</span>) &#123;<br>            ans += it.second * (it.second - <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1">20250304</h2><h3 id="problem-1">Problem</h3><p><a href="https://codeforces.com/problemset/problem/159/D">Palindromepairs</a></p><p>输入长度 ≤2000 的字符串 s，只包含小写英文字母。</p><p>从 s 中选两个不重叠的非空回文子串，有多少种选法？<br>正式地，计算四元组 (i,j,p,q) 的个数，其中 1≤i≤j&lt;p≤q≤n 且 s[i..j] 和s[p..q] 都是回文串。</p><p>【灵茶の试炼】题目&amp;题解<br><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz" class="uri">https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz</a></p><h3 id="example-1">Example</h3><p>输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aa</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">aaa</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abacaba</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">36<br></code></pre></td></tr></table></figure><h3 id="solution-1">Solution</h3><ol type="1"><li><strong>找出所有回文子串</strong><br>使用中心扩展法，遍历每个可能的中心点（奇数和偶数长度），向两边扩展，记录所有回文子串的起始和结束位置。</li><li><strong>统计起始位置</strong><br>对于每个回文子串，记录其起始位置的出现次数，保存在<code>cnt_start</code> 数组中。</li><li><strong>构建后缀和数组</strong><br>构建 <code>suffix</code> 数组，其中 <code>suffix[i]</code> 表示从位置<code>i</code>到字符串末尾的所有回文子串的起始位置总和。通过从右向左遍历累加实现。</li><li><strong>计算合法对的数量</strong><br>遍历每个回文子串，利用 <code>suffix</code>数组快速查询以当前子串结尾后的所有可能的合法后续回文子串数目，累加得到答案。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">expand</span><span class="hljs-params">(string &amp;s, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right, vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; &amp;pals)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> (left &gt;= <span class="hljs-number">0</span> &amp;&amp; right &lt; s.<span class="hljs-built_in">size</span>() &amp;&amp; s[left] == s[right]) &#123;<br>        pals.<span class="hljs-built_in">emplace_back</span>(left, right);<br>        left--;<br>        right++;<br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    vector&lt;pii&gt; pals;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-built_in">expand</span>(s, i, i, pals);<br>        <span class="hljs-built_in">expand</span>(s, i, i + <span class="hljs-number">1</span>, pals);<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">cnt_start</span><span class="hljs-params">(n, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p:pals) &#123;<br>        cnt_start[p.first]++;<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">suffix</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        suffix[i] = suffix[i<span class="hljs-number">+1</span>]+cnt_start[i];<br>    &#125;<br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp; p: pals) &#123;<br>        <span class="hljs-type">int</span> end = p.second;<br>        <span class="hljs-keyword">if</span> (end + <span class="hljs-number">1</span> &lt; n) &#123;<br>            total += suffix[end + <span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; total &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-2">20250305</h2><h3 id="problem-2">Problem</h3><p><a href="https://codeforces.com/problemset/problem/137/D">Palindromes</a></p><p>输入长度 ≤500 的字符串 s，包含大小写英文字母。<br>输入 k(1≤k≤|s|)。</p><p>每次操作，你可以把一个 s[i] 改成任意字符。<br>把 s 分割为至多 k个非空子串，要求每个子串都是回文串，最少要修改多少次？</p><p>第一行，输出最少修改次数。<br>第二行，输出修改后的字符串，并用 '+' 表示分割位置，详见样例。<br>如果有多种分割方案，输出其中任意一种。</p><h3 id="example-2">Example</h3><p>输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">abacaba</span><br><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>abacaba<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">abdcaba</span><br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>abdcdba<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">abdcaba</span><br><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs css"><span class="hljs-number">0</span><br><span class="hljs-selector-tag">a</span>+<span class="hljs-selector-tag">b</span>+d+c+aba<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">abacababababbcbabcd</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>abacaba+babab+bcbabcb<br></code></pre></td></tr></table></figure><h3 id="solution-2">Solution</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> k;<br>    string s;<br>    cin &gt;&gt; s &gt;&gt; k;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">mc</span>(n, <span class="hljs-built_in">vi</span>(n, <span class="hljs-number">0</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;<br>            mc[i][j] = mc[i + <span class="hljs-number">1</span>][j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (s[i] != s[j]) &#123;<br>                mc[i][j]++;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">fr</span>(k, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">0</span>));<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">f</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        f[j] = mc[<span class="hljs-number">0</span>][j];<br>    &#125;<br>    <span class="hljs-type">int</span> minF = f[n - <span class="hljs-number">1</span>], minK = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; k; ++i) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">new_f</span><span class="hljs-params">(n, <span class="hljs-number">1e9</span>)</span></span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = n - <span class="hljs-number">1</span>; r &gt;= i; --r) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = i; l &lt;= r; ++l) &#123;<br>                <span class="hljs-type">int</span> val = f[l - <span class="hljs-number">1</span>] + mc[l][r];<br>                <span class="hljs-keyword">if</span> (val &lt; new_f[r]) &#123;<br>                    new_f[r] = val;<br>                    fr[i][r] = l;<br>                &#125;<br>            &#125;<br>        &#125;<br>        f = <span class="hljs-built_in">move</span>(new_f);<br>        <span class="hljs-keyword">if</span> (f[n - <span class="hljs-number">1</span>] &lt; minF) &#123;<br>            minF = f[n - <span class="hljs-number">1</span>];<br>            minK = i;<br>        &#125;<br>    &#125;<br>    vector&lt;string&gt; path;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = minK, r = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        <span class="hljs-type">int</span> l = fr[i][r];<br>        string t = s.<span class="hljs-built_in">substr</span>(l, r - l + <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>, m = t.<span class="hljs-built_in">size</span>(); j &lt; m / <span class="hljs-number">2</span>; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (t[j] != t[m - <span class="hljs-number">1</span> - j]) &#123;<br>                t[j] = t[m - <span class="hljs-number">1</span> - j];<br>            &#125;<br>        &#125;<br>        path.<span class="hljs-built_in">push_back</span>(t);<br>        r = l - <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(path.<span class="hljs-built_in">begin</span>(), path.<span class="hljs-built_in">end</span>());<br>    <br>    cout &lt;&lt; minF &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; path.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) cout &lt;&lt; <span class="hljs-string">&quot;+&quot;</span>;<br>        cout &lt;&lt; path[i];<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-3">20250306</h2><h3 id="problem-3">Problem</h3><p><a href="https://codeforces.com/problemset/problem/835/D">Palindromiccharacteristics</a></p><p>输入长度 ≤5000 的字符串 s，只包含小写英文字母。</p><p>如果字符串 s 是回文串，我们称 s 为 1 阶回文串。<br>如果字符串 s 的左半部分等于 s 的右半部分，且左半部分和右半部分都是 k-1阶回文串，我们称 s 为 k 阶回文串（k &gt; 1）。<br>注：设 m = floor(len(s)/2)，「左半部分」指 s 的长为 m的前缀，「右半部分」指 s 的长为 m 的后缀。</p><p>输出 n 个数，分别表示 s 的 1,2,3,...,n 阶非空回文子串的个数。</p><h3 id="example-3">Example</h3><p>输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abba</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">6 </span><span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs ebnf"><span class="hljs-attribute">abacaba</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">12 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="solution-3">Solution</h3><p>由题意可得，一个k阶字符串一定是回文串，同时也一定是1<sub>k</sub>-1阶字符串。</p><p>定义 isPal[l] [r] 表示 s[l] 到 s[r] 是否为回文串，这可以写个区间DP（或者中心扩展法）预处理。<br>定义 f[l] [r]，表示 s[l] 到 s[r] 最大是 f[l] [r]阶回文串。如果不是回文串则 f[l] [r]=0。</p><p>根据题目的定义，如果 s[l] 到 s[r] 是回文串，那么有<br>f[l] [r] = f[l] [(l+r-1)/2] + 1，即左半部分的阶数加一。<br>初始值 f[i] [i] = 1，其余为 0。</p><p>统计 f[l] [r] 的出现次数，记作 ans。<br>注意 ans[k] 统计的是最大为 k 阶的回文子串个数。<br>由于 k 阶回文串一定是 k-1 阶回文串，所以计算 ans的后缀和，就是题目要算的东西了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>();<br>    vector&lt;vector&lt;<span class="hljs-type">bool</span>&gt;&gt; <span class="hljs-built_in">isPal</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">bool</span>&gt;(n, <span class="hljs-literal">false</span>));<br>    vector&lt;vector&lt;<span class="hljs-type">short</span>&gt;&gt; <span class="hljs-built_in">order</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">short</span>&gt;(n, <span class="hljs-number">0</span>));<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; ++len) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l + len - <span class="hljs-number">1</span> &lt; n; ++l) &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>                isPal[l][r] = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (len == <span class="hljs-number">2</span>) &#123;<br>                isPal[l][r] = (s[l] == s[r]);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                isPal[l][r] = (s[l] == s[r] &amp;&amp; isPal[l<span class="hljs-number">+1</span>][r<span class="hljs-number">-1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> len = <span class="hljs-number">1</span>; len &lt;= n; ++len) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l + len - <span class="hljs-number">1</span> &lt; n; ++l) &#123;<br>            <span class="hljs-type">int</span> r = l + len - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (isPal[l][r]) &#123;<br>                <span class="hljs-keyword">if</span> (len == <span class="hljs-number">1</span>) &#123;<br>                    order[l][r] = <span class="hljs-number">1</span>;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-type">int</span> current_order = <span class="hljs-number">1</span>;<br>                    <span class="hljs-type">int</span> left_l, left_r, right_l, right_r;<br>                    <span class="hljs-keyword">if</span> (len % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-type">int</span> mid = len / <span class="hljs-number">2</span>;<br>                        left_l = l;<br>                        left_r = l + mid - <span class="hljs-number">1</span>;<br>                        right_l = l + mid;<br>                        right_r = r;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-type">int</span> mid = len / <span class="hljs-number">2</span>;<br>                        left_l = l;<br>                        left_r = l + mid - <span class="hljs-number">1</span>;<br>                        right_l = l + mid + <span class="hljs-number">1</span>;<br>                        right_r = r;<br>                    &#125;<br>                    <span class="hljs-keyword">if</span> (isPal[left_l][left_r] &amp;&amp; isPal[right_l][right_r] &amp;&amp;<br>                        order[left_l][left_r] == order[right_l][right_r]) <br>                    &#123;<br>                        current_order = order[left_l][left_r] + <span class="hljs-number">1</span>;<br>                    &#125;<br>                    order[l][r] = current_order;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(n + <span class="hljs-number">2</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = <span class="hljs-number">0</span>; l &lt; n; ++l) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt; n; ++r) &#123;<br>            <span class="hljs-keyword">if</span> (isPal[l][r]) &#123;<br>                <span class="hljs-type">int</span> k = order[l][r];<br>                <span class="hljs-keyword">if</span> (k &lt;= n) ans[k]++;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>        ans[i] += ans[i + <span class="hljs-number">1</span>];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="codeforces" scheme="http://polaris3003.github.io/categories/codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture14</title>
    <link href="http://polaris3003.github.io/2025/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%A7%84%E5%88%92%E5%92%8C%E4%BC%98%E5%8C%96/"/>
    <id>http://polaris3003.github.io/2025/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%A7%84%E5%88%92%E5%92%8C%E4%BC%98%E5%8C%96/</id>
    <published>2025-02-06T08:36:40.000Z</published>
    <updated>2025-11-02T17:27:19.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="第十四课查询规划和优化">第十四课：查询规划和优化</h1><h2 id="概述">1 概述</h2><p>由于SQL是声明式语言，查询语句仅告知数据库管理系统(DBMS)需要计算什么，而非如何计算。因此，DBMS需要将SQL语句转换为可执行的查询计划。但查询计划中每个操作符存在多种执行方式（例如连接算法的选择），不同计划的性能表现也存在差异。DBMS优化器的核心任务就是为给定查询选择最优计划。</p><p>查询优化器的首个实现是20世纪70年代设计的IBM SystemR。在此之前，人们普遍认为DBMS无法生成优于人工设计的查询计划。SystemR优化器的诸多概念和设计决策至今仍被沿用。当前查询优化主要采用两种高层策略：<br>1.<strong>静态规则（启发式方法）</strong>：通过匹配查询中的已知模式来构建计划，利用规则消除低效操作。这类规则可能需参考目录以理解数据结构，但无需实际扫描数据。<br>2.<strong>基于代价的搜索</strong>：通过读取数据并估算等效计划的执行代价，由代价模型选择最低成本的方案。</p><p>查询优化是构建DBMS最具挑战性的环节。尽管已有研究尝试应用机器学习提升优化器的准确性和效率，但目前尚无主流DBMS部署基于该技术的优化器。</p><h3 id="逻辑计划与物理计划">逻辑计划与物理计划</h3><p>优化器负责将逻辑代数表达式映射为最优的等价物理代数表达式。逻辑计划大致等同于查询中的关系代数表达式。</p><p>物理运算符通过为查询计划中的不同运算符定义特定的访问路径来确立具体的执行策略。物理计划可能会依赖于被处理数据的物理格式（例如排序方式、压缩形式）。</p><p>从逻辑计划到物理计划的映射并不总是存在一一对应关系。</p><h2 id="逻辑查询优化">2 逻辑查询优化</h2><p>部分选择优化策略包括：<br>• 尽早执行过滤操作（谓词下推）<br>• 重新排序谓词，使DBMS优先应用最具选择性的谓词<br>• 分解复杂谓词并进行下推（拆分合取谓词）</p><p><img src="/2025/02/06/%E7%AC%AC%E5%8D%81%E5%9B%9B%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E8%A7%84%E5%88%92%E5%92%8C%E4%BC%98%E5%8C%96/image-20250330213614273.png" alt="图1：架构概览 - 应用程序连接数据库系统并发送SQL查询，该查询可能被重写为不同格式。SQL字符串被解析为构成语法树的标记。绑定器通过查询系统目录，将语法树中的命名对象转换为内部标识符。绑定器输出一个逻辑计划，该计划可能被送入树重写器以获取额外的模式信息。逻辑计划随后交给优化器，由优化器选择执行该计划的最有效方案。"></p><iframe width="920" height="520" src="https://www.youtube.com/embed/HjCG2ihLb98" title="The China You Won’t See Anywhere Else" frameborder="0" allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;第十四课查询规划和优化&quot;&gt;第十四课：查询规划和优化&lt;/h1&gt;
&lt;h2 id=&quot;概述&quot;&gt;1 概述&lt;/h2&gt;
&lt;p&gt;由于SQL是声明式语言，查询语句仅告知数据库管理系统(DBMS)需要计算什么，而非如何计算。因此，DBMS需要将SQL语句转换为可执行的查询计划。但</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
  </entry>
  
  <entry>
    <title>茶-2025-02</title>
    <link href="http://polaris3003.github.io/2025/02/05/Tea202502/"/>
    <id>http://polaris3003.github.io/2025/02/05/Tea202502/</id>
    <published>2025-02-05T06:08:51.000Z</published>
    <updated>2025-02-28T02:38:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tea">Tea</h1><h2 id="section">20250203</h2><h3 id="problem">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1996/C">Sort</a></p><p>输入 T(≤1e3) 表示 T 组数据。所有数据的 n 之和 ≤2e5，q 之和≤2e5。<br>每组数据输入 n(1≤n≤2e5)，q(1≤q≤2e5)，长为 n 的字符串 s，长为 n 的字符串t，都只包含小写英文字母。<br>然后输入 q 个询问，每个询问输入两个数 L 和 R，表示下标从 L 到 R 的子串(1≤L≤R≤n) s[L..R] 和 t[L..R]。</p><p>对于每个询问，你可以修改 s[L..R] 中的若干字母，使得 s[L..R] 和t[L..R] 排序后相等。<br>输出最小修改次数。</p><p>注意：每个询问互相独立。</p><p>进阶：值域更大的情况 <a href="https://atcoder.jp/contests/abc367/tasks/abc367_f"><strong>RearrangeQuery</strong></a></p><h3 id="example">Example</h3><p>输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">5</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">abcde</span><br><span class="hljs-attribute">edcba</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">5</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">3</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">4</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">zzde</span><br><span class="hljs-attribute">azbe</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">6</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">uwuwuw</span><br><span class="hljs-attribute">wuwuwu</span><br><span class="hljs-attribute">2</span> <span class="hljs-number">4</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">3</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>1<br>0<br>2<br>2<br>1<br>1<br>0<br></code></pre></td></tr></table></figure><h3 id="solution">Solution</h3><p>问题相当于计算这两个子串每种字母个数之差的总和。<br>由于一次操作可以把 s 中的多余字母变成 t 中的缺失字母，所以总和除以 2便是答案。</p><p>字母个数之差可以用前缀和处理。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    string a,b;<br>    cin &gt;&gt; a &gt;&gt; b;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">sum</span>(n<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">26</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        sum[i<span class="hljs-number">+1</span>] = sum[i];<br>        sum[i<span class="hljs-number">+1</span>][a[i]-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>        sum[i<span class="hljs-number">+1</span>][b[i]-<span class="hljs-string">&#x27;a&#x27;</span>]--;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">26</span>; i++) &#123;<br>            ans += <span class="hljs-built_in">abs</span>(sum[r][i]-sum[l<span class="hljs-number">-1</span>][i]);<br>        &#125;<br>        cout &lt;&lt; ans/<span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1">20250204</h2><h3 id="problem-1">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1878/E">Iva &amp;Pav</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5，q 之和≤2e5。<br>每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，下标从 1开始。<br>然后输入 q(1≤q≤1e5) 和 q 个询问，每个询问输入 L(1≤L≤n) 和k(1≤k≤1e9)。</p><p>对于每个询问，输出最大的 R，满足非空连续子数组 a[L]<sub>a</sub>[R] 的AND &gt;= k。<br>如果不存在这样的 R，输出 -1。</p><h3 id="example-1">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">15 </span><span class="hljs-number">14</span> <span class="hljs-number">17</span> <span class="hljs-number">42</span> <span class="hljs-number">34</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">15</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-number">7</span><br><span class="hljs-symbol">19 </span><span class="hljs-number">20</span> <span class="hljs-number">15</span> <span class="hljs-number">12</span> <span class="hljs-number">21</span> <span class="hljs-number">7</span> <span class="hljs-number">11</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">15</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">12</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span>-<span class="hljs-number">1</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> -<span class="hljs-number">1</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="solution-1">Solution</h3><p>通过每一位计算前缀和，然后二分运算结果，找到最大满足的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">solve</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vi <span class="hljs-title function_">a</span><span class="hljs-params">(n)</span>;<br>    cnv(a);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-title function_">prefix</span><span class="hljs-params">(<span class="hljs-number">31</span>, vi(n+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>)</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; b &lt; <span class="hljs-number">31</span>; ++b) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            prefix[b][i+<span class="hljs-number">1</span>] = prefix[b][i] + ((a[i]&gt;&gt;b)&amp;<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        <span class="hljs-type">int</span> l,k;<br>        cin &gt;&gt; l &gt;&gt; k;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> l - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (left &gt;= n) &#123;<br>            cout &lt;&lt; -<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">low</span> <span class="hljs-operator">=</span> left;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">high</span> <span class="hljs-operator">=</span> n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">ans</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">mid</span> <span class="hljs-operator">=</span> (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">current_and</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">b</span> <span class="hljs-operator">=</span> <span class="hljs-number">30</span>; b &gt;= <span class="hljs-number">0</span>; --b) &#123;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">cnt</span> <span class="hljs-operator">=</span> prefix[b][mid + <span class="hljs-number">1</span>] - prefix[b][left];<br>                <span class="hljs-keyword">if</span> (cnt == (mid - left + <span class="hljs-number">1</span>)) &#123;<br>                    current_and |= (<span class="hljs-number">1</span> &lt;&lt; b);<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">remaining_bits_mask</span> <span class="hljs-operator">=</span> (<span class="hljs-number">1</span> &lt;&lt; b) - <span class="hljs-number">1</span>;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">possible_max</span> <span class="hljs-operator">=</span> current_and | remaining_bits_mask;<br>                <span class="hljs-keyword">if</span> (possible_max &lt; k) &#123;<br>                    <span class="hljs-keyword">break</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (current_and &gt;= k) &#123;<br>                ans = mid;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (ans != -<span class="hljs-number">1</span>) &#123;<br>            cout &lt;&lt; ans + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; -<span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-2">20250205</h2><h3 id="problem-2">Problem</h3><p><a href="https://atcoder.jp/contests/abc117/tasks/abc117_d"><strong>XXOR</strong></a></p><p>输入 n(1≤n≤1e5) k(0≤k≤1e12) 和长为 n 的数组 a(0≤a[i]≤1e12)。</p><p>选择一个 [0,k] 中的整数 x，最大化 (x XOR a[1]) + (x XOR a[2]) + ... +(x XOR a[n])。<br>输出这个最大值。</p><h3 id="example-2">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">14<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">4</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">46<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span><br><span class="hljs-number">1000000000000</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1000000000000<br></code></pre></td></tr></table></figure><h3 id="solution-2">Solution</h3><p>核心思路：<br>拆位，对于每个比特位，如果这一位 1 多，那么 x 这一位取 0更合适；如果这一位 0 多，那么 x 这一位取 1 更合适。<br>设从低到高第 i 个比特位的 1 的个数是cnt1[i]，那么这个比特位对答案的贡献是 max(cnt1[i], n-cnt1[i]) &lt;&lt;i。</p><p>但是，x 的值受到 k 的约束，怎么处理？</p><p>为方便计算，下面讨论的是 k+1。<br>从最高位 i=39 开始枚举。<br>如果 k+1 在最高位是 1，且 x 在这一位是 0，那么 x 在更低的比特位上可以是0 也可以是 1（不受 k 的约束）。<br>直接累加所有 max(cnt1[i], n-cnt1[i]) &lt;&lt; j（其中 j &lt;i），更新答案的最大值。<br>更新之后，剩下需要讨论的是 x 在这一位一定是 1 的情况。我们先把(n-cnt1[i]) &lt;&lt; i 加入变量 pre 中，然后把 i减一，继续讨论后续的比特位。</p><p>如果 k+1 在第 i 位是 0，那么 x 在这一位也只能是 0，跳过。把 cnt1[i]&lt;&lt; i 加入变量 pre 中。<br>如果 k+1 在第 i 位是 1，且 x 在这一位是0，那么更低的比特位可以随便选（不受约束），累加 max(cnt1[i], n-cnt1[i])&lt;&lt; j（其中 j &lt; i），再加上 pre 以及 cnt1[i] &lt;&lt;i，更新答案的最大值。</p><p>代码实现时，可以提前计算低 i 位的所有 max(cnt1[i], n-cnt1[i])&lt;&lt; i 之和，记作 suf[i+1]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countTrailingZeros</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> ((x &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; x &gt; <span class="hljs-number">0</span>) &#123;<br>        count++;<br>        x &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> count;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mx = <span class="hljs-number">40</span>;<br>    <span class="hljs-type">int</span> n,k,v,pre=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vi <span class="hljs-title">cnt</span><span class="hljs-params">(mx,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; v;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = v; j &gt; <span class="hljs-number">0</span>; j &amp;= (j<span class="hljs-number">-1</span>)) &#123;<br>            cnt[<span class="hljs-built_in">countTrailingZeros</span>(j)]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//print(cnt);cout &lt;&lt; endl;</span><br>    <span class="hljs-function">vi <span class="hljs-title">suf</span><span class="hljs-params">(mx<span class="hljs-number">+1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; mx; i++) &#123;<br>        suf[i<span class="hljs-number">+1</span>] = suf[i] + (<span class="hljs-built_in">max</span>(cnt[i], n-cnt[i])&lt;&lt;i);<br>    &#125;<br>    <span class="hljs-comment">//print(suf);cout &lt;&lt; endl;</span><br>    k++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mx - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (((k &gt;&gt; i) &amp; <span class="hljs-number">1</span>) &gt; <span class="hljs-number">0</span>) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, pre+(cnt[i]&lt;&lt;i)+suf[i]);<br>            pre += (n-cnt[i])&lt;&lt;i;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            pre += cnt[i]&lt;&lt;i;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-3">20250206</h2><h3 id="problem-3">Problem</h3><p><a href="https://atcoder.jp/contests/abc129/tasks/abc129_e"><strong>SumEquals Xor</strong></a></p><p>输入一个长度至多为 1e5+1 的二进制字符串 s，不含前导零。</p><p>把 s 当作一个二进制数。<br>输出有多少对非负整数 (a,b)，满足 a + b &lt;= s 且 a + b = a XORb。<br>答案模 1e9+7。</p><h3 id="example-3">Example</h3><p>输入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">10<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1111111111111111111<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">162261460</span><br></code></pre></td></tr></table></figure><h3 id="solution-3">Solution</h3><p>a + b = a XOR b 意味着加法不能有进位，也就是同一个比特位不能都是1。</p><p>下面以 s=100100 为例。</p><p>对于最高位的 s[0]=1，如果 a+b 在这一位是 0，那么对于 a+b来说，右边的每个比特位可以填 0 也可以填 1。也就是 a+b = 0xxxxx。<br>对于 a 和 b，在 x 填什么，有三种情况：都是 0，一个是 0 另一个是1。<br>由于每一位互相独立，有 pow(3, n-1-i) 种方案（其中 n 是 s的长度，i=0）。</p><p>对于另一个 s[3]=1，同理，如果 a+b 在这一位是 0，那么对于 a+b来说，右边的每个比特位可以填 0 也可以填 1。也就是 a+b = 1000xx。<br>对于 a 和 b，在 x 填什么，有三种情况：都是 0，一个是 0 另一个是1。<br>再算上前面的 s[0]=1 这一位，a 和 b 必须一个是 0 另一个 1，所以有 pow(2,pre1) * pow(3, n-1-i) 种方案（其中 pre1=1，i=3）。</p><p>最后算上 a+b 恰好等于 s 的情况，有 pow(2, cnt1) 种方案（其中 cnt1 是s 中的 1 的个数）。</p><p>计算 pow 用快速幂。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>,pow2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            ans = (ans + pow2*<span class="hljs-built_in">mypow</span>(<span class="hljs-number">3</span>, s.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>-i)) % mod;<br>            pow2 = pow2 * <span class="hljs-number">2</span> % mod;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; (ans + pow2) % mod &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-4">20250207</h2><h3 id="problem-4">Problem</h3><p><a href="https://atcoder.jp/contests/abc194/tasks/abc194_f"><strong>DigitsParadise in Hexadecimal</strong></a></p><p>输入长度 ≤2e5 的字符串 s 和整数 k(1≤k≤16)。<br>s 表示一个十六进制数，无前导零。</p><p>在 [1,s] 中，有多少个（无前导零的）十六进制数，恰好包含 k个不同的数字？这里的数字指 0<sub>9</sub> 和 A<sub>F</sub>。<br>答案模 1e9+7。</p><h3 id="example-4">Example</h3><p>输入 10 1<br>输出 15</p><p>输入 FF 2<br>输出 225</p><p>输入 100 2<br>输出 226</p><p>输入 1A8FD02 4<br>输出 3784674</p><p>输入 DEADBEEFDEADBEEEEEEEEF 16<br>输出 153954073</p><h3 id="solution-4">Solution</h3><p>数位 DP。</p><p>考虑把填入的数字用位运算状压成一个mask，这样我们可以知道有多少个不同数字。<br>但是 (i, mask) 状态个数太多了，如何简化？</p><p>如果后续填入的数字，不受到 s 的约束，那么考虑以下两种情况：<br>前面填的数字有 1,2,3。<br>前面填的数字有 2,3,4。<br>虽然填入的数字不同，但是不同数字的个数是相同的，这意味着后面填【其他数字】的方案数是【等价】的：<br>前面填的数字有 1,2,3 的情况下，后面填 1，不改变 mask；后面填 4，那么mask 会多一个比特位。<br>前面填的数字有 2,3,4 的情况下，后面填 2，不改变 mask；后面填 1，那么mask 会多一个比特位。<br>这种mask【是否改变】，对于这两种情况都是等价的（或者说可以找到一一对应关系）。</p><p>所以我们只需要记忆化 (i, mask 中的 1 的个数) 这个状态。<br>于是状态个数大大减少，总体时间复杂度为 O(nk<sup>2</sup>)。</p><p>注意前导零影响答案，可以写 isNum 参数，或者根据 mask 是否为 0来判断。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    <span class="hljs-type">int</span> k;<br>    cin &gt;&gt; s &gt;&gt; k;<br><br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">memo</span>(s.<span class="hljs-built_in">length</span>(), <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(k + <span class="hljs-number">1</span>, <span class="hljs-number">-1</span>));<br><br>    <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> mask, <span class="hljs-type">bool</span> isLimit, <span class="hljs-keyword">auto</span>&amp;&amp; self) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-type">int</span> c = __builtin_popcount(mask);<br>        <span class="hljs-keyword">if</span> (c &gt; k) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i == s.<span class="hljs-built_in">length</span>()) &#123;<br>            <span class="hljs-keyword">if</span> (c &lt; k) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; mask &gt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-type">int</span>&amp; res = memo[i][c];<br>            <span class="hljs-keyword">if</span> (res &gt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> res = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (mask == <span class="hljs-number">0</span>) &#123;<br>            res += <span class="hljs-built_in">self</span>(i + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">false</span>, self);<br>        &#125;<br>        <span class="hljs-type">int</span> up = <span class="hljs-number">15</span>;<br>        <span class="hljs-keyword">if</span> (isLimit) &#123;<br>            <span class="hljs-keyword">if</span> (s[i] &lt;= <span class="hljs-string">&#x27;9&#x27;</span>) &#123;<br>                up = s[i] - <span class="hljs-string">&#x27;0&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                up = <span class="hljs-number">10</span> + (s[i] - <span class="hljs-string">&#x27;A&#x27;</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> d = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">if</span> (mask == <span class="hljs-number">0</span>) &#123;<br>            d = <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (; d &lt;= up; d++) &#123;<br>            res += <span class="hljs-built_in">self</span>(i + <span class="hljs-number">1</span>, mask | (<span class="hljs-number">1</span> &lt;&lt; d), isLimit &amp;&amp; d == up, self);<br>            res %= MOD;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!isLimit &amp;&amp; mask &gt; <span class="hljs-number">0</span>) &#123;<br>            memo[i][c] = res;<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;;<br><br>    cout &lt;&lt; <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-literal">true</span>, dfs) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-5">20250210</h2><h3 id="problem-5">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1909/B">MakeAlmost Equal With Mod</a></p><p>输入 T(≤500) 表示 T 组数据。<br>每组数据输入 n(2≤n≤100) 和长为 n 的数组 a(1≤a[i]≤1e17)。保证所有 a[i]互不相同。</p><p>找到一个在 [1,1e18] 中的 k，使得所有 a[i]%=k 后，a中恰好有两个不同的数，即 len(set(a)) == 2。<br>输出这个 k。如果有多个答案，输出任意一个。</p><p>可以证明，答案是存在的。</p><h3 id="example-5">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-number">4</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">15</span> <span class="hljs-number">22</span> <span class="hljs-number">30</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">60 </span><span class="hljs-number">90</span> <span class="hljs-number">98</span> <span class="hljs-number">120</span> <span class="hljs-number">308</span><br><span class="hljs-number">6</span><br><span class="hljs-symbol">328 </span><span class="hljs-number">769</span> <span class="hljs-number">541</span> <span class="hljs-number">986</span> <span class="hljs-number">215</span> <span class="hljs-number">734</span><br><span class="hljs-number">5</span><br><span class="hljs-symbol">1000 </span><span class="hljs-number">2000</span> <span class="hljs-number">7000</span> <span class="hljs-number">11000</span> <span class="hljs-number">16000</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">7</span><br><span class="hljs-number">30</span><br><span class="hljs-number">3</span><br><span class="hljs-number">5000</span><br><span class="hljs-number">1000000000000000000</span><br></code></pre></td></tr></table></figure><h3 id="solution-5">Solution</h3><p>取模后恰好有两种不同的数？试试二进制。</p><p>计算所有二进制 a[i] 的最长公共后缀。<br>例如下面三个二进制数：<br>1110<br>0010<br>1010<br>最长公共后缀是 10。<br>只要取这三个数的低三位（也就是模 8），结果必然是两个不同的数。</p><p>如何计算最长公共后缀？<br>设所有 a[i] 的 OR 为 or，所有 a[i] 的 AND 为 and。<br>例如上面的三个数，or=1110，and=0010。<br>从 or 中去掉 and 的比特位，即 or ^= and，可以得到 1100。<br>这个数的 lowbit 再左移 1 位，就是答案 1000。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,v;<br>    cin &gt;&gt; n;<br>    <span class="hljs-type">int</span> o = <span class="hljs-number">0</span>, a = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; v;<br>        o |= v;<br>        a &amp;= v;<br>    &#125;<br>    o = o^a;<br>    cout &lt;&lt; ((o&amp;-o)&lt;&lt;<span class="hljs-number">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-6">20250211</h2><h3 id="problem-6">Problem</h3><p><a href="https://atcoder.jp/contests/abc281/tasks/abc281_d" class="uri">https://atcoder.jp/contests/abc281/tasks/abc281_d</a></p><p>输入 n(1≤n≤100) k(1≤k≤n) d(1≤d≤100) 和长为 n 的数组a(0≤a[i]≤1e9)。</p><p>从 a 中选出恰好 k 个数，满足元素和恰好是 d 的倍数。</p><p>输出元素和的最大值。<br>如果无法得到 d 的倍数，输出 -1。</p><h3 id="example-6">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><h3 id="solution-6">Solution</h3><p>恰好装满型二维 0-1 背包。</p><p>k 是背包的第一类容量上限，d-1 是背包的第二类容量上限。<br>a[i] 看成一个体积为 (1,a[i])，价值为 a[i] 的物品。</p><p>定义 f[i+1] [j] [s] 表示 a[0]<sub>a</sub>[i] 中选 j 个，元素和模 k的结果为 s 时，所选元素的最大和。如果没有这样的元素和，f[i+1] [j][s]=-inf。<br>考虑第 i 个物品 a[i] 选或不选：<br>不选，问题变成 f[i] [j] [s]。<br>选，问题变成 f[i] [j-1] [s']，其中 s' = ((s - a[i]) % d + d) % d。<br>两种情况取最大值，得 f[i+1] [j] [s] = max(f[i] [j] [s], f[i] [j-1][s']+a[i])。</p><p>初始值 f [0] [0] [0] = 0，其余为 -inf。<br>答案为 f [n] [k] [0]。如果答案为 -inf，输出 -1。</p><p>代码实现时，f 的第一个维度可以优化掉，j需要倒序循环，避免覆盖状态。</p><p>注意用 64 位整数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k,d;<br>    cin &gt;&gt; n &gt;&gt; k &gt;&gt; d;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">cnv</span>(a);<br>    <span class="hljs-type">int</span> inf = -INF;<br>    <span class="hljs-function">vector&lt;vi&gt; <span class="hljs-title">dp</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, vi(d, inf))</span></span>;<br>    dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : a) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; d; ++j) &#123;<br>                <span class="hljs-keyword">if</span> (dp[i<span class="hljs-number">-1</span>][j] != inf) &#123;<br>                    <span class="hljs-type">int</span> new_mod = (j + num) % d;<br>                    dp[i][new_mod] = <span class="hljs-built_in">max</span>(dp[i][new_mod], dp[i - <span class="hljs-number">1</span>][j] + num);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> result = dp[k][<span class="hljs-number">0</span>];  <br>    cout &lt;&lt; (result != inf ? result : <span class="hljs-number">-1</span>) &lt;&lt; endl; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-7">20250212</h2><h3 id="problem-7">Problem</h3><p><a href="https://atcoder.jp/contests/tenka1-2017/tasks/tenka1_2017_d"><strong>IntegerotS</strong></a></p><p>输入 n(1≤n≤1e5) k(0≤k&lt;2<sup>30</sup>) 和 n 个 pair (ai,bi)，其中0≤ai&lt;2<sup>30</sup>，1≤bi≤1e9。</p><p>从中选择一些 pair，满足所有 ai 的 OR &lt;= k，并且 bi之和越大越好。<br>输出 bi 之和的最大值。</p><h3 id="example-7">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">9<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">7 </span><span class="hljs-number">14</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">11 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">32<br></code></pre></td></tr></table></figure><h3 id="solution-7">Solution</h3><p>从高到低分析 k+1 的每一位：<br>如果是 1，那么如果 OR 的这一位是0，右边所有比特位可以随便选，把所有这一位不是 1的数的价值全部加起来，更新答案的最大值。<br>后续就只需考虑 OR 这一位是 1 的情况下的答案。<br>如果 k+1 这一位是 0，那么这一位是 1的数就不能选（因为我们是从高到低考虑的）。<br>把哪些比特位不能选记录在一个变量 ban 中，所有与 ban 的 AND &gt; 0的数都不能选。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k,ban=<span class="hljs-number">0</span>,ans=<span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;pii&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i].first &gt;&gt; a[i].second;<br>    &#125;<br>    k++;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">30</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> ((k &gt;&gt; i) &amp; <span class="hljs-number">1</span>) &#123;<br>            ban ^= (<span class="hljs-number">1</span> &lt;&lt; i);<br>            <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p: a) &#123;<br>                <span class="hljs-keyword">if</span> ((p.first&amp;ban) == <span class="hljs-number">0</span>) &#123;<br>                    s += p.second;<br>                &#125;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, s);<br>        &#125;<br>        ban ^= <span class="hljs-number">1</span> &lt;&lt; i;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-8">20250213</h2><h3 id="problem-8">Problem</h3><p><a href="https://atcoder.jp/contests/abc215/tasks/abc215_f"><strong>DistMax 2</strong></a></p><p>输入 n(2≤n≤2e5) 和 n 个二维坐标点，范围[0,1e9]。保证所有点互不相同。</p><p>定义两点 (xi,yi) 和 (xj,yj) 的距离为 min(|xi-xj|,|yi-yj|)。</p><p>输出两点之间的最大距离。</p><p>【灵茶の试炼】题目&amp;题解<br><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz" class="uri">https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz</a></p><h3 id="example-8">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">897 </span><span class="hljs-number">729</span><br><span class="hljs-symbol">802 </span><span class="hljs-number">969</span><br><span class="hljs-symbol">765 </span><span class="hljs-number">184</span><br><span class="hljs-symbol">992 </span><span class="hljs-number">887</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">104</span><br><span class="hljs-symbol">521 </span><span class="hljs-number">641</span><br><span class="hljs-symbol">220 </span><span class="hljs-number">909</span><br><span class="hljs-symbol">380 </span><span class="hljs-number">378</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">801<br></code></pre></td></tr></table></figure><h3 id="solution-8">Solution</h3><ol type="1"><li><strong>问题分析：</strong>我们需要找到两个点，使得它们的x坐标差和y坐标差中的最小值最大。直接暴力遍历的话时间复杂度为O(n<sup>2</sup>),不可行。</li><li><strong>观察：</strong>最大的距离d一定满足存在两个点，它们的x坐标差和y坐标差都至少为d。因此可以考虑二分确定最大的d。</li><li><strong>优化：</strong><ul><li>点按x坐标排序</li><li>预处理前缀和后缀数组来快速查询区间内的最小和最大y坐标</li><li>二分确定d，检查是否存在满足条件的点对</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;<br>    <span class="hljs-type">int</span> x,y;<br>&#125;;<br>vector&lt;Point&gt; points;<br><span class="hljs-type">int</span> n;<br>vi pre_min, pre_max, suf_min, suf_max;<br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span> <span class="hljs-params">(<span class="hljs-type">int</span> d)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> x_i = points[i].x;<br>        <span class="hljs-type">int</span> y_i = points[i].y;<br><br>        <span class="hljs-comment">// 左边区间 x_j &lt;= x_i - d</span><br>        <span class="hljs-type">int</span> left = x_i - d;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = i - <span class="hljs-number">1</span>, k = <span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (points[mid].x &lt;= left) &#123;<br>                k = mid;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k != <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (pre_max[k] &gt;= y_i + d || pre_min[k] &lt;= y_i - d) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-comment">// 右边区间 x_j &gt;= x_i + d</span><br>        <span class="hljs-type">int</span> right = x_i + d;<br>        low = i + <span class="hljs-number">1</span>;<br>        high = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> m = n;<br>        <span class="hljs-keyword">while</span> (low &lt;= high) &#123;<br>            <span class="hljs-type">int</span> mid = (low + high) / <span class="hljs-number">2</span>;<br>            <span class="hljs-keyword">if</span> (points[mid].x &gt;= right) &#123;<br>                m = mid;<br>                high = mid - <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (m &lt; n) &#123;<br>            <span class="hljs-keyword">if</span> (suf_max[m] &gt;= y_i + d || suf_min[m] &lt;= y_i - d) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    points.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; points[i].x &gt;&gt; points[i].y;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(points.<span class="hljs-built_in">begin</span>(), points.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> Point&amp; a,<span class="hljs-type">const</span> Point&amp; b) &#123;<br>        <span class="hljs-keyword">return</span> a.x &lt; b.x;<br>    &#125;);<br>    pre_min.<span class="hljs-built_in">resize</span>(n);<br>    pre_max.<span class="hljs-built_in">resize</span>(n);<br>    suf_min.<span class="hljs-built_in">resize</span>(n);<br>    suf_max.<span class="hljs-built_in">resize</span>(n);<br><br>    pre_min[<span class="hljs-number">0</span>] = points[<span class="hljs-number">0</span>].y;<br>    pre_max[<span class="hljs-number">0</span>] = points[<span class="hljs-number">0</span>].y;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        pre_min[i] = <span class="hljs-built_in">min</span>(pre_min[i<span class="hljs-number">-1</span>], points[i].y);<br>        pre_max[i] = <span class="hljs-built_in">max</span>(pre_max[i<span class="hljs-number">-1</span>], points[i].y);<br>    &#125;<br><br>    suf_min[n<span class="hljs-number">-1</span>] = points[n<span class="hljs-number">-1</span>].y;<br>    suf_max[n<span class="hljs-number">-1</span>] = points[n<span class="hljs-number">-1</span>].y;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>        suf_min[i] = <span class="hljs-built_in">min</span>(suf_min[i<span class="hljs-number">+1</span>], points[i].y);<br>        suf_max[i] = <span class="hljs-built_in">max</span>(suf_max[i<span class="hljs-number">+1</span>], points[i].y);<br>    &#125;<br>     <span class="hljs-type">int</span> max_x = points.<span class="hljs-built_in">back</span>().x - points[<span class="hljs-number">0</span>].x;<br>    <span class="hljs-type">int</span> global_min_y = pre_min.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-type">int</span> global_max_y = pre_max.<span class="hljs-built_in">back</span>();<br>    <span class="hljs-type">int</span> max_y_diff = global_max_y - global_min_y;<br><br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>, right = <span class="hljs-built_in">max</span>(max_x, max_y_diff);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">while</span> (left &lt;= right) &#123;<br>        <span class="hljs-type">int</span> mid = (left + right) / <span class="hljs-number">2</span>;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">check</span>(mid)) &#123;<br>            ans = mid;<br>            left = mid + <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            right = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-9">20250214</h2><h3 id="problem-9">Problem</h3><p><a href="https://atcoder.jp/contests/arc107/tasks/arc107_d"></a></p><p>输入 n k (1≤k≤n≤3000)。</p><p>输出有多少个多重集合，满足如下条件：<br>1. 恰好有 n 个元素。<br>2. 每个元素都是 1/2<sup>i</sup>，即 1, 1/2, 1/4, 1/8, ...中的一个。<br>3. 这 n 个数的和恰好等于 k。<br>答案模 998244353。</p><h3 id="example-9">Example</h3><p>输入 4 2<br>输出 2<br>解释 {1,1/2,1/4,1/4} 和 {1/2,1/2,1/2,1/2} 这两个多重集合满足要求。</p><p>输入 2525 425<br>输出 687232272</p><h3 id="solution-9">Solution</h3><p>定义 f[i] [j] 表示 i 个数且元素和为 j 的多重集合个数，并且这 i个数都是 1, 1/2, 1/4, ...<br>如果这 i 个数里面至少有 1 个 1，那么去掉这个 1，问题变成 i-1个数且元素和为 j-1 的多重集合个数，即 f[i-1] [j-1]。<br>如果这 i 个数里面没有 1，那么（举例）1=1/2+1/4+1/4 等价于2=1+1/2+1/2，所以问题等价于 i 个数且元素和为 2j 的多重集合个数，即 f[i][2j]。<br>注：2j 的意义在于让这 i 个数都是 1, 1/2, 1/4,...，从而【符合状态的定义】。</p><p>所以有<br>f[i] [j] = f[i-1] [j-1] + f[i] [2j]</p><p>根据转移方程，j 要倒序遍历。<br>如果 i&lt;j，那么 f[i] [j] = 0。所以 j 最大是 i。</p><p>初始值 f[0] [0] = 1。<br>答案为 f[n] [k]。</p><p>代码实现时，可以去掉第一个维度，那么 f[j] = f[j-1] 相当于在 f数组最前面插入了一个 0。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vi <span class="hljs-title">f</span><span class="hljs-params">(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        f.<span class="hljs-built_in">insert</span>(f.<span class="hljs-built_in">begin</span>(), <span class="hljs-number">0</span>); <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i / <span class="hljs-number">2</span>; j &gt; <span class="hljs-number">0</span>; j--) &#123;  <br>            f[j] = (f[j] + f[j * <span class="hljs-number">2</span>]) % mod;  <br>        &#125; <br>    &#125;<br>    cout &lt;&lt; f[k] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-10">20250217</h2><h3 id="problem-10">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1788/B">Sum of TwoNumbers</a></p><p>输入 T(≤1e4) 表示 T 组数据。<br>每组数据输入 n(1≤n≤1e9)。</p><p>定义 digsum(a) 表示 a 的数位和。<br>构造两个非负整数 x 和 y，满足 x + y = n 且 |digsum(x) - digsum(y)| &lt;=1。</p><p>可以证明，这样的 x 和 y 一定存在。</p><h3 id="example-10">Example</h3><p>输入</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">5</span><br><span class="hljs-number">1</span><br><span class="hljs-number">161</span><br><span class="hljs-number">67</span><br><span class="hljs-number">1206</span><br><span class="hljs-number">19</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><span class="hljs-number">0</span><br><span class="hljs-symbol">67 </span><span class="hljs-number">94</span><br><span class="hljs-symbol">60 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">1138 </span><span class="hljs-number">68</span><br><span class="hljs-symbol">14 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><h3 id="solution-10">Solution</h3><p>每一位单独考虑，出现奇数x和y的数位每次交替增加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n;<br>    cin&gt;&gt;n;<br>    ll x=<span class="hljs-number">0</span>,y=<span class="hljs-number">0</span>,i=<span class="hljs-number">0</span>,flag=<span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n&gt;<span class="hljs-number">0</span>)&#123;<br>        ll dig=n%<span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">if</span>(dig%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)&#123;<br>            x+=((dig/<span class="hljs-number">2</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,i));<br>            y+=((dig/<span class="hljs-number">2</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,i));<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>)&#123;<br>            x+=((dig/<span class="hljs-number">2</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,i));<br>            y+=((dig/<span class="hljs-number">2</span><span class="hljs-number">+1</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,i));<br>            flag=<span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            x+=((dig/<span class="hljs-number">2</span><span class="hljs-number">+1</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,i));<br>            y+=((dig/<span class="hljs-number">2</span>)*<span class="hljs-built_in">pow</span>(<span class="hljs-number">10</span>,i));<br>            flag=<span class="hljs-number">0</span>;<br>        &#125;<br> <br>        n/=<span class="hljs-number">10</span>;<br>        i++;<br>    &#125;<br>    cout&lt;&lt;x&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;y&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-11">20250218</h2><h3 id="problem-11">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1974/D">Ingenuity-2</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤2e5) 和长为 n 的字符串 s，只包含 NSEW四种字母，表示北南东西四个方向。</p><p>有两个机器人，一开始都在坐标原点。<br>选择 s中的某些字母分配给第一个机器人，其余字母分配给第二个机器人。<br>机器人按照字母方向移动，一个字母移动一个单位长度。<br>如何分配字母，可以让两个机器人最终在同一个位置？<br>注意：两个机器人都至少要走一步。</p><p>输出一个长为 n 的字符串 t，其中 t[i]='R' 表示 s[i]分给了第一个机器人，t[i]='H' 表示 s[i] 分给了第二个机器人。<br>多解输出任意解。<br>如果无法做到，输出 NO。</p><h3 id="example-11">Example</h3><p>输入</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">10</span><br><span class="hljs-number">6</span><br>NENSNE<br><span class="hljs-number">3</span><br>WWW<br><span class="hljs-number">6</span><br>NESSWS<br><span class="hljs-number">2</span><br>SN<br><span class="hljs-number">2</span><br>WE<br><span class="hljs-number">4</span><br>SSNN<br><span class="hljs-number">4</span><br>WESN<br><span class="hljs-number">2</span><br><span class="hljs-built_in">SS</span><br><span class="hljs-number">4</span><br>EWNN<br><span class="hljs-number">4</span><br>WEWE<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams">RRHRRH<br><span class="hljs-keyword">NO</span><br>HRRHRH<br><span class="hljs-keyword">NO</span><br><span class="hljs-keyword">NO</span><br>RHRH<br>RRHH<br>RH<br>RRRH<br>RRHH<br></code></pre></td></tr></table></figure><h3 id="solution-11">Solution</h3><p>设一共有 a 个 W（左）和 b 个 E（右）。<br>如果 a 和 b 的奇偶性不同，那么直接输出 NO。<br>如果 a=2,b=4，那么可以平均分配，每个机器人都往左走 a/2 步，往右走 b/2步。<br>如果 a=3,b=5 呢？多出来的 1步都给同一个机器人，这样两个人的横坐标仍然是相同的。<br>纵坐标同理。</p><p>实现的时候，可以用一个 who 数组记录当前轮到谁走，who[s[i]] = 0 表示s[i] 给第一个机器人，who[s[i]] = 1 表示 s[i] 给第二个机器人。<br>走完之后把 who[s[i]] 取反，从而做到均匀分配。</p><p>为了保证两个机器人都至少走一步，可以初始化南北方向 who['N'] =who['S'] = 0，东西方向 who['E'] = who['W'] = 1。</p><p>最后再检查一遍：统计 'R'的个数，判断两个机器人是否都至少走一步。<br>小技巧：通过判断最终 who['N'] = who['S'] 和 who['E'] = who['W']是否成立，来判断奇偶性（是否需要输出 NO）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n &gt;&gt; s;<br>    <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> ch : s) &#123;<br>        <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>            x++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;W&#x27;</span>) &#123;<br>            x--;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;N&#x27;</span>) &#123;<br>            y++;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ch == <span class="hljs-string">&#x27;S&#x27;</span>) &#123;<br>            y--;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function">string <span class="hljs-title">ans</span><span class="hljs-params">(n, <span class="hljs-string">&#x27;R&#x27;</span>)</span></span>;<br><br>    <span class="hljs-keyword">if</span> (x % <span class="hljs-number">2</span> != <span class="hljs-number">0</span> || y % <span class="hljs-number">2</span> != <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (x == <span class="hljs-number">0</span> &amp;&amp; y == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n == <span class="hljs-number">2</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">char</span> ch;<br>            <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;E&#x27;</span>) &#123;<br>                ch = <span class="hljs-string">&#x27;W&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;W&#x27;</span>) &#123;<br>                ch = <span class="hljs-string">&#x27;E&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;N&#x27;</span>) &#123;<br>                ch = <span class="hljs-string">&#x27;S&#x27;</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[<span class="hljs-number">0</span>] == <span class="hljs-string">&#x27;S&#x27;</span>) &#123;<br>                ch = <span class="hljs-string">&#x27;N&#x27;</span>;<br>            &#125;<br>            ans[<span class="hljs-number">0</span>] = ans[s.<span class="hljs-built_in">find</span>(ch)] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>            cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;E&#x27;</span> &amp;&amp; x &gt; <span class="hljs-number">0</span>) &#123;<br>            x -= <span class="hljs-number">2</span>;<br>            ans[i] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;W&#x27;</span> &amp;&amp; x &lt; <span class="hljs-number">0</span>) &#123;<br>            x += <span class="hljs-number">2</span>;<br>            ans[i] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;N&#x27;</span> &amp;&amp; y &gt; <span class="hljs-number">0</span>) &#123;<br>            y -= <span class="hljs-number">2</span>;<br>            ans[i] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;S&#x27;</span> &amp;&amp; y &lt; <span class="hljs-number">0</span>) &#123;<br>            y += <span class="hljs-number">2</span>;<br>            ans[i] = <span class="hljs-string">&#x27;H&#x27;</span>;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-12">20250219</h2><h3 id="problem-12">Problem</h3><p><a href="https://atcoder.jp/contests/abc100/tasks/abc100_d"><strong>PatisserieABC</strong></a></p><p>输入 n(1≤n≤1000) m(0≤m≤n) 和一个 n 行 3 列的矩阵 a。</p><p>从 n 行中选择 m 行，输出 abs(第一列元素和) + abs(第二列元素和) +abs(第三列元素和) 的最大值。</p><h3 id="example-12">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">7</span> <span class="hljs-number">9</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">56<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs subunit">5 3<br>1 <span class="hljs-string">-2</span> 3<br><span class="hljs-string">-4</span> 5 <span class="hljs-string">-6</span><br>7 <span class="hljs-string">-8</span> <span class="hljs-string">-9</span><br><span class="hljs-string">-10</span> 11 <span class="hljs-string">-12</span><br>13 <span class="hljs-string">-14</span> 15<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">54<br></code></pre></td></tr></table></figure><h3 id="solution-12">Solution</h3><p>假设第一列元素和 &gt;= 0，第二列元素和 &lt; 0，第三列元素和 &gt;=0。<br>去掉绝对值，要计算的式子就是：<br>第一列元素和 - 第二列元素和 + 第三列元素和<br>= sum(a[i][0] - a[i][1] + a[i][2])<br>要让答案尽量大，按照 a[i][0] - a[i][1] + a[i][2] 从大到小排序，计算前 m项的 abs(第一列元素和) + abs(第二列元素和) + abs(第三列元素和)。</p><p>一般地，枚举 2<sup>3</sup>=8种元素和的正负号组合，这样可以把绝对值拆开，方便我们做式子变形 +排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Point</span> &#123;  <br>    <span class="hljs-type">int</span> x, y, z;  <br>&#125;; <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,ans=<span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;Point&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i].x &gt;&gt; a[i].y &gt;&gt; a[i].z;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">-1</span>; i &lt;= <span class="hljs-number">1</span>; i += <span class="hljs-number">2</span>) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">-1</span>; j &lt;= <span class="hljs-number">1</span>; j += <span class="hljs-number">2</span>) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">-1</span>; k &lt;= <span class="hljs-number">1</span>; k += <span class="hljs-number">2</span>) &#123;  <br>                <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">const</span> Point&amp;p1,<span class="hljs-type">const</span> Point&amp;p2) &#123;  <br>                    <span class="hljs-keyword">return</span> p<span class="hljs-number">1.</span>x * i + p<span class="hljs-number">1.</span>y * j + p<span class="hljs-number">1.</span>z * k &gt; p<span class="hljs-number">2.</span>x * i + p<span class="hljs-number">2.</span>y * j + p<span class="hljs-number">2.</span>z * k;  <br>                &#125;);  <br><br>                <span class="hljs-type">int</span> s1 = <span class="hljs-number">0</span>, s2 = <span class="hljs-number">0</span>, s3 = <span class="hljs-number">0</span>;  <br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> idx = <span class="hljs-number">0</span>; idx &lt; m; idx++) &#123;  <br>                    s1 += a[idx].x;  <br>                    s2 += a[idx].y;  <br>                    s3 += a[idx].z;  <br>                &#125;  <br>                ans = <span class="hljs-built_in">max</span>(ans, <span class="hljs-built_in">abs</span>(s1) + <span class="hljs-built_in">abs</span>(s2) + <span class="hljs-built_in">abs</span>(s3));  <br>            &#125;  <br>        &#125;  <br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-13">20250220</h2><h3 id="problem-13">Problem</h3><p><a href="https://atcoder.jp/contests/abc218/tasks/abc218_f"><strong>BlockedRoads</strong></a></p><p>输入 n(2≤n≤400) m(1≤m≤n*(n-1))，表示一个 n 点 m边的有向图。保证图中无自环和重边。<br>然后输入 m 条边，每条边输入 x y，表示一条 x 到 y 的有向边，边权为1。节点编号从 1 开始。</p><p>输出 m 个数，其中第 i 个数表示删除输入的第 i 条边后，从 1 到 n的最短路长度。如果无法从 1 到达 n，输出 -1。</p><p>样例太长，请在原题查看。</p><p>【灵茶の试炼】题目&amp;题解<br><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz" class="uri">https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz</a></p><h3 id="example-13">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br>2<br>3<br>2<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>1<br>3<br>1<br>1<br>1<br>1<br>1<br>1<br>1<br></code></pre></td></tr></table></figure><h3 id="solution-13">Solution</h3><p>首先找到任意一条从 1 到 n 的最短路。</p><p>分类讨论：<br>如果删除的边不在这条最短路上，那么最短路长度不变。<br>如果删除的边在这条最短路上，直接重新算一遍最短路长度。由于最短路至多有n-1 条边，所以至多重新算 n-1 次。<br>时间复杂度 O(nm)。</p><p>怎么求任意一条最短路？由于图中边权都是 1，这可以通过一次 BFS完成。<br>BFS 更新 dis 的时候记录转移来源 from。最后从终点 n 出发，根据 from倒着走到起点 1，就知道路径上有哪些边了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;Edge&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> v,w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        g[v<span class="hljs-number">-1</span>].<span class="hljs-built_in">push_back</span>(&#123;w<span class="hljs-number">-1</span>,i&#125;);<br>    &#125;<br>    <span class="hljs-function">vector&lt;Edge&gt; <span class="hljs-title">from</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n)</span></span>;<br><br>    <span class="hljs-keyword">auto</span> bfs = [&amp;](<span class="hljs-type">int</span> ban) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-built_in">fill</span>(dis.<span class="hljs-built_in">begin</span>(), dis.<span class="hljs-built_in">end</span>(), <span class="hljs-number">-1</span>);<br>        dis[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>        queue&lt;<span class="hljs-type">int</span>&gt; q;<br>        q.<span class="hljs-built_in">push</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> v = q.<span class="hljs-built_in">front</span>();<br>            q.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; e : g[v]) &#123;<br>                <span class="hljs-type">int</span> w = e.to;<br>                <span class="hljs-keyword">if</span> (e.i != ban &amp;&amp; dis[w] &lt; <span class="hljs-number">0</span>) &#123;<br>                    dis[w] = dis[v] + <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">if</span> (ban &lt; <span class="hljs-number">0</span>) &#123;<br>                        from[w] = &#123;v, e.i&#125;;<br>                    &#125;<br>                    q.<span class="hljs-built_in">push</span>(w);<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dis[n<span class="hljs-number">-1</span>];<br>    &#125;;<br><br>    <span class="hljs-type">int</span> res = <span class="hljs-built_in">bfs</span>(<span class="hljs-number">-1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m, res)</span></span>;<br>    <span class="hljs-keyword">if</span> (res != <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v = n - <span class="hljs-number">1</span>; v != <span class="hljs-number">0</span>; v = from[v].to) &#123;<br>            ans[from[v].i] = <span class="hljs-built_in">bfs</span>(from[v].i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ans) &#123;<br>        cout &lt;&lt; v &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-14">20250221</h2><h3 id="problem-14">Problem</h3><p><a href="https://atcoder.jp/contests/abc163/tasks/abc163_f"><strong>pathpass i</strong></a></p><p>输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤n)。<br>然后输入一棵无向树的 n-1 条边，节点编号从 1 到 n。<br>节点 i 的颜色是 a[i]。</p><p>定义 f(c) = 包含颜色 c 的简单路径的数目。注：只有 1个点也算路径。<br>输出 f(1),f(2),...,f(n)。</p><h3 id="example-14">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>4<br>0<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>1<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>2<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">5<br>8<br>10<br>5<br>5<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span> <span class="hljs-number">5</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">18<br>15<br>0<br>14<br>23<br>0<br>23<br>0<br></code></pre></td></tr></table></figure><h3 id="solution-14">Solution</h3><p>正难则反，计算不包含颜色 c 的简单路径数。<br>所有路径数减去不包含颜色 c 的路径数就是答案。</p><p>去掉颜色 c 节点后，树分成了若干连通块。<br>对于大小为 m 的连通块，其中有 m*(m+1)/2 条简单路径。</p><p>如何快速计算各个连通块的大小？</p><p><img src="/2025/02/05/Tea202502/image-20250221153932232.png" alt="image-20250221153932232"></p><p>如图，去掉粉色节点后，考虑包含节点 y 的连通块，它的大小等于：<br>子树 y 的大小，减去子树 z1,z2,z3 的大小之和。</p><p>如何计算子树 z1,z2,z3 的大小之和？<br>额外用一个数组 size[c] 记录以颜色 c 为根的子树的大小之和。</p><p>这对吗？考虑 x 更上面的节点，这样做 z1,z2,z3 的子树大小岂不是会和 x的子树大小相加？<br>为了避免重复累加子树大小，直接用子树 x 的大小「覆盖」子树 z1,z2,z3的大小之和。<br>具体来说，在 dfs(x) 的开头，用临时变量 old 记录 size[c]；在 dfs(x)的末尾，覆盖 size[c] = old + 子树 x 的大小。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> v,w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        v--;<br>        w--;<br>        g[v].<span class="hljs-built_in">pb</span>(w);<br>        g[w].<span class="hljs-built_in">pb</span>(v);<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(n)</span>,<span class="hljs-title">size</span><span class="hljs-params">(n)</span></span>;<br>    function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">int</span> &#123;<br>        <span class="hljs-type">int</span> c = a[v] - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> old = size[c];<br>        <span class="hljs-type">int</span> sz = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : g[v]) &#123;<br>            <span class="hljs-keyword">if</span> (w != fa) &#123;<br>                size[c] = <span class="hljs-number">0</span>;<br>                <span class="hljs-type">int</span> szW = <span class="hljs-built_in">dfs</span>(w, v);<br>                sz += szW;<br>                <span class="hljs-type">int</span> m = szW - size[c];<br>                ans[c] += m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>        &#125;<br>        size[c] = old + sz;<br>        <span class="hljs-keyword">return</span> sz;<br>    &#125;;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> m = n - size[i];<br>        cout &lt;&lt; n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> - ans[i] - m * (m + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-15">20250224</h2><h3 id="problem-15">Problem</h3><p><a href="https://codeforces.com/problemset/problem/327/A">FlippingGame</a></p><p>输入 n(1≤n≤100) 和长为 n 的数组 a，只包含 0 和 1。</p><p>从 a 中选一个非空连续子数组，把其中的 0 变成 1，1 变成 0。<br>这个操作必须恰好执行一次。</p><p>输出操作后 a 中 1 的个数的最大值。</p><h3 id="example-15">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><h3 id="solution-15">Solution</h3><p>找到0比1数量最多的反转区间，如果找不到就必须反转一个1导致数量减一</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int</span> count1=<span class="hljs-number">0</span>,count0=<span class="hljs-number">0</span>,flip=<span class="hljs-number">0</span>,ans=<span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">1</span>) &#123;<br>            count1++;<br>            flip--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            count0++;<br>            flip++;<br>        &#125;<br>        ans = <span class="hljs-built_in">max</span>(ans, flip);<br>        <span class="hljs-keyword">if</span> (flip &lt; <span class="hljs-number">0</span>) &#123;<br>            flip = <span class="hljs-number">0</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; count1 + ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-16">20250225</h2><h3 id="problem-16">Problem</h3><p><a href="https://atcoder.jp/contests/abc371/tasks/abc371_e"></a></p><p>输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤n)。</p><p>定义 f(i,j) 为连续子数组 a[i]<sub>a</sub>[j] 中的不同元素个数。</p><p>输出所有 f(i,j) 之和，其中 i&lt;=j。</p><h3 id="example-16">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">9</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">111<br></code></pre></td></tr></table></figure><h3 id="solution-16">Solution</h3><p>我们需要计算所有连续子数组中不同元素个数的总和。直接暴力枚举所有子数组的方法时间复杂度为O(n²)，对于较大的n来说不可行。因此，我们需要一种更高效的方法。</p><p><strong>逆向思维</strong>：计算每个元素在多少个子数组中出现过至少一次。总和即为每个元素在所有子数组中出现次数的总和。具体步骤如下：</p><ol type="1"><li><strong>记录每个元素的位置</strong>：使用<code>unordered_map</code>记录每个元素在数组中的出现位置。</li><li><strong>计算总子数组数目</strong>：总子数组数目为<code>n*(n+1)/2</code>。</li><li><strong>计算不包含某元素的子数组数目</strong>：对于每个元素，找到其所有出现位置，将数组分割成多个不包含该元素的区间，计算这些区间的子数组数目之和。</li><li><strong>计算元素贡献</strong>：用总子数组数目减去不包含该元素的子数组数目，即为该元素的贡献。累加所有元素的贡献即为结果。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    unordered_map&lt;<span class="hljs-type">int</span>, vi&gt; pos_dict;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        pos_dict[a[i]].<span class="hljs-built_in">pb</span>(i);<br>    &#125;<br>    <span class="hljs-type">int</span> total_arrays = n * (n + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>    <span class="hljs-type">int</span> result = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span>&amp; entry : pos_dict) &#123;<br>        <span class="hljs-type">const</span> vi&amp; position = entry.second;<br>        <span class="hljs-type">int</span> prev = <span class="hljs-number">-1</span>;<br>        <span class="hljs-type">int</span> sum_not = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p : position) &#123;<br>            <span class="hljs-type">int</span> start = prev + <span class="hljs-number">1</span>;<br>            <span class="hljs-type">int</span> end = p - <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (start &lt;= end) &#123;<br>                <span class="hljs-type">int</span> length = end - start + <span class="hljs-number">1</span>;<br>                sum_not += length * (length + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>            &#125;<br>            prev = p;<br>        &#125;<br>        <span class="hljs-type">int</span> start = prev + <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> end = n - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (start &lt;= end) &#123;<br>            <span class="hljs-type">long</span> <span class="hljs-type">long</span> length = end - start + <span class="hljs-number">1</span>;<br>            sum_not += length * (length + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>        <br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> contribution = total_arrays - sum_not;<br>        result += contribution;<br>    &#125;<br>    cout &lt;&lt; result &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-17">20250226</h2><h3 id="problem-17">Problem</h3><p><a href="https://atcoder.jp/contests/abc348/tasks/abc348_e"><strong>MinimizeSum of Distances</strong></a></p><p>输入 n(1≤n≤1e5)。<br>输入一棵无向树的 n-1 条边，边权为 1，节点编号从 1 到 n。<br>输入长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>定义 f(x) = sum(dist(x, i) * a[i] for i in [1, n])，其中 dist(x, i)表示 x 到 i 的最短路长度。</p><p>输出 f(1),f(2),...,f(n) 中的最小值。</p><h3 id="example-17">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">5<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1000000000</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">56<br></code></pre></td></tr></table></figure><h3 id="solution-17">Solution</h3><p>换根dp</p><ul><li><strong>第一次DFS（后序）</strong>：计算每个子树的总权值<code>sum_a_subtree</code> 和以该节点为根的初始总距离权值<code>sum_dist</code>。</li><li><strong>第二次DFS（前序）</strong>：利用父节点的结果，通过公式<code>f(v) = f(u) + (总权值 - 2 * 子树v的权值)</code>递推计算所有子节点的结果。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; ++i) &#123;<br>        <span class="hljs-type">int</span> u,v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        adj[u].<span class="hljs-built_in">pb</span>(v);<br>        adj[v].<span class="hljs-built_in">pb</span>(u);<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">sum_a_tree</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">vi <span class="hljs-title">sum_dist</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs1 = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p) &#123;<br>        sum_a_tree[u] = a[u];<br>        sum_dist[u] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>            <span class="hljs-keyword">if</span> (v != p) &#123;<br>                <span class="hljs-built_in">dfs1</span>(v, u);<br>                sum_a_tree[u] += sum_a_tree[v];<br>                sum_dist[u] += sum_dist[v] + sum_a_tree[v];<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs1</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-type">int</span> total_a = sum_a_tree[<span class="hljs-number">1</span>];<br>    function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs2 = [&amp;](<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> p) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>            <span class="hljs-keyword">if</span> (v != p) &#123;<br>                sum_dist[v] = sum_dist[u] + (total_a - <span class="hljs-number">2</span> * sum_a_tree[v]);<br>                <span class="hljs-built_in">dfs2</span>(v, u);<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs2</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-type">int</span> min_f = *<span class="hljs-built_in">min_element</span>(sum_dist.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>, sum_dist.<span class="hljs-built_in">end</span>());<br>    cout &lt;&lt; min_f &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>图可视化网站：<a href="https://csacademy.com/app/graph_editor/" class="uri">https://csacademy.com/app/graph_editor/</a></p><h2 id="section-18">20250227</h2><h3 id="problem-18">Problem</h3><p><a href="https://atcoder.jp/contests/abc321/tasks/abc321_f"><strong>#(subsetsum = K) with Add and Erase</strong></a></p><p>输入 q(1≤n≤5000) 和 k(1≤k≤5000)。<br>一开始有一个空箱子。输入 q 个操作：<br>"+ v"：把一个写有数字 v 的小球放入箱子。<br>"- v"：从箱子中移除一个写有数字 v 的小球，保证箱子中有这样的小球。<br>v 的范围是 [1,5000]。</p><p>每次操作后，输出有多少种方案，从盒子中选取一些球，元素和恰好等于k。答案模 998244353。<br>注意球是有区分的。</p><h3 id="example-18">Example</h3><p>输入</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs markdown">15 10<br><span class="hljs-bullet">+</span> 5<br><span class="hljs-bullet">+</span> 2<br><span class="hljs-bullet">+</span> 3<br><span class="hljs-bullet">-</span> 2<br><span class="hljs-bullet">+</span> 5<br><span class="hljs-bullet">+</span> 10<br><span class="hljs-bullet">-</span> 3<br><span class="hljs-bullet">+</span> 1<br><span class="hljs-bullet">+</span> 3<br><span class="hljs-bullet">+</span> 3<br><span class="hljs-bullet">-</span> 5<br><span class="hljs-bullet">+</span> 1<br><span class="hljs-bullet">+</span> 7<br><span class="hljs-bullet">+</span> 4<br><span class="hljs-bullet">-</span> 3<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs">0<br>0<br>1<br>0<br>1<br>2<br>2<br>2<br>2<br>2<br>1<br>3<br>5<br>8<br>5<br></code></pre></td></tr></table></figure><h3 id="solution-18">Solution</h3><ol type="1"><li><strong>动态规划（背包问题）</strong>：使用动态规划数组<code>dp</code>，其中<code>dp[i]</code>表示当前箱子中的小球组成和为i的方案数。初始化<code>dp[0] = 1</code>（空集的方案数为1）。</li><li><strong>添加操作（+v）</strong>：相当于扩展背包容量。对于每个可能的和i（从k到v逆序遍历），更新<code>dp[i] += dp[i - v]</code>。逆序保证每个小球只被计算一次。</li><li><strong>移除操作（-v）</strong>：需要撤销该小球的影响。对于每个可能的和i（从v到k正序遍历），更新<code>dp[i] -= dp[i - v]</code>。正序确保正确减去包含该小球的方案数，处理负数时加上模数保证非负。</li><li><strong>复杂度分析</strong>：每次操作的时间复杂度为O(k)，总时间复杂度为O(qk)。</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vi <span class="hljs-title">dp</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">char</span> op;<br>        <span class="hljs-type">int</span> v;<br>        cin &gt;&gt; op &gt;&gt; v;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;+&#x27;</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = k; i &gt;= v; i--) &#123;<br>                dp[i] = (dp[i] + dp[i-v]) % MOD;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = v; i &lt;= k; ++i) &#123;<br>                dp[i] = (dp[i] - dp[i-v] + MOD) % MOD;<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; dp[k] &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-19">20250228</h2><h3 id="problem-19">Problem</h3><p><a href="https://atcoder.jp/contests/agc015/tasks/agc015_c"><strong>Nuskevs Phantom Thnook</strong></a></p><p>输入 n(1≤n≤2000) m(1≤m≤2000) q(1≤q≤2e5) 和一个 n 行 m 列的 01网格图。<br>其中 0 表示白色格子，1 表示蓝色格子。<br>保证每个由蓝色格子构成的（四方向）连通块都是树。</p><p>然后输入 q 个询问，每个询问输入 4个数，表示一个子矩形的左上角行列坐标和右下角行列坐标（下标从 1开始）。<br>输出这个子矩形中，有多少个蓝色连通块。</p><h3 id="example-19">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-number">1101</span><br><span class="hljs-number">0110</span><br><span class="hljs-number">1101</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br>2<br>2<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-number">11010</span><br><span class="hljs-number">01110</span><br><span class="hljs-number">10101</span><br><span class="hljs-number">11101</span><br><span class="hljs-number">01010</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">3<br>2<br>1<br>1<br>3<br>2<br></code></pre></td></tr></table></figure><h3 id="solution-19">Solution</h3><ol type="1"><li><strong>问题分析</strong>：<ul><li>每个蓝色连通块都是树结构，即无环连通块。树的性质是点数等于边数加1。</li><li>对于子矩形内的所有蓝色点，连通块的数量等于点数减去边数。</li></ul></li><li><strong>关键观察</strong>：<ul><li>使用二维前缀和数组快速计算子矩形内的点数。</li><li>预处理横向边和纵向边的数量，使用二维前缀和数组快速计算子矩形内的边数。</li></ul></li><li><strong>预处理步骤</strong>：<ul><li><strong>sum数组</strong>：存储每个位置及其左上区域内的蓝色点总数。</li><li><strong>h数组和h_sum数组</strong>：存储每个位置及其右侧的横向边数量。</li><li><strong>v数组和v_sum数组</strong>：存储每个位置及其下方的纵向边数量。</li></ul></li><li><strong>查询处理</strong>：<ul><li>使用前缀和数组快速计算子矩形内的点数（S）。</li><li>计算横向边（H）和纵向边（V）的数量，得到总边数（E = H + V）。</li><li>结果即为点数减去边数（S - E）。</li></ul></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">2005</span>;<br><span class="hljs-type">int</span> sum[MAXN][MAXN];<br><span class="hljs-type">int</span> h[MAXN][MAXN], h_sum[MAXN][MAXN];<br><span class="hljs-type">int</span> v[MAXN][MAXN], v_sum[MAXN][MAXN];<br><span class="hljs-type">char</span> grid[MAXN][MAXN];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d&quot;</span>, &amp;n, &amp;m, &amp;q);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%s&quot;</span>, grid[i] + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// Precompute sum array for 1&#x27;s</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            sum[i][j] = sum[i<span class="hljs-number">-1</span>][j] + sum[i][j<span class="hljs-number">-1</span>] - sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + (grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> ? <span class="hljs-number">1</span> : <span class="hljs-number">0</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Precompute h and v arrays for edges</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            <span class="hljs-comment">// Horizontal edges (right)</span><br>            <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; grid[i][j<span class="hljs-number">+1</span>] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                h[i][j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                h[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-comment">// Vertical edges (down)</span><br>            <span class="hljs-keyword">if</span> (i &lt; n &amp;&amp; grid[i][j] == <span class="hljs-string">&#x27;1&#x27;</span> &amp;&amp; grid[i<span class="hljs-number">+1</span>][j] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>                v[i][j] = <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                v[i][j] = <span class="hljs-number">0</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// Precompute prefix sums for h and v</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= m; ++j) &#123;<br>            h_sum[i][j] = h_sum[i<span class="hljs-number">-1</span>][j] + h_sum[i][j<span class="hljs-number">-1</span>] - h_sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + h[i][j];<br>            v_sum[i][j] = v_sum[i<span class="hljs-number">-1</span>][j] + v_sum[i][j<span class="hljs-number">-1</span>] - v_sum[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + v[i][j];<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (q--) &#123;<br>        <span class="hljs-type">int</span> x1, y1, x2, y2;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d%d%d&quot;</span>, &amp;x1, &amp;y1, &amp;x2, &amp;y2);<br><br>        <span class="hljs-type">int</span> S = sum[x2][y2] - sum[x1<span class="hljs-number">-1</span>][y2] - sum[x2][y1<span class="hljs-number">-1</span>] + sum[x1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>];<br><br>        <span class="hljs-type">int</span> H = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> j1 = y1, j2 = y2 - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (j1 &lt;= j2 &amp;&amp; x1 &lt;= x2) &#123;<br>            H = h_sum[x2][j2] - h_sum[x1<span class="hljs-number">-1</span>][j2] - h_sum[x2][j1<span class="hljs-number">-1</span>] + h_sum[x1<span class="hljs-number">-1</span>][j1<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> V = <span class="hljs-number">0</span>;<br>        <span class="hljs-type">int</span> i1 = x1, i2 = x2 - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (i1 &lt;= i2 &amp;&amp; y1 &lt;= y2) &#123;<br>            V = v_sum[i2][y2] - v_sum[i1<span class="hljs-number">-1</span>][y2] - v_sum[i2][y1<span class="hljs-number">-1</span>] + v_sum[i1<span class="hljs-number">-1</span>][y1<span class="hljs-number">-1</span>];<br>        &#125;<br><br>        <span class="hljs-type">int</span> E = H + V;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, S - E);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="codeforces" scheme="http://polaris3003.github.io/categories/codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>茶-2025-01</title>
    <link href="http://polaris3003.github.io/2025/01/07/Tea202501/"/>
    <id>http://polaris3003.github.io/2025/01/07/Tea202501/</id>
    <published>2025-01-07T12:47:51.000Z</published>
    <updated>2025-02-11T09:26:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tea">Tea</h1><h2 id="section">20250107</h2><h3 id="problem">Problem</h3><p><a href="https://codeforces.com/problemset/problem/2048/C">Kevin andBinary Strings</a></p><p>输入 T(≤1e3) 表示 T 组数据。所有数据的字符串长度之和 ≤5000。</p><p>每组数据输入长度 ≤5000 的 01 字符串 s。保证 s 的第一个字符是'1'。</p><p>你需要在 s中选择两个非空子串（可以重叠，可以有前导零），将其视作两个二进制数，计算XOR。</p><p>目标是最大化 XOR。</p><p>输出你选择的两个子串的左右端点 l1 r1 l2 r2，下标从 1 开始。</p><p>如果答案不止一种，输出其中任意一个。</p><h3 id="example">Example</h3><p>Input</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">5</span><br><span class="hljs-number">111</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">10111</span><br><span class="hljs-number">11101</span><br><span class="hljs-number">1100010001101</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">13</span> <span class="hljs-number">1</span> <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h3 id="solution">Solution</h3><p>1.其中一个子串必然是 s，如果比 s 还短，那 XOR 必然比 s 小。</p><p>2.找到 s 的最左边的 0，这个 0 一定要改成 1，得到的 XOR一定比不改更大。</p><p>3.设这个 0 的下标为 i，那么另一个子串的长度必须恰好等于n-i，因为我们要【右对齐】计算 XOR。</p><p>4.暴力枚举所有长为 n-i 的子串。</p><p>5.如果 s 没有 0，那么输出 1 n 1 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), idx = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    ans[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    ans[<span class="hljs-number">1</span>] = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            idx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> len = n - idx, mx = <span class="hljs-number">0</span>;<br>    ans[<span class="hljs-number">2</span>] = ans[<span class="hljs-number">3</span>] = idx + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx &amp;&amp; i + len &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = idx + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; n &amp;&amp; s[k] != s[j]) &#123;<br>                j++;<br>                k++;<br>            &#125;<br>            <span class="hljs-type">int</span> sz = j - i;<br>            <span class="hljs-keyword">if</span> (sz &gt; mx) &#123;<br>                mx = sz;<br>                ans[<span class="hljs-number">2</span>] = i + <span class="hljs-number">1</span>;<br>                ans[<span class="hljs-number">3</span>] = i + len;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i==<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-1">20250108</h2><h3 id="problem-1">Problem</h3><p><a href="https://codeforces.com/problemset/problem/2045/A">ScrambledScrabble</a></p><p>输入长度 ≤5000 的字符串 s，只包含大写英文字母。</p><p>字母 AEIOU 是元音。Y 可以是元音也可以是辅音。<br>其余字母为辅音。特别地，可以把 NG 连在一起，当作一个辅音。</p><p>定义音节为一个辅音 + 一个元音 + 一个辅音。例如 CAR，KING 等等。<br>定义单词为由一个或多个音节串联得到的字符串。例如 KINGDOM 是由 KING + DOM两个音节组成。</p><p>从 s 中删除零个或多个字母，然后重新排列剩余的字母，组成单词。<br>输出最长单词长度。<br>如果无法组成单词，输出 0。</p><h3 id="example-1">Example</h3><p>输入 ICPCJAKARTA<br>输出 9</p><p>输入 NGENG<br>输出 5</p><p>输入 YYY<br>输出 3</p><p>输入 DANGAN<br>输出 6</p><p>输入 AEIOUY<br>输出 0</p><h3 id="solution-1">Solution</h3><ol type="1"><li>首先统计每种字母的出现次数</li><li>计算元音数(a)、Y数(y)、辅音数(b)和NG组合数(ng)</li><li>考虑不同情况下能组成的最长单词：<ul><li>如果NG组合充足，每个音节可以是5个字母（如NGENG）</li><li>如果普通辅音充足，每个音节是3个字母，可能额外使用NG</li><li>如果元音较多，需要根据辅音数量来限制</li><li>其他情况下尽可能组成3字符音节</li></ul></li><li>时间复杂度:O(n),空间复杂度O(1)</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">length</span>();<br>    <span class="hljs-function">vi <span class="hljs-title">count</span><span class="hljs-params">(<span class="hljs-number">26</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e:s) &#123;<br>        count[e-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-type">int</span> a = count[<span class="hljs-string">&#x27;A&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]+count[<span class="hljs-string">&#x27;E&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]+count[<span class="hljs-string">&#x27;I&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]+count[<span class="hljs-string">&#x27;O&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]+count[<span class="hljs-string">&#x27;U&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>];<br>    <span class="hljs-type">int</span> y = count[<span class="hljs-string">&#x27;Y&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>];<br>    <span class="hljs-type">int</span> b = s.<span class="hljs-built_in">length</span>() - a - y;<br>    <span class="hljs-type">int</span> ng = <span class="hljs-built_in">min</span>(count[<span class="hljs-string">&#x27;N&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>],count[<span class="hljs-string">&#x27;G&#x27;</span>-<span class="hljs-string">&#x27;A&#x27;</span>]);<br>    <span class="hljs-keyword">if</span> ((a+y)*<span class="hljs-number">2</span>&lt;=ng) &#123;<br>        cout &lt;&lt; (a+y)*<span class="hljs-number">5</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((a+y)*<span class="hljs-number">2</span> &lt;= b - ng) &#123;<br>        cout &lt;&lt; (a+y)*<span class="hljs-number">3</span>+ng &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((b+y)/<span class="hljs-number">2</span> &lt;= a) &#123;<br>        <span class="hljs-type">int</span> res = (b+y)/<span class="hljs-number">2</span>*<span class="hljs-number">3</span>;<br>        <span class="hljs-keyword">if</span> ((b+y)%<span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span> &amp;&amp; ng &gt; <span class="hljs-number">0</span>) &#123;<br>            res++;<br>        &#125;<br>        cout &lt;&lt; res &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; n - <span class="hljs-built_in">max</span>(n%<span class="hljs-number">3</span>-ng,<span class="hljs-number">0</span>) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-2">20250109</h2><h3 id="problem-2">Problem</h3><p><a href="https://atcoder.jp/contests/abc282/tasks/abc282_e"><strong>ChooseTwo and Eat One</strong></a></p><p>输入 n(2≤n≤500) m(2≤m≤1e9) 和长为 n 的数组 a(1≤a[i]≤m-1)。</p><p>重复如下操作 n-1 次：<br>选择 a 中的两个数 x 和 y，得到 (pow(x,y)+pow(y,x))%m 分，然后从 a 中删除x 或者 y。</p><p>输出总得分的最大值。</p><h3 id="example-2">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">20<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">20</span> <span class="hljs-number">100</span><br><span class="hljs-attribute">29</span> <span class="hljs-number">31</span> <span class="hljs-number">68</span> <span class="hljs-number">20</span> <span class="hljs-number">83</span> <span class="hljs-number">66</span> <span class="hljs-number">23</span> <span class="hljs-number">84</span> <span class="hljs-number">69</span> <span class="hljs-number">96</span> <span class="hljs-number">41</span> <span class="hljs-number">61</span> <span class="hljs-number">83</span> <span class="hljs-number">37</span> <span class="hljs-number">52</span> <span class="hljs-number">71</span> <span class="hljs-number">18</span> <span class="hljs-number">55</span> <span class="hljs-number">40</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">1733</span><br></code></pre></td></tr></table></figure><h3 id="solution-2">Solution</h3><p>看成有 n 个节点的完全图。</p><p>每次操作相当于选择一条边，并删掉一个节点。</p><p>由于选择的边，不会与已删除的点相连，所以选择的边不能构成环。</p><p>于是 n-1 次选边后，我们得到的是一棵生成树。</p><p>Kruskal/Prim 计算最大生成树即可，后者复杂度 O(n<sup>2</sup>)。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Tuple</span> &#123;<br>    ll v, w, wt;<br>&#125;;<br><span class="hljs-function">ll <span class="hljs-title">my_pow</span><span class="hljs-params">(ll x, ll n, ll mod)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(n &gt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (n % <span class="hljs-number">2</span> &gt; <span class="hljs-number">0</span>) &#123;<br>            res = (<span class="hljs-number">1LL</span> * res * x) % mod;<br>        &#125;<br>        x = (<span class="hljs-number">1LL</span> * x * x) % mod;<br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vll <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) cin &gt;&gt; a[i];<br>    vector&lt;Tuple&gt; b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt; n; ++j) &#123;  <br>            ll v = a[i];  <br>            ll w = a[j];  <br>            ll weight = (<span class="hljs-built_in">my_pow</span>(v, w, m) + <span class="hljs-built_in">my_pow</span>(w, v, m)) % m;  <br>            b.<span class="hljs-built_in">push_back</span>(&#123;i, j, weight&#125;);  <br>        &#125;  <br>    &#125;<br>    <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>(), [](Tuple &amp;a, Tuple &amp;b) &#123;<br>        <span class="hljs-keyword">return</span> a.wt &gt; b.wt;<br>    &#125;);<br>    <span class="hljs-function">vector&lt;ll&gt; <span class="hljs-title">fa</span><span class="hljs-params">(n)</span></span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;  <br>        fa[i] = i;  <br>    &#125;  <br><br>    function&lt;ll(ll)&gt; find = [&amp;](ll x) &#123;  <br>        <span class="hljs-keyword">if</span> (fa[x] != x) &#123;  <br>            fa[x] = <span class="hljs-built_in">find</span>(fa[x]);  <br>        &#125;  <br>        <span class="hljs-keyword">return</span> fa[x];  <br>    &#125;;  <br><br>    ll sum = <span class="hljs-number">0</span>;  <br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> &amp;e : b) &#123;  <br>        ll v = e.v, w = e.w, wt = e.wt;  <br>        ll fv = <span class="hljs-built_in">find</span>(v), fw = <span class="hljs-built_in">find</span>(w);  <br>        <span class="hljs-keyword">if</span> (fv != fw) &#123;  <br>            fa[fv] = fw;<br>            sum += wt;  <br>        &#125;  <br>    &#125;  <br><br>    cout &lt;&lt; sum &lt;&lt; endl;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-3">20250110</h2><h3 id="problem-3">Problem</h3><p><a href="https://atcoder.jp/contests/arc189/tasks/arc189_d"><strong>Takahashiis Slime</strong></a></p><p>输入 n(2≤n≤5e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>有 n 只史莱姆排成一行，从左到右第 i 只史莱姆的体积为 a[i]。<br>假设你是第 k只史莱姆，每次操作，你可以吃掉左右相邻的体积严格小于你的一只史莱姆，并获得它的体积。把你可以达到的最大体积记为f(k)。</p><p>输出 f(1),f(2),f(3),...,f(n)。</p><h3 id="example-3">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">13</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">2</span> <span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">30</span> <span class="hljs-number">2</span> <span class="hljs-number">13</span> <span class="hljs-number">2</span> <span class="hljs-number">13</span><br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">12</span><br><span class="hljs-attribute">22</span> <span class="hljs-number">25</span> <span class="hljs-number">61</span> <span class="hljs-number">10</span> <span class="hljs-number">21</span> <span class="hljs-number">37</span> <span class="hljs-number">2</span> <span class="hljs-number">14</span> <span class="hljs-number">5</span> <span class="hljs-number">8</span> <span class="hljs-number">6</span> <span class="hljs-number">24</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">22</span> <span class="hljs-number">47</span> <span class="hljs-number">235</span> <span class="hljs-number">10</span> <span class="hljs-number">31</span> <span class="hljs-number">235</span> <span class="hljs-number">2</span> <span class="hljs-number">235</span> <span class="hljs-number">5</span> <span class="hljs-number">235</span> <span class="hljs-number">6</span> <span class="hljs-number">235</span><br></code></pre></td></tr></table></figure><h3 id="solution-3">Solution</h3><p>从大到小思考。<br>a 中最大值的答案是多少？次大值的答案是多少？</p><p>设：<br>a[i] 左边最近 &gt; a[i] 的数的下标为 left[i]，若不存在则为 -1。<br>a[i] 左边最近 &gt;= a[i] 的数的下标为 leftGE[i]，若不存在则为 -1。<br>a[i] 右边最近 &gt; a[i] 的数的下标为 right[i]，若不存在则为 n。<br>a[i] 右边最近 &gt;= a[i] 的数的下标为 rightGE[i]，若不存在则为 n。</p><p>分类讨论：<br>如果 rightGE[i]-leftGE[i]=2，那么啥也做不了，ans[i] = a[i]。<br>否则，由于 a中元素都是正数，在吃掉一个史莱姆后，我们的体积一定比初始体积大。<br>计算从 left[i]+1 到 right[i]-1 的子数组和 s。<br>如果 left[i] &gt;= 0，且子数组和 s 比 a[i]左边更大数的答案还要大，那么左边更大数能吃掉的数，a[i] 也可以吃掉，所以ans[i] 就是左边更大数的答案，即 ans[i] = ans[left[i]]。<br>否则如果 right[i] &lt; n，且子数组和 s 比 a[i]右边更大数的答案还要大，那么右边更大数能吃掉的数，a[i] 也可以吃掉，所以ans[i] 就是右边更大数的答案，即 ans[i] = ans[right[i]]。<br>其他情况，ans[i] = s。</p><p>记得开 LL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">sum</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span>, <span class="hljs-title">leftGE</span><span class="hljs-params">(n)</span>, <span class="hljs-title">right</span><span class="hljs-params">(n)</span></span>;<br>    vi st = &#123;<span class="hljs-number">-1</span>&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        sum[i<span class="hljs-number">+1</span>] = sum[i] + a[i];<br>        <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; a[st.<span class="hljs-built_in">back</span>()] &lt; a[i]) &#123;<br>            right[st.<span class="hljs-built_in">back</span>()] = i;<br>            st.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        leftGE[i] = st.<span class="hljs-built_in">back</span>();<br>        st.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : st) &#123;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">-1</span>) right[i] = n;<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">rightGE</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vi <span class="hljs-title">left</span><span class="hljs-params">(n)</span></span>;<br>    st = &#123;n&#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (st.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">1</span> &amp;&amp; a[st.<span class="hljs-built_in">back</span>()] &lt; a[i]) &#123;<br>            left[st.<span class="hljs-built_in">back</span>()] = i;<br>            st.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        rightGE[i] = st.<span class="hljs-built_in">back</span>();<br>        st.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : st) &#123;<br>        <span class="hljs-keyword">if</span> (i != n) left[i] = <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">id</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">iota</span>(id.<span class="hljs-built_in">begin</span>(), id.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sort</span>(id.<span class="hljs-built_in">begin</span>(), id.<span class="hljs-built_in">end</span>(), [&amp;](<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j) &#123;<br>        <span class="hljs-keyword">return</span> a[i] &gt; a[j];<br>    &#125;);<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i : id) &#123;<br>        <span class="hljs-keyword">if</span> (rightGE[i] - leftGE[i] == <span class="hljs-number">2</span>) &#123;<br>            ans[i] = a[i];<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> l = left[i], r = right[i];<br>        <span class="hljs-type">int</span> s = sum[r] - sum[l + <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span> (l &gt;= <span class="hljs-number">0</span> &amp;&amp; s &gt; a[l]) &#123;<br>            ans[i] = ans[l];<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (r &lt; n &amp;&amp; s &gt; a[r]) &#123;<br>            ans[i] = ans[r];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans[i] = s;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ans) cout &lt;&lt; v &lt;&lt; <span class="hljs-string">&#x27; &#x27;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-4">20250113</h2><h3 id="problem-4">Problem</h3><p><a href="https://codeforces.com/problemset/problem/2019/B">All PairsSegments</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e5，q 之和≤1e5。<br>每组数据输入 n(2≤n≤2e5) q(1≤q≤1e5) 和长为 n 的严格递增数组a(1≤a[i]≤1e9)。</p><p>对于每个满足 i&lt;j 的 (i,j)，画一条线段（闭区间）[ai,aj]。一共有n*(n-1)/2 条线段。<br>然后输入 q 个询问，每个询问输入 k(1≤k≤1e18)，输出有多少个整数恰好在 k条线段中。</p><p>【灵茶の试炼】题目&amp;题解<br><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz" class="uri">https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz</a></p><h3 id="example-4">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">101 </span><span class="hljs-number">200</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">15</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span> <span class="hljs-number">7</span> <span class="hljs-number">8</span> <span class="hljs-number">9</span> <span class="hljs-number">10</span> <span class="hljs-number">11</span> <span class="hljs-number">12</span> <span class="hljs-number">13</span> <span class="hljs-number">14</span> <span class="hljs-number">15</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">254618033 </span><span class="hljs-number">265675151</span> <span class="hljs-number">461318786</span> <span class="hljs-number">557391198</span> <span class="hljs-number">848083778</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">9</span> <span class="hljs-number">15</span> <span class="hljs-number">10</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">4</span> <span class="hljs-number">4294967300</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">100</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">3</span> <span class="hljs-number">0</span> <span class="hljs-number">2</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">291716045 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">291716045</span> <span class="hljs-number">0</span> <span class="hljs-number">301749698</span> <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="solution-4">Solution</h3><p>直接预处理所有答案，即在回答询问之前，预处理 mp，其中 mp[k]表示恰好在 k 条线段中的整数个数。</p><p>分类讨论。</p><p>对于不在 a 中的整数 x，如果 a[i-1]&lt;x&lt;a[i]，那么线段的左端点有 i种选择，右端点有 n-i 种选择，所以一共有 i*(n-1) 条线段包含 x。</p><p>此外满足 a[i-1]&lt;x&lt;a[i] 的 x 有 a[i]-a[i-1]-1 个，那么mp[i*(n-1)] += a[i]-a[i-1]-1。</p><p>对于在 a 中的整数 x，如果 x=a[i]，那么左端点有 i+1 种选择，右端点有n-i 种选择，减去左右端点重合的线段（不符合题目要求），</p><p>所以一共有 (i+1)*(n-1)-1 条线段包含 a[i]，那么 mp[(i+1)*(n-i)-1] +=1。</p><p>最后对于每个询问，输出 mp[k]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,q,pre;<br>    cin &gt;&gt; n &gt;&gt; q &gt;&gt; pre;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    mii mp;<br>    mp[n<span class="hljs-number">-1</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        mp[i*(n-i)] += a[i] - pre - <span class="hljs-number">1</span>;<br>        mp[(i<span class="hljs-number">+1</span>)*(n-i)<span class="hljs-number">-1</span>]++;<br>        pre = a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> k;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        cin &gt;&gt; k;<br>        cout &lt;&lt; mp[k] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-5">20250114</h2><h3 id="problem-5">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1923/C">FindB</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤3e5，q 之和≤3e5。<br>每组数据输入 n(1≤n≤3e5) q(1≤q≤3e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，下标从1 开始。<br>然后输入 q 个询问，每个询问输入两个数 L 和 R，表示下标从 L 到 R的连续子数组 b (1≤L≤R≤n)。</p><p>对于每个询问，你需要构造一个和 b 一样长的数组 c，要求：<br>1. sum(c) = sum(b)。<br>2. 所有 c[i] 都不等于 b[i]。<br>3. 所有 c[i] 都是正数。</p><p>能否构造？输出 YES 或 NO。</p><p>【灵茶の试炼】题目&amp;题解<br><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz" class="uri">https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz</a></p><h3 id="example-5">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">1</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">NO</span><br><span class="hljs-keyword">YES</span><br><span class="hljs-keyword">NO</span><br></code></pre></td></tr></table></figure><h3 id="solution-5">Solution</h3><p>如果 b[i] = 1，那么必须增大，至少增大 1。<br>如果 b[i] &gt; 1，那么为了弥补 b[i]=1的增大，我们需要知道这些数最多能减小多少，也就是 b[i]-1 之和。</p><p>所以统计子数组内的 b[i]=1 的个数，以及 b[i]-1 的元素和，如果前者&lt;= 后者，那么输出 YES，否则输出 NO。<br>注意特判 L=R 的情况，只有一个数必然是 NO。</p><p>计算子数组和用前缀和。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n<span class="hljs-number">+1</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">1</span>) &#123;<br>            sum[i<span class="hljs-number">+1</span>] = sum[i]<span class="hljs-number">-1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sum[i<span class="hljs-number">+1</span>] = sum[i] + a[i] - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> l,r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span> (l &lt; r &amp;&amp; sum[l<span class="hljs-number">-1</span>] &lt;= sum[r]) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-6">20250115</h2><h3 id="problem-6">Problem</h3><p><a href="https://atcoder.jp/contests/abc375/tasks/abc375_f"><strong>RoadBlocked</strong></a></p><p>输入 n(2≤n≤300) m(0≤m≤n*(n-1)/2) q(1≤q≤2e5)，表示一个 n 点 m边的无向图。保证图中无自环和重边。<br>然后输入 m 条边，每条边输入 x y w(1≤w≤1e9)，表示一条边权为 w的无向边连接 x 和 y。节点编号从 1 开始。</p><p>然后输入 q 个询问，格式如下：<br>"1 i"：删掉输入的第 i(1≤i≤m) 条边。保证这条边没被删除。<br>"2 x y"：输出从 x 到 y 的最短距离。如果无法到达，输出 -1。</p><p>保证第一种询问不超过 300 个。</p><h3 id="example-6">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">10<br>11<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">6</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-1</span><br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><h3 id="solution-6">Solution</h3><p>倒序处理查询，删边变成加边</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Edge</span> &#123;<br>    <span class="hljs-type">int</span> v,w, wt;<br>&#125;;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Query</span> &#123;<br>    <span class="hljs-type">int</span> v,w;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addEdge</span> <span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> w, <span class="hljs-type">int</span> wt, <span class="hljs-type">int</span> n)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;  <br>            g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], <span class="hljs-built_in">min</span>(g[i][v] + wt + g[w][j], g[i][w] + wt + g[v][j]));  <br>        &#125;  <br>    &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m,q;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;q;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, INF));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        g[i][i] = <span class="hljs-number">0</span>;<br>    &#125; <br>    <span class="hljs-function">vector&lt;Edge&gt; <span class="hljs-title">edges</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        cin &gt;&gt; edges[i].v &gt;&gt; edges[i].w &gt;&gt; edges[i].wt;<br>        edges[i].v--;<br>        edges[i].w--;<br>        g[edges[i].v][edges[i].w] = edges[i].wt;<br>        g[edges[i].w][edges[i].v] = edges[i].wt;<br>    &#125;<br>    <span class="hljs-function">vector&lt;Query&gt; <span class="hljs-title">queries</span><span class="hljs-params">(q)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        <span class="hljs-type">int</span> op;<br>        cin &gt;&gt; op &gt;&gt; queries[i].v;<br>        queries[i].v--;<br>        <span class="hljs-keyword">if</span> (op == <span class="hljs-number">2</span>) &#123;<br>            cin &gt;&gt; queries[i].w;<br>            queries[i].w--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Edge e = edges[queries[i].v];<br>            g[e.v][e.w] = INF;<br>            g[e.w][e.v] = INF;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; n; ++k) &#123;  <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;  <br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;  <br>                g[i][j] = <span class="hljs-built_in">min</span>(g[i][j], g[i][k] + g[k][j]);  <br>            &#125;  <br>        &#125;  <br>    &#125;<br>    vi ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = q - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        Query q = queries[i];<br>        <span class="hljs-keyword">if</span> (q.w == <span class="hljs-number">0</span>) &#123;<br>            Edge e = edges[q.v];<br>            <span class="hljs-built_in">addEdge</span>(g, e.v, e.w, e.wt, n);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> dist = g[q.v][q.w];<br>            <span class="hljs-keyword">if</span> (dist == INF) &#123;<br>                dist = <span class="hljs-number">-1</span>;<br>            &#125;<br>            ans.<span class="hljs-built_in">push_back</span>(dist);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ans.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; --i) &#123;  <br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;  <br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-7">20250116</h2><h3 id="problem-7">Problem</h3><p><a href="https://atcoder.jp/contests/abc379/tasks/abc379_f"><strong>Buildings2</strong></a></p><p>输入 n(2≤n≤2e5) q(1≤q≤2e5) 和长为 n 的数组a(1≤a[i]≤n)，所有元素互不相同，下标从 1 开始。<br>然后输入 q 个询问，每个询问输入两个数 L 和 R (1≤L≤R≤n)。</p><p>有 n 栋建筑物，第 i 栋建筑物的高度是 a[i]。<br>如果下标在 [i+1,j-1] 中的建筑物高度都 &lt;= a[j]，那么在 i 能看到 j (i&lt; j)。<br>对于每个询问，输出：在 L 和 R 都能看到的、下标在 [R+1,n]中的建筑物的数量。</p><p>【灵茶の试炼】题目&amp;题解<br><a href="https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz" class="uri">https://docs.qq.com/sheet/DWGFoRGVZRmxNaXFz</a></p><h3 id="example-7">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>0<br>1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">6</span> <span class="hljs-number">9</span> <span class="hljs-number">8</span> <span class="hljs-number">7</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">10</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>3<br>1<br>2<br>1<br>0<br>1<br>1<br>0<br>0<br></code></pre></td></tr></table></figure><h3 id="solution-7">Solution</h3><p>离线，把询问按照左端点分组。</p><p>从右到左遍历 a，如果当前 a[i] 比右边的数 x 大，那么 x在后续遍历中必然无法被看见。这启发我们用单调栈解决。<br>单调栈保存的是下标。由于我们是倒着遍历的，所以栈是底大顶小的。<br>在单调栈上二分下标 &gt; r 的下标个数，即为能看到的建筑物的个数。</p><p>小技巧：为方便调用库函数，可以在单调栈中保存下标的相反数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">cnv</span>(a);<br>    vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">ls</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        ls[l].<span class="hljs-built_in">push_back</span>(&#123;r<span class="hljs-number">-1</span>,i&#125;);<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(q)</span>,st</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-type">int</span> v = a[i];<br>        <span class="hljs-keyword">while</span> (!st.<span class="hljs-built_in">empty</span>() &amp;&amp; v &gt; a[-st.<span class="hljs-built_in">back</span>()]) &#123;<br>            st.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        st.<span class="hljs-built_in">pb</span>(-i);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : ls[i]) &#123;<br>            ans[p.second] = <span class="hljs-built_in">lower_bound</span>(st.<span class="hljs-built_in">begin</span>(), st.<span class="hljs-built_in">end</span>(), -p.first) - st.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : ans) &#123;<br>        cout &lt;&lt; v &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-8">20250117</h2><h3 id="problem-8">Problem</h3><p><a href="https://atcoder.jp/contests/arc183/tasks/arc183_c"><strong>NotArgmax</strong></a></p><p>输入 n(1≤n≤500) m(1≤m≤1e5)。<br>你需要构造一个 1<sub>n</sub> 的排列 P。<br>然后输入 m 个约束，每个约束输入 L R X (1≤L≤X≤R≤n)，表示P[L],P[L+1],...,P[R] 中的最大值不能是 P[X]。<br>输出有多少个符合要求的排列 P，模 998244353。</p><h3 id="example-8">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">1</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">7</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">8</span> <span class="hljs-number">7</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">1598400</span><br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">15 </span><span class="hljs-number">17</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">11</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">15</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">14</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">11</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">15</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">15</span> <span class="hljs-number">12</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">11</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">13</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">14</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">15</span> <span class="hljs-number">11</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">8</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">14</span> <span class="hljs-number">8</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">10</span> <span class="hljs-number">2</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">12</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">14</span> <span class="hljs-number">12</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">6</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">921467228</span><br></code></pre></td></tr></table></figure><h3 id="solution-8">Solution</h3><p>如果 x 可以是区间 [L,R] 中的最大值的下标，那么把最大值放置在下标 x上，问题变成：<br>1. 从 R-L 个非最大值中，选 x-L 个数分到区间 [L,x-1]中的方案数（其余数分到区间 [x+1,R]）。<br>2. 区间 [L,x-1] 的排列数。<br>3. 区间 [x+1,R] 的排列数。<br>三者互相独立，根据乘法原理相乘。</p><p>这样就有子问题了，于是定义 f[L] [R] 表示区间 [L,R] 的排列数。<br>枚举可以是区间 [L,R] 的最大值的下标 x，我们有<br>f[L] [R] = sum(C(R-L,x-L) * f[L] [x-1] * f[x+1] [R] for x invalid[L,R])。</p><p>怎么计算哪些 x 可以是最大值的下标？<br>把输入按照右端点分组。<br>在枚举 R 的过程中，把左端点 &gt;= L 的 x 标记为「不能是最大值」。<br>为什么可以这样做？如果 x 不能是 [l,r] 中的最大值的下标，那么对于任意包含[l,r] 的更大的区间 [L,R]，x 也不能是 [L,R] 中的最大值的下标。</p><p>初始值 f[i] [i-1] = 1。<br>答案为 f[1] [n]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> mx = <span class="hljs-number">500</span>;<br><span class="hljs-type">int</span> F[mx], invF[mx];<br>vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; ban;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pow_mod</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = <span class="hljs-number">1LL</span> * res * a % mod;<br>        a = <span class="hljs-number">1LL</span> * a * a % mod;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">C</span><span class="hljs-params">(<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (k &lt; <span class="hljs-number">0</span> || k &gt; n) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">1LL</span> * F[n] * invF[k] % mod * invF[n - k] % mod;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    F[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; mx; i++) &#123;<br>        F[i] = <span class="hljs-number">1LL</span> * F[i - <span class="hljs-number">1</span>] * i % mod;<br>    &#125;<br>    invF[mx - <span class="hljs-number">1</span>] = <span class="hljs-built_in">pow_mod</span>(F[mx - <span class="hljs-number">1</span>], mod - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mx - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        invF[i] = <span class="hljs-number">1LL</span> * invF[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % mod;<br>    &#125;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    ban.<span class="hljs-built_in">resize</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> l, r, x;<br>        cin &gt;&gt; l &gt;&gt; r &gt;&gt; x;<br>        ban[r].<span class="hljs-built_in">push_back</span>(&#123;l, x&#125;);<br>    &#125;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vi</span>(n + <span class="hljs-number">1</span>));<br>    f[n + <span class="hljs-number">1</span>][n] = <span class="hljs-number">1</span>;<br>    <span class="hljs-comment">// DP process</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> l = n; l &gt;= <span class="hljs-number">1</span>; l--) &#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>)</span></span>;<br>        f[l][l - <span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        <br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = l; r &lt;= n; r++) &#123;<br>            <span class="hljs-comment">// Mark banned values</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; p : ban[r]) &#123;<br>                <span class="hljs-keyword">if</span> (p.first &gt;= l) &#123;<br>                    b[p.second] = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;<br>            <br>            <span class="hljs-comment">// Calculate f[l][r]</span><br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x = l; x &lt;= r; x++) &#123;<br>                <span class="hljs-keyword">if</span> (!b[x]) &#123;<br>                    f[l][r] = (f[l][r] + <span class="hljs-number">1LL</span> * <span class="hljs-built_in">C</span>(r - l, x - l) * f[l][x - <span class="hljs-number">1</span>] % mod * f[x + <span class="hljs-number">1</span>][r]) % mod;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; f[<span class="hljs-number">1</span>][n] &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-9">20250120</h2><h3 id="problem-9">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1364/A">XXXXX</a></p><p>输入 T(≤5) 表示 T 组数据。<br>每组数据输入 n(1≤n≤1e5) x(1≤x≤1e4) 和长为 n 的数组 a(0≤a[i]≤1e4)。</p><p>输出 a 的最长连续子数组的长度，满足子数组的元素和不是 x的倍数。<br>如果没有这样的子数组，输出 -1。</p><h3 id="example-9">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs diff">2<br>3<br><span class="hljs-deletion">-1</span><br></code></pre></td></tr></table></figure><h3 id="solution-9">Solution</h3><p>1.如果sum(a)不是x的倍数，输出n</p><p>2.否则删除一段和为x的倍数的子数组再删除一个数，便是答案</p><p>3.如果全是x的倍数，输出-1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,x,v;<br>    cin &gt;&gt; n &gt;&gt; x;<br>    <span class="hljs-type">int</span> s = <span class="hljs-number">0</span>,l = <span class="hljs-number">-1</span>, r = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; v;<br>        s += v;<br>        <span class="hljs-keyword">if</span> (v % x != <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span>) &#123;<br>                l = i;<br>            &#125;<br>            r = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (s % x != <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; n &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (l &lt; <span class="hljs-number">0</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-built_in">max</span>(n-l<span class="hljs-number">-1</span>,r) &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-10">20250121</h2><h3 id="problem-10">Problem</h3><p><a href="https://atcoder.jp/contests/abc376/tasks/abc376_e"><strong>Max ×Sum</strong></a></p><p>输入 T(≤2e5) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n k(1≤k≤n≤2e5)，长为 n 的数组 a(1≤a[i]≤1e6)，长为 n 的数组b(1≤b[i]≤1e6)。</p><p>你需要从 n 个下标中选择恰好 k 个下标，组成集合 S。<br>输出 max(a[i] for i in S) * sum(b[i] for i in S) 的最小值。</p><h3 id="example-10">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">7</span> <span class="hljs-number">6</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span> <span class="hljs-number">9</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">6</span> <span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">7</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">61 </span><span class="hljs-number">95</span> <span class="hljs-number">61</span> <span class="hljs-number">57</span> <span class="hljs-number">69</span> <span class="hljs-number">49</span> <span class="hljs-number">46</span> <span class="hljs-number">47</span> <span class="hljs-number">14</span> <span class="hljs-number">43</span><br><span class="hljs-symbol">39 </span><span class="hljs-number">79</span> <span class="hljs-number">48</span> <span class="hljs-number">92</span> <span class="hljs-number">90</span> <span class="hljs-number">76</span> <span class="hljs-number">30</span> <span class="hljs-number">16</span> <span class="hljs-number">30</span> <span class="hljs-number">94</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">42<br>60<br>14579<br></code></pre></td></tr></table></figure><h3 id="solution-10">Solution</h3><p>假设 a[i] 是最大的，那么我们需要在所有 &lt;= a[i] 的对应的 b[j]中，选择最小的 k 个数。</p><p>把 a 和 b 绑在一起，按照 a 从小到大排序。<br>然后遍历 a，用最大堆维护最小的 k 个 b[i]。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <br>    vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i].first;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i].second;<br>    <br>    <span class="hljs-comment">// Sort by x coordinate</span><br>    <span class="hljs-built_in">sort</span>(a);<br>     <br>    <span class="hljs-type">int</span> ans = INF;<br>    <span class="hljs-type">int</span> bsum = <span class="hljs-number">0</span>;<br>    priority_queue&lt;<span class="hljs-type">int</span>&gt; pq;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>    &#123;<br>        <span class="hljs-type">int</span> c = a[i].first, b = a[i].second;<br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() == (k - <span class="hljs-number">1</span>))<br>        &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans, c * (bsum + b));<br>        &#125;<br>        pq.<span class="hljs-built_in">push</span>(b);<br>        bsum += b;<br>        <span class="hljs-comment">// maintain bsum</span><br>        <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &gt; (k - <span class="hljs-number">1</span>))<br>        &#123;<br>            bsum -= pq.<span class="hljs-built_in">top</span>(); <span class="hljs-comment">// smallest (k-1)</span><br>            pq.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-11">20250122</h2><h3 id="problem-11">Problem</h3><p><a href="https://atcoder.jp/contests/abc356/tasks/abc356_e"><strong>Max/Min</strong></a></p><p>输入 n(2≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e6)。下标从 1 开始。</p><p>定义 f(i,j) = floor(max(a[i],a[j]) / min(a[i],a[j]))。</p><p>输出所有 f(i,j) 之和，其中 1≤i&lt;j≤n。</p><h3 id="example-11">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span> <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">6</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">7</span> <span class="hljs-number">1</span> <span class="hljs-number">8</span> <span class="hljs-number">2</span> <span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">53<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">12</span><br><span class="hljs-attribute">3</span> <span class="hljs-number">31</span> <span class="hljs-number">314</span> <span class="hljs-number">3141</span> <span class="hljs-number">31415</span> <span class="hljs-number">314159</span> <span class="hljs-number">2</span> <span class="hljs-number">27</span> <span class="hljs-number">271</span> <span class="hljs-number">2718</span> <span class="hljs-number">27182</span> <span class="hljs-number">271828</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">592622<br></code></pre></td></tr></table></figure><h3 id="solution-11">Solution</h3><p>本质上是从 a 中选两个数来计算，所以 a 中元素顺序不影响答案。</p><p>（调和级数）枚举数字 i 以及 i 的倍数 j，那么 [j,j+i-1]范围内的数，除以 i 下取整都等于 j/i。这些数可以合在一起计算。<br>为了快速知道范围中的元素个数，可以先统计每个元素的出现次数 cnt，然后计算cnt 的前缀和。</p><p>注意所有等于 i 的数，对答案的正确贡献是 C(cnt[i],2)，但按照上面的算法会错误地把 cnt[i]<sup>2</sup> 加进去，<br>所以要额外减去 cnt[i]<sup>2</sup> - C(cnt[i], 2) =cnt[i]*(cnt[i]+1)/2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, v, ans=<span class="hljs-number">0</span>;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> mx = <span class="hljs-number">1e6</span>;<br>    <span class="hljs-function">vi <span class="hljs-title">s</span><span class="hljs-params">(mx<span class="hljs-number">+1</span>)</span></span>;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; v;<br>        s[v]++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= mx; i++) &#123;<br>        s[i] += s[i<span class="hljs-number">-1</span>];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= mx; i++) &#123;<br>        <span class="hljs-type">int</span> c = s[i] - s[i<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= mx; j+=i) &#123;<br>            ans += j/i *(s[<span class="hljs-built_in">min</span>(j+i<span class="hljs-number">-1</span>,mx)]-s[j<span class="hljs-number">-1</span>])*c;<br>        &#125;<br>        ans -= c*(c<span class="hljs-number">+1</span>)/<span class="hljs-number">2</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-12">20250123</h2><h3 id="problem-12">Problem</h3><p><a href="https://atcoder.jp/contests/abc381/tasks/abc381_f"><strong>1122Subsequence</strong></a></p><p>输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤20)。</p><p>输出 a 的子序列 b 的最长长度，满足：<br>1. b 的长度是偶数。<br>2. b[0]=b[1], b[2]=b[3], ... 即两个两个一组，每组中的元素都相同。<br>3. b 中的每种数字恰好在 b 中出现两次。</p><p>注：子序列不一定连续。</p><h3 id="example-12">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">7</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>20<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">0<br></code></pre></td></tr></table></figure><h3 id="solution-12">Solution</h3><p>状态设计题。</p><p>定义 f[i] 表示 b 中元素恰好组成集合 i 的情况下，b 的最后一个元素在 a中的下标的最小值。<br>枚举不在集合 i 中的 j，在 a 中下标 f[i] 右边寻找两个最近的元素j，用第二个 j 的下标更新 f[i|1&lt;&lt;j] 的最小值。</p><p>初始值 f[0]=-1, f[i]=inf。<br>最后答案为：对于不等于 inf 的 f[i]，计算 i 的二进制 1 的个数的最大值 *2。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">int</span> inf = <span class="hljs-number">0x7f7f7f7f</span>;<br><span class="hljs-type">int</span> dp[(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>)<span class="hljs-number">+5</span>];<br><span class="hljs-type">int</span> a[N];<br><span class="hljs-type">int</span> to[N][<span class="hljs-number">25</span>];<br><span class="hljs-type">int</span> n,ans;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-built_in">memset</span>(dp,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(dp));<br>    <span class="hljs-type">int</span> trans[<span class="hljs-number">25</span>];<br>    <span class="hljs-built_in">memset</span>(trans,<span class="hljs-number">0x7f</span>,<span class="hljs-built_in">sizeof</span>(trans));<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=<span class="hljs-number">20</span>;j++)<br>            to[i][j] = trans[j];<br>        trans[a[i]] = i;<br>    &#125;<br>    <span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">after_two</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> t)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(x == inf || to[x][t] == inf)<br>        <span class="hljs-keyword">return</span> inf;<br>    <span class="hljs-keyword">return</span> to[to[x][t]][t];<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">record_num</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(x)&#123;<br>        cnt += (x&amp;<span class="hljs-number">1</span>);<br>        x &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> cnt;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-built_in">init</span>();<br>    dp[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> k=<span class="hljs-number">1</span>;k&lt;(<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-number">20</span>);k++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=<span class="hljs-number">20</span>;i++)&#123;<br>            <span class="hljs-keyword">if</span>(!(k &amp; (<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>))))<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-type">int</span> k0 = k - (<span class="hljs-number">1</span>&lt;&lt;(i<span class="hljs-number">-1</span>));<br>            <span class="hljs-keyword">if</span>(dp[k0] == inf)<br>                <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">after_two</span>(dp[k0],i) == inf)<br>                <span class="hljs-keyword">continue</span>;<br>            dp[k] = <span class="hljs-built_in">min</span>(dp[k],<span class="hljs-built_in">after_two</span>(dp[k0],i));<br>        &#125;<br>        <span class="hljs-keyword">if</span>(dp[k] != inf)<br>            ans = <span class="hljs-built_in">max</span>(ans,<span class="hljs-built_in">record_num</span>(k));<br>    &#125;<br>    cout &lt;&lt; (ans&lt;&lt;<span class="hljs-number">1</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-13">20250124</h2><h3 id="problem-13">Problem</h3><p><a href="https://atcoder.jp/contests/abc160/tasks/abc160_f"><strong>DistributingIntegers</strong></a></p><p>输入 n(2≤n≤2e5) 和一棵无向树的 n-1 条边，节点编号从 1 到 n。</p><p>定义 f(i) 为如下过程的方案数：<br>首先，在节点 i 写下数字 1。<br>然后，选择一个与写下数字节点相邻的节点（没有写过数字），写下数字2。<br>继续，重复上述过程，依次写下数字 3,4,...,n。</p><p>输出 f(1),f(2),...,f(n)。</p><h3 id="example-13">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>1<br>1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>1<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>8<br>12<br>3<br>3<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">8</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">5</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">8</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">40<br>280<br>840<br>120<br>120<br>504<br>72<br>72<br></code></pre></td></tr></table></figure><h3 id="solution-13">Solution</h3><p>f(1) 怎么算？<br>写下所有数字后，如果 DFS 遍历这棵树，按顺序记录遍历到的数字，会得到一个1<sub>n</sub> 的排列，总共有 n! 种，其中肯定有不合法的。<br>比如，这个排列肯定要以 1 开头，所有不以 1 开头的排列都是不合法的。以 1开头的排列个数是 (n-1)!，相当于把 n! 除以 n。<br>同理，对于每棵子树 v 而言（对应着 1<sub>n</sub>排列中的一个子序列），不以 v的标记数字开头的排列都是不合法的，同样要把方案数除以 size[v]，即子树 v的大小。<br>所以 f(1) = n! / (size[1] * size[2] * ... * size[n])。</p><p>对于其他 f(i)，我们可以在 f(1) 的基础上，用换根 DP快速计算上式的分母。<br>从节点 x 换到节点 y，先除以 size[y]，对于不在子树 y 中的节点，会形成一棵y 的子树，所以要乘以 (n-size[y])。</p><p>由于上述过程有除法，需要用逆元（费马小定理）计算。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">using</span> ll = <span class="hljs-type">long</span> <span class="hljs-type">long</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1e9</span> + <span class="hljs-number">7</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MAXN = <span class="hljs-number">2e5</span> + <span class="hljs-number">5</span>;<br><br>vector&lt;<span class="hljs-type">int</span>&gt; adj[MAXN];<br>ll fact[MAXN], inv_fact[MAXN];<br>ll dp[MAXN];<br><span class="hljs-type">int</span> sz[MAXN];<br><span class="hljs-type">int</span> n;<br>vector&lt;ll&gt; ans;<br><br><span class="hljs-function">ll <span class="hljs-title">pow_mod</span><span class="hljs-params">(ll a, ll b)</span> </span>&#123;<br>    ll res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (b) &#123;<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>) res = res * a % MOD;<br>        a = a * a % MOD;<br>        b &gt;&gt;= <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">precompute</span><span class="hljs-params">()</span> </span>&#123;<br>    fact[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; MAXN; i++) &#123;<br>        fact[i] = fact[i - <span class="hljs-number">1</span>] * i % MOD;<br>    &#125;<br>    inv_fact[MAXN - <span class="hljs-number">1</span>] = <span class="hljs-built_in">pow_mod</span>(fact[MAXN - <span class="hljs-number">1</span>], MOD - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = MAXN - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        inv_fact[i] = inv_fact[i + <span class="hljs-number">1</span>] * (i + <span class="hljs-number">1</span>) % MOD;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> parent)</span> </span>&#123;<br>    sz[u] = <span class="hljs-number">1</span>;<br>    dp[u] = <span class="hljs-number">1</span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; children;<br>    ll sum_s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v == parent) <span class="hljs-keyword">continue</span>;<br>        children.<span class="hljs-built_in">push_back</span>(v);<br>        <span class="hljs-built_in">dfs</span>(v, u);<br>        sz[u] += sz[v];<br>        sum_s += sz[v];<br>        dp[u] = dp[u] * dp[v] % MOD;<br>    &#125;<br>    ll comb = fact[sum_s];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : children) &#123;<br>        comb = comb * inv_fact[sz[v]] % MOD;<br>    &#125;<br>    dp[u] = dp[u] * comb % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">reroot</span><span class="hljs-params">(<span class="hljs-type">int</span> u, <span class="hljs-type">int</span> parent)</span> </span>&#123;<br>    ans[u - <span class="hljs-number">1</span>] = dp[u];<br>    vector&lt;<span class="hljs-type">int</span>&gt; children;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : adj[u]) &#123;<br>        <span class="hljs-keyword">if</span> (v != parent) &#123;<br>            children.<span class="hljs-built_in">push_back</span>(v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> original_sz_u = sz[u];<br>    ll original_dp_u = dp[u];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : children) &#123;<br>        <span class="hljs-type">int</span> original_sz_v = sz[v];<br>        ll original_dp_v = dp[v];<br>        <span class="hljs-type">int</span> s_v = original_sz_v;<br>        <span class="hljs-type">int</span> sum_s = original_sz_u - <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> sum_s_new = sum_s - s_v;<br>        ll numerator = original_dp_u * <span class="hljs-built_in">pow_mod</span>(dp[v], MOD - <span class="hljs-number">2</span>) % MOD;<br>        numerator = numerator * fact[sum_s_new] % MOD;<br>        numerator = numerator * fact[s_v] % MOD;<br>        numerator = numerator * inv_fact[sum_s] % MOD;<br>        ll dp_parent = numerator % MOD;<br>        <span class="hljs-type">int</span> s_parent = n - original_sz_v;<br>        ll product_dp = <span class="hljs-number">1</span>;<br>        ll product_sz_fact = <span class="hljs-number">1</span>;<br>        ll sum_s_new_v = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> child : adj[v]) &#123;<br>            <span class="hljs-keyword">if</span> (child == u) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (child == parent) &#123;<br>                product_dp = product_dp * dp_parent % MOD;<br>                product_sz_fact = product_sz_fact * fact[s_parent] % MOD;<br>                sum_s_new_v += s_parent;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                product_dp = product_dp * dp[child] % MOD;<br>                product_sz_fact = product_sz_fact * fact[sz[child]] % MOD;<br>                sum_s_new_v += sz[child];<br>            &#125;<br>        &#125;<br>        sum_s_new_v += s_parent;<br>        product_dp = product_dp * dp_parent % MOD;<br>        product_sz_fact = product_sz_fact * fact[s_parent] % MOD;<br>        ll comb_v = fact[sum_s_new_v] * <span class="hljs-built_in">pow_mod</span>(product_sz_fact, MOD - <span class="hljs-number">2</span>) % MOD;<br>        ll new_dp_v = product_dp * comb_v % MOD;<br>        sz[v] = n;<br>        dp[v] = new_dp_v;<br>        <span class="hljs-built_in">reroot</span>(v, u);<br>        sz[v] = original_sz_v;<br>        dp[v] = original_dp_v;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">precompute</span>();<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-type">int</span> u, v;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        adj[u].<span class="hljs-built_in">push_back</span>(v);<br>        adj[v].<span class="hljs-built_in">push_back</span>(u);<br>    &#125;<br>    ans.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-built_in">reroot</span>(<span class="hljs-number">1</span>, <span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">for</span> (ll x : ans) &#123;<br>        cout &lt;&lt; x &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-14">20250127</h2><h3 id="problem-14">Problem</h3><p><a href="https://codeforces.com/problemset/problem/2037/C">Superultra'sFavorite Permutation</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(2≤n≤2e5)。</p><p>构造一个 1<sub>n</sub> 的排列，满足任意相邻两数之和都是合数。<br>如果无法构造，输出 -1。</p><h3 id="example-14">Example</h3><p>输入</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br>8<br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs tap">-1<br>1<span class="hljs-number"> 8 </span>7<span class="hljs-number"> 3 </span>6<span class="hljs-number"> 2 </span>4 5<br></code></pre></td></tr></table></figure><h3 id="solution-14">Solution</h3><p>除了 2 以外的偶数都是合数。由于我们无法构造出2，相邻元素之和只要是偶数，那么一定是合数。</p><p>奇数+奇数=偶数，偶数+偶数=偶数。<br>所以把奇数放在一起，把偶数放在一起。</p><p>唯一需要注意的是奇偶交界的位置，是奇数+偶数。<br>最小的奇合数是 9。<br>满足 奇数+偶数=奇合数 的最小数对是 5+4。</p><p>所以 n&lt;5 直接输出 -1。<br>否则答案存在，按顺序输出以下内容：<br>1<sub>n</sub> 中的除了 5 以外的奇数。<br>5 和 4。<br>1<sub>n</sub> 中的除了 4 以外的偶数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">if</span> (n &lt; <span class="hljs-number">5</span>) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i!=<span class="hljs-number">5</span>)<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;5 4 &quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i += <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">if</span> (i != <span class="hljs-number">4</span>)<br>            cout &lt;&lt; i &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-15">20250128</h2><h3 id="problem-15">Problem</h3><p><a href="https://codeforces.com/problemset/problem/1932/C">LR-remainders</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤2e5) mod(1≤mod≤1e4)，长为 n 的数组a(1≤a[i]≤1e4)，长为 n 的字符串 s，只包含 L 和 R。</p><p>从左到右遍历 s，如果是 L，则去掉 a 最左边的元素，否则去掉 a最右边的元素。<br>每次去掉元素【之前】，输出 a 中所有元素乘积模 m 的结果。</p><p><a href="https://www.luogu.com.cn/problem/P4588">相似题目 P4588[TJOI2018] 数学计算</a></p><h3 id="example-15">Example</h3><p>输入</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">4</span><br><span class="hljs-attribute">4</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br><span class="hljs-attribute">LRRL</span><br><span class="hljs-attribute">5</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span> <span class="hljs-number">1</span><br><span class="hljs-attribute">LLLLL</span><br><span class="hljs-attribute">6</span> <span class="hljs-number">8</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">6</span><br><span class="hljs-attribute">RLLLRR</span><br><span class="hljs-attribute">1</span> <span class="hljs-number">10000</span><br><span class="hljs-attribute">10000</span><br><span class="hljs-attribute">R</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">1</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span><span class="hljs-number">0</span> <span class="hljs-number">0</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span> <span class="hljs-number">4</span><br><span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="solution-15">Solution</h3><p>反向遍历操作，由删除变为添加，起始点可以根据L和R的个数判断</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> cntL = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : s) &#123;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>            cntL++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> l = cntL - <span class="hljs-number">1</span>,r = cntL;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">1</span>;<br>    vi ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = s.<span class="hljs-built_in">length</span>()<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;L&#x27;</span>) &#123;<br>            sum = sum*a[l]%m;<br>            l--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sum = sum*a[r]%m;<br>            r++;<br>        &#125;<br>        ans.<span class="hljs-built_in">pb</span>(sum%m);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = ans.<span class="hljs-built_in">size</span>()<span class="hljs-number">-1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-16">20250129</h2><h3 id="problem-16">Problem</h3><p><a href="https://atcoder.jp/contests/abc133/tasks/abc133_e"><strong>VirusTree 2</strong></a></p><p>输入 n(1≤n≤1e5) k(1≤k≤1e5) 和一棵无向树的 n-1 条边，节点编号从 1 到n。</p><p>有 k 种颜色，你需要把每个节点染成 k 种颜色中的一个。<br>要求：对于相距为 1 或 2 的点对，颜色必须不同。</p><p>输出染色方案数，模 1e9+7。</p><h3 id="example-16">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">6<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">48<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">16 </span><span class="hljs-number">22</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">1</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">16</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">12</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">2</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">15</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">16</span><br><span class="hljs-symbol">14 </span><span class="hljs-number">16</span><br><span class="hljs-symbol">10 </span><span class="hljs-number">11</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">10</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">13</span><br><span class="hljs-symbol">8 </span><span class="hljs-number">6</span><br><span class="hljs-symbol">16 </span><span class="hljs-number">8</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">12</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">271414432</span><br></code></pre></td></tr></table></figure><h3 id="solution-16">Solution</h3><p>从特殊到一般，如果树是一条链，答案是多少？<br>从左到右思考：<br>第一个点可以染 k 种颜色；<br>第二个点颜色不能和前一个点相同，可以染 k-1 种颜色；<br>其余点不能和前两个点相同，可以染 k-2 种颜色。</p><p>对于一般树上的点 v，哪些点是在点 v 前面的距离点 v 至多为 2的点？<br>v 的父节点，<br>v 的父节点的父节点，<br>v 左边的兄弟节点（即 v 的父节点的儿子）。<br>那么 v 可以染 (k - 上述节点个数) 种颜色。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k,v,w;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n<span class="hljs-number">+1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        g[v].<span class="hljs-built_in">push_back</span>(w);<br>        g[w].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br>    <span class="hljs-type">int</span> ans = k;<br>    <span class="hljs-keyword">auto</span> dfs = [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> dep,<span class="hljs-keyword">auto</span>&amp;&amp; self) -&gt; <span class="hljs-type">void</span> &#123;<br>        <span class="hljs-type">int</span> c = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : g[v]) &#123;<br>            <span class="hljs-keyword">if</span> (w != fa) &#123;<br>                ans = ans * (k - <span class="hljs-built_in">min</span>(dep + <span class="hljs-number">1</span>, <span class="hljs-number">2LL</span>) - c) % mod;<br>                <span class="hljs-built_in">self</span>(w, v, dep + <span class="hljs-number">1</span>, self);<br>                c++;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, dfs);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-17">20250130</h2><h3 id="problem-17">Problem</h3><p><a href="https://atcoder.jp/contests/abc146/tasks/abc146_e"><strong>Rem ofSum is Num</strong></a></p><p>输入 n(1≤n≤2e5) k(1≤k≤1e9) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>输出 a 的非空连续子数组 b 的个数，满足 sum(b) % k = len(b)。</p><h3 id="example-17">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">5 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">4<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">8 </span><span class="hljs-number">4</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span> <span class="hljs-number">4</span> <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">7<br></code></pre></td></tr></table></figure><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">10 </span><span class="hljs-number">7</span><br><span class="hljs-symbol">14 </span><span class="hljs-number">15</span> <span class="hljs-number">92</span> <span class="hljs-number">65</span> <span class="hljs-number">35</span> <span class="hljs-number">89</span> <span class="hljs-number">79</span> <span class="hljs-number">32</span> <span class="hljs-number">38</span> <span class="hljs-number">46</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">8<br></code></pre></td></tr></table></figure><h3 id="solution-17">Solution</h3><p>由于 sum(b)%k &lt; k，所以子数组的长度至多为 k-1。</p><p>考虑前缀和，我们有 (s[r] - s[l]) % k = r - l = (r - l) % k。<br>所以 s[r] - s[l] 和 r - l 模 k 同余。<br>移项得 ((s[r] - r) - (s[l] - l)) % k = 0。<br>哈希表统计 (s[i]-i)%k 的个数，用【枚举右维护左】解决。</p><p>注意子数组的长度至多为 k-1，所以还要滑窗（移除左端点元素）。</p><p>注：s[i]-i 等价于计算 a[i]-1 的前缀和。<br>注：由于本题保证 a[i] &gt;= 1，所以无需考虑负数取模的问题。</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs prolog">void solve()<br>&#123;<br>    int n,k,ans=<span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    vi s(n+<span class="hljs-number">1</span>);<br>    for (int i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; s[i];<br>        s[i] = (s[i] + s[i<span class="hljs-number">-1</span>] - <span class="hljs-number">1</span>) <span class="hljs-comment">% k;</span><br>    &#125;<br>    mii cnt;<br>    for (int i = <span class="hljs-number">0</span>; i &lt;= n; i++) &#123;<br>        ans += cnt[s[i]];<br>        cnt[s[i]]++;<br>        if (i &gt;= k<span class="hljs-number">-1</span>) &#123;<br>            cnt[s[i-k+<span class="hljs-number">1</span>]]--;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="section-18">20250131</h2><h3 id="problem-18">Problem</h3><p><a href="https://atcoder.jp/contests/aising2020/tasks/aising2020_e"><strong>CamelTrain</strong></a></p><p>输入 T(≤1e5) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤2e5)。然后输入 n 行，每行输入三个数 ki(1≤ki≤n)li(1≤li≤1e9) ri(1≤ri≤1e9)。</p><p>有 n 只骆驼，你需要把这 n 只骆驼按照某种顺序，排成一行。<br>如果第 i 只骆驼在前 ki 个位置中，那么它的幸福值是 li，否则是 ri。<br>输出总幸福值的最大值。</p><p>本题简单版本：<a href="https://www.luogu.com.cn/problem/P2949">P2949[USACO09OPEN] Work Scheduling G</a></p><h3 id="example-18">Example</h3><p>输入</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-number">3</span><br><span class="hljs-number">2</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">10</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">15</span> <span class="hljs-number">5</span><br><span class="hljs-number">3</span><br><span class="hljs-symbol">2 </span><span class="hljs-number">93</span> <span class="hljs-number">78</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">71</span> <span class="hljs-number">59</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">57</span> <span class="hljs-number">96</span><br><span class="hljs-number">19</span><br><span class="hljs-symbol">19 </span><span class="hljs-number">23</span> <span class="hljs-number">16</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">90</span> <span class="hljs-number">13</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">85</span> <span class="hljs-number">70</span><br><span class="hljs-symbol">19 </span><span class="hljs-number">67</span> <span class="hljs-number">78</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">16</span> <span class="hljs-number">60</span><br><span class="hljs-symbol">18 </span><span class="hljs-number">48</span> <span class="hljs-number">28</span><br><span class="hljs-symbol">5 </span><span class="hljs-number">4</span> <span class="hljs-number">24</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">97</span> <span class="hljs-number">97</span><br><span class="hljs-symbol">4 </span><span class="hljs-number">57</span> <span class="hljs-number">87</span><br><span class="hljs-symbol">19 </span><span class="hljs-number">91</span> <span class="hljs-number">74</span><br><span class="hljs-symbol">18 </span><span class="hljs-number">100</span> <span class="hljs-number">76</span><br><span class="hljs-symbol">7 </span><span class="hljs-number">86</span> <span class="hljs-number">46</span><br><span class="hljs-symbol">9 </span><span class="hljs-number">100</span> <span class="hljs-number">57</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">76</span> <span class="hljs-number">73</span><br><span class="hljs-symbol">6 </span><span class="hljs-number">84</span> <span class="hljs-number">93</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">6</span> <span class="hljs-number">84</span><br><span class="hljs-symbol">11 </span><span class="hljs-number">75</span> <span class="hljs-number">94</span><br><span class="hljs-symbol">19 </span><span class="hljs-number">15</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">12 </span><span class="hljs-number">11</span> <span class="hljs-number">34</span><br></code></pre></td></tr></table></figure><p>输出</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">25</span><br><span class="hljs-number">221</span><br><span class="hljs-number">1354</span><br></code></pre></td></tr></table></figure><h3 id="solution-18">Solution</h3><p>初步分析</p><p>l &gt; r 的骆驼放在 l &lt; r的骆驼的左边是更优的（可以用交换法证明）。<br>所以把 l &gt; r的骆驼分成一组，其余骆驼分成另一组，两组互相独立，分别计算。</p><p>下面只讨论 l &gt; r 的情况。<br>我们可以先把所有 r 加起来，然后讨论 l-r 怎么选取。<br>如果没法把骆驼放在前 k 个中，那么幸福值只能是 r，这相当于不选 l-r。</p><p>方法一：反悔贪心（反悔堆）</p><p>按照 k 从小到大排序。<br>采取「捡到西瓜，丢掉芝麻」的反悔贪心策略：<br>先把 l-r 入堆（最小堆），如果入堆后发现堆的大小超过当前的k，则弹出堆顶的「芝麻」。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k,l,r;<br>    cin &gt;&gt; n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">a</span>(n<span class="hljs-number">+1</span>),<span class="hljs-built_in">b</span>(n);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; k &gt;&gt; l &gt;&gt; r;<br>        <span class="hljs-keyword">if</span> (l &gt; r) &#123;<br>            ans += r;<br>            a[k].<span class="hljs-built_in">push_back</span>(l-r);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += l;<br>            b[n-k].<span class="hljs-built_in">push_back</span>(r-l);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> f = [&amp;](vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; a) &#123;<br>        priority_queue&lt;<span class="hljs-type">int</span>, vector&lt;<span class="hljs-type">int</span>&gt;, greater&lt;&gt;&gt; pq;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; a.<span class="hljs-built_in">size</span>(); i++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; a[i].<span class="hljs-built_in">size</span>(); j++) &#123;<br>                ans += a[i][j];<br>                pq.<span class="hljs-built_in">push</span>(a[i][j]);<br>                <span class="hljs-keyword">if</span> (pq.<span class="hljs-built_in">size</span>() &gt; i) &#123;<br>                    <span class="hljs-type">int</span> h = pq.<span class="hljs-built_in">top</span>();<br>                    pq.<span class="hljs-built_in">pop</span>();<br>                    ans -= h;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">f</span>(a);<br>    <span class="hljs-built_in">f</span>(b);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><p>方法二：有序集合</p><p>按照 l-r 从大到小排序。<br>最大的 l-r 肯定是要选的，为了能让其他 l-r 有位置放，最大的 l-r放的位置越靠右越好，那就放在第 k 个位置。</p><p>一般地，用一个有序集合维护空位。<br>每次找到 &lt;= k的最大空位，放置骆驼，然后从有序集合中删除这个位置。<br>如果没有 &lt;= k 的空位，就不放骆驼。</p><p>方法三：并查集</p><p>把方法二的有序集合改成用并查集维护。删除一个数就相当于把 i 指向i-1。这样 find(i) 就是 &lt;= i 的最大空位。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="codeforces" scheme="http://polaris3003.github.io/categories/codeforces/"/>
    
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture13</title>
    <link href="http://polaris3003.github.io/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/"/>
    <id>http://polaris3003.github.io/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/</id>
    <published>2024-12-03T11:36:40.000Z</published>
    <updated>2025-02-11T09:25:22.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十三课查询处理ii">第十三课：查询处理II</h1><h2 id="背景">1 背景</h2><p>前面关于查询执行的讨论都假设查询由单个工作器（即线程）执行。然而，在实践中，查询通常由多个工作器并行执行。</p><p>并行执行为 DBMS 提供了许多关键优势：</p><ul><li>提高吞吐量（每秒更多查询）和延迟（每个查询所用时间更少）的性能。</li><li>从 DBMS 外部客户端的角度来看，响应能力和可用性有所提高。</li><li>潜在降低总拥有成本 (TCO)。此成本包括硬件采购和软件许可，以及部署DBMS 的人工开销和运行机器所需的能源。</li></ul><p>DBMS 支持两种类型的并行性：查询间并行性和查询内并行性。</p><h2 id="并行vs分布式数据库">2 并行vs分布式数据库</h2><p>在并行和分布式系统中，数据库分布在多个“资源”上以提高并行性。这些资源可能是计算资源（例如，CPU内核、CPU 插槽、GPU、附加机器）或存储资源（例如，磁盘、内存）。</p><p>区分并行和分布式系统非常重要。</p><ul><li><strong>并行DBMS</strong> 在并行 DBMS中，资源或节点在物理上彼此接近。这些节点通过高速互连进行通信。假设资源之间的通信不仅快速，而且廉价可靠。</li><li><strong>分布式DBMS</strong> 在分布式 DBMS中，资源可能彼此相距甚远；这可能意味着数据库跨越世界不同地区的机架或数据中心。因此，资源通过公共网络进行通信时，互连速度较慢，节点之间的通信成本较高，故障不容忽视。</li></ul><p>即使数据库可能在物理上分布在多个资源上，但它在应用程序看来仍然是一个逻辑数据库实例。因此，针对单节点DBMS 执行的 SQL 查询应该在并行或分布式 DBMS 上生成相同的结果。</p><h2 id="处理模型">3 处理模型</h2><p>DBMS 进程模型定义系统如何支持来自多用户应用程序/环境的并发请求。DBMS由多个工作器组成，负责代表客户端执行任务并返回结果。应用程序可能会同时发送一个或多个大型请求，这些请求必须分配给不同的工作程序。</p><p>DBMS可能采用两种主要进程模型：每个工作者进程和每个工作者线程。第三种常见的数据库使用模式采用嵌入式方法。</p><p><img src="/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/image-20241203205321890.png" alt="图1：每个工作者进程模型" id="image1"></p><h3 id="每个工作者进程">每个工作者进程</h3><p>最基本的方法是每个工作进程。在这里，每个工作进程都是一个单独的操作系统进程，因此依赖于操作系统调度程序。应用程序发送请求并打开与数据库系统的连接。一些调度程序接收请求，选择其中一个工作进程来管理连接。应用程序现在直接与负责执行查询请求的工作进程进行通信。此事件序列如<a href="#image1">图 1</a>所示。</p><p>依赖操作系统进行调度会有效降低 DBMS对执行的控制力。此外，该模型依赖共享内存来维护全局数据结构或依赖消息传递，开销较高。</p><p>每个工作进程方法的优点在于进程崩溃不会破坏整个系统，因为每个工作进程都在其自己的操作系统进程上下文中运行。</p><p>这个过程模型提出了多个在不同进程中工作的工人制作同一页面多个副本的问题。一个最大化内存使用的解决方案是使用共享内存来存储全局数据结构，以便不同进程中的工人可以共享这些数据。</p><p>采用每个工作进程模型的系统示例包括 IBM DB2、Postgres 和Oracle。当这些 DBMS 被开发时，pthreads尚未成为标准线程模型。线程的语义因操作系统而异，而 fork()的定义更为明确。</p><h3 id="每个工作者线程">每个工作者线程</h3><p>如今最常见的模型是每个工作线程一个线程。不同于让不同的进程执行不同的任务，每个数据库系统只有一个进程和多个工作线程。在这种环境中，数据库管理系统（DBMS）对任务和线程具有完全的控制权，可以管理自己的调度。多线程模型可能使用或不使用分发线程。线程每个工作的模型示意图如<a href="#image2">图 2</a>所示。</p><p>使用多线程架构提供了一定的优势。首先，每次上下文切换的开销较小。此外，不必维护共享模型。然而，每个工作线程的模型并不一定意味着数据库管理系统支持查询内部的并行性。</p><p>在过去20年中几乎所有创建的数据库管理系统都采用这种方法，包括MicrosoftSQL Server和MySQL。IBMDB2和Oracle也更新了他们的模型，以支持这种方法。Postgres和Postgres衍生的数据库在很大程度上仍然使用基于进程的方法。</p><p><img src="/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/image-20250120141109075.png" alt="图2：每个工作者线程模型" id="image2"></p><h3 id="调度">调度</h3><p>总之，对于每个查询计划，DBMS必须决定在何处、何时以及如何执行。相关问题包括：</p><ul><li>应该使用多少个任务？</li><li>应该使用多少个CPU核心？</li><li>这些任务应该在哪些 CPU 核心上执行？</li><li>任务应该将其输出存储在哪里？</li></ul><p>在制定有关查询计划的决策时，DBMS 总是比 OS了解得更多，因此应该优先考虑。</p><p><img src="/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/image-20250120141738917.png" alt="图3：嵌入式 DBMS 调度" id="image3"></p><h3 id="嵌入式dbms">嵌入式DBMS</h3><p>一种非常不同的数据库使用模式涉及将系统在应用程序的相同地址空间中运行，与数据库独立于应用程序的客户端-服务器模型相对。在这种情况下，应用程序将设置线程和任务以在数据库系统上运行。应用程序本身在很大程度上将负责调度。嵌入式数据库管理系统的调度行为的示意图如<a href="#image3">图3</a>所示。</p><p>DuckDB、SQLite和RocksDB是最著名的嵌入式数据库管理系统。</p><h2 id="查询间并行">4 查询间并行</h2><p>在查询间并行中，DBMS会同时执行不同的查询。由于多个工作器同时运行请求，因此整体性能得到改善。这会增加吞吐量并减少延迟。</p><p>如果查询是只读的，则查询之间几乎不需要协调。但是，如果多个查询同时更新数据库，则会出现更复杂的冲突。这些问题将在第15 讲中进一步讨论。</p><h2 id="查询内并行">5 查询内并行</h2><p>在查询内并行中，DBMS并行执行单个查询的操作。这减少了长时间运行的查询的延迟。</p><p>查询内并行性的组织可以从生产者/消费者范式的角度来思考。每个操作符都是数据的生产者，同时也是其下层运行的操作符的数据的消费者。</p><p><img src="/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/image-20250206141201753.png" alt="图4：操作内部并行性 – 此SELECT的查询计划是在A上进行的顺序扫描，结果被输入到一个过滤操作符中。为了并行运行，查询计划被划分为不相交的片段。给定的计划片段由不同的工作者进行操作。交换操作符同时在所有片段上调用Next，然后从各自的页面检索数据。" id="image4"></p><p>每个关系运算符都有并行算法。DBMS既可以让多个线程访问集中式数据结构，也可以使用分区来划分工作。</p><p>在查询内并行性中，有三种类型的并行性：操作内并行性、操作间并行性和密集并行性。这些方法并不相互排斥。DBMS有责任将这些技术结合起来，以优化给定工作负载的性能。</p><h3 id="操作内并行性水平">操作内并行性（水平）</h3><p>在操作符内并行中，查询计划的操作符被分解为独立的片段，这些片段对不同的（不相交的）数据子集执行相同的功能。</p><p>DBMS在查询计划中插入一个交换运算符，以合并子运算符的结果。交换运算符会阻止DBMS 在计划中执行其上方的运算符，直到它收到来自子运算符的所有数据。<a href="#image4">图4</a>中展示了一个样例。</p><p>一般来说，交换操作有三种类型：</p><ul><li><strong>聚集</strong>：将多个worker中的结果聚合成单个输出流。这是并行DBMS 中最常用的类型。</li><li><strong>分发</strong>：将单个输入流分成多个输出流。</li><li><strong>重新分区</strong>：在多个输出流中重新组织多个输入流。这允许DBMS 接收以一种方式分区的输入，然后以另一种方式重新分配它们。</li></ul><h3 id="操作间并行性垂直">操作间并行性（垂直）</h3><p>在运算符间并行中，DBMS重叠运算符，以便将数据从一个阶段流水线传输到下一个阶段而无需具体化。这有时称为流水线并行。参见<a href="#image5">图 5</a> 中的示例。</p><p>这种方法广泛应用于流处理系统，即对输入元组流持续执行查询的系统。</p><p><img src="/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/image-20250206144107341.png" alt="图5：操作间并行 - 在左边的 JOIN 语句中，一个工作者执行连接，然后将结果发送给另一个工作者，后者执行投影，然后再次发出结果。" id="image5"></p><p><img src="/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/image-20250206144425418.png" alt="图6：密集平行性 - 为了对三个表执行 4 路 JOIN，查询计划被分为四个片段，如图所示。查询计划的不同部分同时运行，方式类似于运算符间并行。" id="image6"></p><h3 id="密集并行性">密集并行性</h3><p>密集并行是操作符内并行和操作符间并行的混合，其中工作者同时执行来自查询计划的不同段的多个操作符。</p><p>DBMS 仍然使用交换运算符来组合这些段的中间结果。示例如<a href="#image6">图 6</a> 所示。</p><h2 id="io并行">6 I/O并行</h2><p>如果磁盘始终是主要瓶颈，那么使用额外的进程/线程来并行执行查询不会提高性能。因此，能够将数据库拆分到多个存储设备中非常重要。</p><p>为了解决这个问题，DBMS 使用 I/O 并行性将安装拆分到多个设备上。I/O并行性的两种方法是多磁盘并行性和数据库分区。</p><h3 id="多磁盘并行">多磁盘并行</h3><p>在多磁盘并行中，操作系统/硬件配置为将 DBMS的文件存储在多个存储设备上。这可以通过存储设备或 RAID配置来实现。所有存储设置对 DBMS都是透明的，因此工作人员无法在不同的设备上运行，因为 DBMS不知道底层的并行性。</p><h3 id="数据库分区">数据库分区</h3><p>在数据库分区中，数据库被分成不相交的子集，可以分配给离散磁盘。一些DBMS 允许指定每个单独数据库的磁盘位置。如果 DBMS将每个数据库存储在单独的目录中，则在文件系统级别上很容易做到这一点。更改的日志文件通常是共享的。</p><p>逻辑分区的想法是将单个逻辑表分成不相交的物理段，并单独存储/管理。理想情况下，这种分区对于应用程序来说是透明的。也就是说，应用程序应该能够访问逻辑表，而不必关心内容是如何存储的。</p><p>分区有两种方法：垂直分区和水平分区。</p><p>在垂直分区中，表的属性存储在单独的位置（如列存储）。必须存储元组信息才能重建原始记录。</p><p>在水平分区中，表的元组会根据一些分区键划分为不相交的段。有多种方法可以决定如何分区（例如哈希、范围或谓词分区）。每种方法的有效性取决于查询。</p><p>我们将在本学期晚些时候讨论分布式数据库时介绍这些方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="并行执行 (Parallel Execution)" scheme="http://polaris3003.github.io/tags/%E5%B9%B6%E8%A1%8C%E6%89%A7%E8%A1%8C-Parallel-Execution/"/>
    
    <category term="查询内并行 (Intra-Query Parallelism)" scheme="http://polaris3003.github.io/tags/%E6%9F%A5%E8%AF%A2%E5%86%85%E5%B9%B6%E8%A1%8C-Intra-Query-Parallelism/"/>
    
    <category term="分布式数据库 (Distributed Databases)" scheme="http://polaris3003.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E6%95%B0%E6%8D%AE%E5%BA%93-Distributed-Databases/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture11</title>
    <link href="http://polaris3003.github.io/2024/11/28/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"/>
    <id>http://polaris3003.github.io/2024/11/28/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/</id>
    <published>2024-11-28T11:36:40.000Z</published>
    <updated>2025-02-11T09:24:24.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十一课连接算法">第十一课：连接算法</h1><h2 id="连接">1 连接</h2><p>良好的数据库设计的目标是尽量减少信息重复量。这就是为什么表格是基于规范化理论组成的。因此需要连接来重建原始表格。</p><p>本课程将介绍用于合并两个表的内部等值连接算法。等值连接算法连接键相等的表。这些算法可以调整以支持其他连接。</p><h3 id="运算符输出">运算符输出</h3><p>对于在连接属性上匹配的元组 r <span class="math inline">\(\in\)</span>R 和元组 s <span class="math inline">\(\in\)</span> S，连接运算符将 r 和s 连接在一起形成一个新的输出元组。</p><p>实际上，连接运算符生成的输出元组的内容各不相同。这取决于 DBMS的查询处理模型、存储模型和查询本身。连接运算符输出的内容有多种方法。</p><ul><li><strong>数据</strong>：这种方法将外表和内表中属性的值复制到仅针对该运算符的中间结果表中的元组中。这种方法的优点是查询计划中未来的操作符永远不需要返回基表来获取更多数据。缺点是这需要更多内存来实现整个元组。这称为实例化。DBMS还可以进行额外的计算并省略查询中以后不需要的属性以进一步优化这种方法。</li><li><strong>记录ID</strong>：在这种方法中，DBMS仅复制连接键以及匹配元组的记录 ID。这种方法非常适合列存储，因为 DBMS不会复制查询不需要的数据。这称为延迟实现。</li></ul><h3 id="成本分析">成本分析</h3><p>这里用于分析不同连接算法的成本指标是用于计算连接的磁盘 I/O数量。这包括从磁盘读取数据以及将任何中间数据写入磁盘所产生的 I/O。</p><p>请注意，只考虑计算连接时的 I/O，而不考虑输出结果时产生的I/O。这是因为输出成本取决于数据，而且任何连接算法的输出都是相同的，因此不同算法之间的成本不会改变。</p><blockquote><p>本课中使用的变量：</p><ul><li>R表（内表）中有M个页表，共m个元组</li><li>S表（外表）中有N个页表，共n个元组</li></ul></blockquote><p>一般来说，许多算法/优化可以在某些情况下降低连接成本，但没有一种算法可以在所有情况下都运行良好。</p><h2 id="嵌套循环连接">2 嵌套循环连接</h2><p>从高层次上讲，这种类型的连接算法由两个嵌套的 for循环组成，它们对两个表中的元组进行迭代，并逐对比较它们。如果元组与连接谓词匹配，则输出它们。外层for 循环中的表称为外表，内层 for 循环中的表称为内表。</p><p>DBMS总是希望使用“较小”的表作为外表。较小可以是元组数量或页面数量。DBMS还会希望在内存中缓冲尽可能多的外表。它还可以尝试利用索引在内表中查找匹配项。</p><h3 id="简单嵌套循环连接">简单嵌套循环连接</h3><p>对于外表中的每个元组，将其与内表中的每个元组进行比较。这是最糟糕的情况，DBMS必须对外表中的每个元组进行整个内表扫描，而没有任何缓存或访问局部性。</p><p><strong>复杂度</strong>：M + (m * N)</p><h3 id="块嵌套循环连接">块嵌套循环连接</h3><p>对于外表中的每个块，从内表获取每个块并比较这两个块中的所有元组。该算法执行的磁盘访问较少，因为DBMS 扫描内表以查找每个外表块，而不是每个元组。</p><p><strong>复杂度</strong>：M + (M * N)</p><p>如果 DBMS 有 B 个缓冲区可用于计算连接，则它可以使用 B − 2个缓冲区来扫描外表。它将使用一个缓冲区来扫描内表，另一个缓冲区来存储连接的输出。</p><p><strong>复杂度</strong>：M + (<span class="math inline">\(\lceil M /(B - 2) \rceil * N\)</span>)</p><h3 id="索引嵌套循环连接">索引嵌套循环连接</h3><p>以前的嵌套循环连接算法性能较差，因为 DBMS必须执行顺序扫描来检查内表中是否存在匹配项。但是，如果数据库已经为连接键上的其中一个表建立了索引，则可以使用该索引来加快比较速度。DBMS可以使用现有索引，也可以为连接操作建立临时索引。</p><p>外表是没有索引的表，内表是有索引的表。</p><p>假设每个索引探测的成本是每个元组的某个常数值 C。</p><p><strong>复杂度</strong>：M + (m * C)</p><h2 id="排序合并连接">3 排序合并连接</h2><p>从高层次上讲，排序合并连接根据连接键对两个表进行排序。DBMS可以使用外部合并排序算法来实现这一点。然后，它使用游标逐一遍历每个表并发出匹配项（就像合并排序一样）。</p><p>如果一个或两个表已经根据连接属性（例如使用聚集索引）排序，或者输出需要根据连接键排序，则此算法很有用。</p><p>该算法的最坏情况是两个表中所有元组的连接属性都包含相同的值，这在实际数据库中不太可能发生。在这种情况下，合并的成本将是M · N。不过，大多数情况下，密钥大多是唯一的，因此合并成本大约为 M +N。</p><p>假设 DBMS 有 B 个缓冲区可用于该算法：</p><ul><li>表R的排序成本：2M * (1 + <span class="math inline">\(\lceillog_{B-1}\lceil M/B \rceil \rceil\)</span>)</li><li>表S的排序成本：2N * (1 + <span class="math inline">\(\lceillog_{B-1}\lceil N/B \rceil \rceil\)</span>)</li><li>合并成本：（M + N）</li></ul><p>总成本：排序 + 合并</p><h2 id="哈希连接">4 哈希连接</h2><p>哈希连接算法的高级思想是使用哈希表根据元组的连接属性将其分成更小的块。这减少了DBMS计算连接时需要对每个元组执行的比较次数。哈希连接只能用于完整连接键上的等值连接。</p><p>如果元组 r <span class="math inline">\(\in\)</span> R 和元组 s <span class="math inline">\(\in\)</span> S满足连接条件，则它们对于连接属性具有相同的值。如果该值被哈希化为某个值i，则 R 元组必须在存储桶 r<sub>i</sub> 中，而 S 元组必须在存储桶s<sub>i</sub> 中。因此，存储桶 r<sub>i</sub> 中的 R 元组只需与存储桶s<sub>i</sub> 中的 S 元组进行比较。</p><h3 id="基本哈希连接">基本哈希连接</h3><ul><li>阶段1 – 构建：首先，扫描外部关系并使用连接属性上的哈希函数 h1填充哈希表。哈希表中的键是连接属性。值取决于实现（可以是完整元组值或元组ID）</li><li>阶段2 - 探测：扫描内部关系并在每个元组的连接属性上使用哈希函数 h1跳转到哈希表中的相应位置并找到匹配的元组。由于哈希表中可能存在冲突，DBMS将需要检查连接属性的原始值以确定元组是否真正匹配。</li></ul><p>如果 DBMS知道外表的大小，则连接可以使用静态哈希表。如果不知道大小，则连接必须使用动态哈希表或允许溢出页面。</p><p>一个有 N 页的表需要大约 <span class="math inline">\(\sqrt N\)</span>个缓冲区。上述方法在第 1 阶段创建了最多有 B 个块大小的 B − 1个溢出分区，因此假设哈希函数均匀分布记录，则可以使用此方法进行哈希处理的最大表是B · (B − 1)个缓冲区。如果哈希函数不是均匀的，则可以引入一个模糊因子f&gt;1，因此最大的此类表为<span class="math inline">\(B * \sqrt{f * N}\)</span>。</p><p>探测阶段的一个优化是使用布隆过滤器。这是一个概率数据结构，可以放入CPU 缓存中，并回答问题“密钥 x是否在哈希表中？”要么肯定否，要么很可能是。这可以通过阻止不会导致发出元组的磁盘读取来减少磁盘I/O 量。</p><h3 id="grace-hash-连接分区哈希连接">Grace Hash 连接/分区哈希连接</h3><p>当表无法放入主内存时，DBMS 必须随机地交换表，这会导致性能不佳。GraceHash Join 是基本哈希连接的扩展，它还将内表哈希化为写入磁盘的分区。</p><ul><li>阶段1 – 构建：首先，扫描外表和内表，并使用连接属性上的哈希函数 h1填充哈希表。哈希表的存储桶根据需要写入磁盘。如果内存中无法容纳单个存储桶，则DBMS 可以使用不同的哈希函数 h2（其中 h1 ̸=h2）进行递归分区，以进一步划分存储桶。此过程可以递归继续，直到内存中容纳所有存储桶为止。</li><li>阶段2 -探测：对于每个存储桶级别，检索外部表和内表的相应页面。然后，对这两个页面中的元组执行嵌套循环连接。页面可以装入内存，因此此连接操作会很快。</li></ul><p>分割阶段成本:2 * (M + N)</p><p>探测阶段成本：（M + N)</p><p>总成本：3 * （M + N）</p><p>混合哈希连接优化：在基本哈希连接和 Grace哈希连接之间进行调整；如果键有偏差，则将热分区保留在内存中并立即进行比较，而不是将其溢出到磁盘。很难正确实施。</p><h2 id="总结">5 总结</h2><p>连接是与关系数据库交互的重要部分，因此确保 DBMS具有有效的算法来执行连接至关重要。</p><p><img src="/2024/11/28/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/image-20241128211147350.png" alt="图一：上表假设以下情况：M = 1000，m = 100000，N = 500，n= 40000，B = 100 和每个 I/O 0.1 毫秒。"></p><p>哈希连接几乎总是比基于排序的连接算法更好，但在某些情况下基于排序的连接会更受欢迎。这包括查询非均匀数据、数据已按连接键排序以及结果需要排序的情况。好的DBMS 会使用其中一种或两种方法。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="查询优化" scheme="http://polaris3003.github.io/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    
    <category term="连接算法" scheme="http://polaris3003.github.io/tags/%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"/>
    
    <category term="嵌套循环连接" scheme="http://polaris3003.github.io/tags/%E5%B5%8C%E5%A5%97%E5%BE%AA%E7%8E%AF%E8%BF%9E%E6%8E%A5/"/>
    
    <category term="哈希连接" scheme="http://polaris3003.github.io/tags/%E5%93%88%E5%B8%8C%E8%BF%9E%E6%8E%A5/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture12</title>
    <link href="http://polaris3003.github.io/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/"/>
    <id>http://polaris3003.github.io/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/</id>
    <published>2024-11-21T11:36:40.000Z</published>
    <updated>2025-02-11T09:25:16.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十二课查询处理i">第十二课：查询处理I</h1><h2 id="查询计划">1 查询计划</h2><p>DBMS将一个SQL语句转换成一个查询计划。查询计划中的操作被整理成一个树。数据从这颗树的叶子流向树根。树的根节点的输出是查询的结果。通常情况下，运算符都是二进制的（1-2个子运算符）。同一个查询计划可以用多种方式执行。</p><h2 id="处理模型">2 处理模型</h2><p>DBMS处理模型定义了系统如何执行查询计划。它指定了诸如查询计划的评估方向以及沿途运算符之间传递的数据类型等内容。存在不同的处理模型，它们针对不同的工作负载有各种权衡。</p><p>这些模型也可以从上到下或从下到上调用操作符来实现。尽管自上而下的方法更为常见，但自下而上的方法可以更严格地控制管道中的缓存/寄存器。</p><p>我们考虑的三种执行模型是：</p><ul><li>迭代器模型</li><li>实例化模型</li><li>矢量化/批处理模型</li></ul><h3 id="迭代器模型">迭代器模型</h3><p>迭代器模型，也称为 Volcano 或 Pipeline模型，是最常见的处理模型，几乎每个（基于行）DBMS 都使用这种模型。</p><p>迭代器模型通过为数据库中的每个运算符实现一个 Next函数来工作。查询计划中的每个节点都会对其子节点调用Next，直到到达叶节点，叶节点开始向其父节点发出元组进行处理。然后，在检索下一个元组之前，尽可能按照计划处理每个元组。这在基于磁盘的系统中非常有用，因为它允许我们在访问下一个元组或页面之前充分利用内存中的每个元组。图1 显示了迭代器模型的示例图。</p><p>迭代器模型中的查询计划运算符具有高度可组合性，并且易于推理。因为每个运算符都可以独立于查询计划树中的父运算符或子运算符实现，只要它实现如下的Next 函数：</p><ul><li>每次调用 Next时，如果没有更多元组可发出，则运算符将返回单个元组或空标记。</li><li>该运算符实现一个循环，调用其子运算符上的 Next来检索它们的元组，然后处理它们。这样，对父节点调用 Next就会对其子节点调用Next。作为响应，子节点将返回父节点必须处理的下一个元组。</li></ul><p>迭代器模型允许流水线操作，其中 DBMS可以通过尽可能多的运算符处理一个元组，然后再检索下一个元组。查询计划中针对给定元组执行的一系列任务称为管道。</p><p>某些运算符会阻塞，直到子运算符发出所有元组。此类运算符的示例包括连接、子查询和排序(ORDER BY)。此类运算符称为管道断路器。</p><p>输出控制可以通过这种方法（LIMIT）轻松地工作，因为一旦操作员拥有了所需的所有元组，它就可以停止在其子操作员上调用Next。</p><p><img src="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241121204121679.png" alt="图一：迭代器模型示例 – 每个运算符的不同 Next 函数的伪代码。Next 函数本质上是 for 循环，迭代其子运算符的输出。例如，根节点在其子节点上调用 Next，即连接运算符，这是一种循环遍历关系 R 并向上发出元组然后进行操作的访问方法。处理完所有元组后，将发送一个空指针（或另一个指示符），让父节点知道继续前进。"></p><h3 id="实例化模型">实例化模型</h3><p>实例化模型是迭代器模型的一种特殊化，其中每个运算符一次处理其输入，然后一次发出其输出。每个运算符每次到达时都会返回其所有元组，而不是使用返回单个元组的下一个函数。为了避免扫描太多元组，DBMS可以将需要多少元组的信息传播给后续操作符（例如LIMIT）。运算符将其输出“实例化”为单个结果。输出可以是整个元组 (NSM)或列的子集 (DSM)。图 2 显示了实例化模型的示意图。</p><p>每个查询计划运算符都实现一个Output函数：</p><ul><li>操作立即处理子节点传来的所有元组</li><li>此函数的返回结果是该运算符将发出的所有元组。当该运算符完成执行时，DBMS无需返回该函数来检索更多数据。</li></ul><p>这种方法更适合OLTP工作负载，因为查询通常一次只访问少量元组。因此，检索元组的函数调用较少。实例化模型不适合具有大量中间结果的OLAP 查询，因为 DBMS 可能必须在操作员之间将这些结果溢出到磁盘。</p><p><img src="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241121210346219.png" alt="图二：实例化模型示例 - 从根开始，调用 child.Output() 函数，该函数调用下面的运算符，返回所有元组。"></p><h3 id="矢量化模型">矢量化模型</h3><p>与迭代器模型一样，矢量化模型中的每个运算符都实现一个 Next函数。但是，每个运算符都会发出一批数据（即向量），而不是单个元组。运算符的内循环实现针对处理批量数据（而不是一次处理单个数据）进行了优化。批次的大小可能因硬件或查询属性而异。请参阅图3 中的矢量化模型示例。</p><p>矢量化模型方法非常适合需要扫描大量元组的 OLAP 查询，因为 Next函数的调用次数较少。</p><p>矢量化模型使得操作能够更轻松地使用矢量化（SIMD）指令来处理批量元组。</p><p><img src="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241123234749040.png" alt="图三：矢量化模型样例-矢量化模型与迭代器模型非常相似，不同之处在于，每个操作符都会将输出缓冲区与所需的发射大小进行比较。如果缓冲区较大，则发送元组批次。"></p><h3 id="操作方向">操作方向</h3><ul><li>方式一：自顶向下<ul><li>从根开始，将数据从子节点“拉”到父节点</li><li>元组总是通过函数调用传输</li></ul></li><li>方式二：自底向上<ul><li>从叶节点开始，将数据从子节点“推送”到父节点</li><li>允许更严格地控制操作管道中的缓存/寄存器</li></ul></li></ul><h2 id="访问方法">3 访问方法</h2><p>访问方法是 DBMS访问表中存储的数据的方式。一般来说，访问模型有两种方法：要么从表中读取数据，要么通过顺序扫描从索引中读取数据。</p><h3 id="顺序扫描">顺序扫描</h3><p>顺序扫描运算符遍历表中的每个页面并从缓冲池中检索它。当扫描遍历每个页面上的所有元组时，它会评估谓词以决定是否将元组发送给下一个运算符。</p><p>DBMS 维护一个内部游标，用于跟踪其检查的最后一页/槽。</p><p>顺序表扫描几乎始终是 DBMS执行查询时效率最低的方法。有许多优化方法可帮助加快顺序扫描速度：</p><ul><li><strong>预读取</strong>：提前获取接下来的几页，以便 DBMS在访问每个页面时不必阻塞存储 I/O。</li><li><strong>缓存池绕过</strong>：扫描操作符将从磁盘获取的页面存储在其本地内存中而不是缓冲池中，以避免顺序洪泛。</li><li><strong>并行化</strong>：使用多个线程/进程并行执行扫描。</li><li><strong>慢实例化</strong>：DBMS可以将元组的拼接延迟到查询计划的上部。这样每个操作符都可以将所需的最少信息传递给下一个操作符（例如记录ID、列中记录的偏移量）。这仅在列存储系统中有用。</li><li><strong>堆聚类</strong>：元组按照聚类索引指定的顺序存储在堆页中。</li><li><strong>近似查询（跳过有损数据）</strong>：对整个表的抽样子集执行查询以产生近似结果。这通常用于在允许低误差产生近乎准确的答案的场景中计算聚合。</li><li><strong>区域图（无损数据跳过）</strong>：预先计算页面中每个元组属性的聚合。然后，DBMS可以通过首先检查区域图来决定是否需要访问页面。每个页面的区域图存储在单独的页面中，并且每个区域图页面中通常有多个条目。因此，可以减少连续扫描中检查的总页面数。区域图在云数据库系统中尤其有价值，因为通过网络传输数据会产生更大的成本。参见图4 的区域地图示例。</li></ul><p><img src="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241127205536313.png" alt="图四：区域图样例 – 区域图存储页面中值的预先计算的聚合。在上面的示例中，选择查询从区域图中得知，原始数据中的最大值只有 400.然后，查询就不必遍历页面中的每个元组，而是可以完全避免访问该页面，因为没有任何值大于 600。"></p><h3 id="索引扫描">索引扫描</h3><p>在索引扫描中，DBMS 选择一个索引来查找查询所需的元组。</p><p><img src="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241127210523298.png" alt="图五：索引扫描样例 – 考虑一个包含 100 个元组和两个索引（年龄和部门）的单表。在第一种情况下，最好在扫描中使用部门索引，因为它只有两个元组需要匹配。选择 age 索引并不会比简单的顺序扫描好多少。在第二种情况下，age 索引会消除更多不必要的扫描，是最佳选择。"></p><p>DBMS 的索引选择过程涉及许多因素，包括：</p><ul><li>索引包含哪些属性</li><li>查询引用了哪些属性</li><li>属性的值域</li><li>谓词组合</li><li>索引是否具有唯一键或非唯一键</li></ul><p>图 5 显示了索引扫描的一个简单示例。</p><p>更高级的 DBMS 支持多索引扫描。当对查询使用多个索引时，DBMS会使用每个匹配的索引计算记录 ID集，根据查询的谓词组合这些集合，然后检索记录并应用可能保留的任何谓词。DBMS可以使用位图、哈希表或布隆过滤器通过集合交集计算记录 ID。请参阅图 6中利用多索引扫描的示例。</p><p><img src="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241128155039980.png" alt="图六：多索引扫描示例 – 考虑图 5 中的同一张表。借助多索引扫描支持，我们首先使用相应的索引分别计算满足年龄和部门谓词的记录 ID 集。然后，我们计算两个集合的交集，获取相应的记录，并应用剩余的谓词 country=’US’。"></p><h2 id="修改查询">4 修改查询</h2><p>修改数据库（INSERT、UPDATE、DELETE）的操作员负责检查约束和更新索引。对于UPDATE/DELETE，子操作符传递目标元组的记录ID，并且必须跟踪先前看到的元组。</p><p>关于如何处理 INSERT 运算符有两种实现选择：</p><ul><li>选择1：在运算符内部实现元组。</li><li>选择2：运算符插入从子运算符传入的任何元组。</li></ul><h3 id="万圣节问题">万圣节问题</h3><p>万圣节问题是一种异常现象，其中更新操作会更改元组的物理位置，从而导致扫描运算符多次访问该元组。这可能发生在聚簇表或索引扫描上。</p><p>这一现象最初是由 IBM 研究人员在 1976 年万圣节当天构建 System R时发现的。解决此问题的方法是跟踪每个查询的修改记录 ID。</p><h2 id="表达式求值">5 表达式求值</h2><p>DBMS 将 WHERE 子句表示为表达式树（参见图 7中的示例）。树中的节点表示不同的表达式类型。</p><p><img src="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241128160655862.png" alt="图 7：表达式求值示例 – WHERE 子句及其对应表达式的图表。"></p><p>可以存储在树节点中的表达式类型的一些示例：</p><ul><li>比较（=、&lt;、&gt;、!=）</li><li>连接 (AND)、分离 (OR)</li><li>算术运算符（+、-、*、/、%）</li><li>常量和参数值</li><li>元组属性引用</li></ul><p>为了在运行时评估表达式树，DBMS维护一个上下文句柄，其中包含执行的元数据，例如当前元组、参数和表架构。然后，DBMS遍历树来评估其运算符并产生结果。</p><p>以这种方式评估谓词很慢，因为 DBMS必须遍历整个树并确定每个运算符要采取的正确操作。更好的方法是直接评估表达式（想想JIT 编译）。基于内部成本模型，DBMS将确定是否采用代码生成来加速查询。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="查询优化" scheme="http://polaris3003.github.io/tags/%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    
    <category term="查询处理" scheme="http://polaris3003.github.io/tags/%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86/"/>
    
    <category term="执行模型" scheme="http://polaris3003.github.io/tags/%E6%89%A7%E8%A1%8C%E6%A8%A1%E5%9E%8B/"/>
    
    <category term="迭代器模型" scheme="http://polaris3003.github.io/tags/%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture10</title>
    <link href="http://polaris3003.github.io/2024/11/19/%E7%AC%AC%E5%8D%81%E8%AF%BE%EF%BC%9A%E6%8E%92%E5%BA%8F%E5%92%8C%E8%81%9A%E5%90%88%E7%AE%97%E6%B3%95/"/>
    <id>http://polaris3003.github.io/2024/11/19/%E7%AC%AC%E5%8D%81%E8%AF%BE%EF%BC%9A%E6%8E%92%E5%BA%8F%E5%92%8C%E8%81%9A%E5%90%88%E7%AE%97%E6%B3%95/</id>
    <published>2024-11-19T11:21:40.000Z</published>
    <updated>2025-02-11T09:25:18.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十课排序和聚合算法">第十课：排序和聚合算法</h1><h2 id="排序">1 排序</h2><p>DBMS需要对数据进行排序，因为表中的元组在关系模型下没有特定的顺序。排序（可能）用于ORDER BY、GROUP BY、JOIN 和 DISTINCT运算符。如果需要排序的数据适合内存，那么 DBMS可以使用标准排序算法（例如，快速排序）。如果数据不适合，那么 DBMS需要使用外部排序，该排序可以根据需要溢出到磁盘，并且优先选择顺序 I/O而不是随机 I/O。</p><p>如果查询包含带有 LIMIT 的 ORDER BY，则 DBMS只需扫描数据一次即可找到前 N 个元素。这称为 Top-N堆排序。堆排序的理想情况是前 N 个元素适合内存，这样 DBMS在扫描数据时只需维护内存中的排序优先级队列。对于内存中容纳不了的庞大数据进行排序的标准算法是外部合并排序。它是一种分而治之的排序算法，将数据集拆分为单独的运行，然后单独对它们进行排序。它可以根据需要将运行溢出到磁盘，然后一次读回一个。该算法由两个阶段组成：</p><ol type="1"><li>排序：首先，该算法对适合主内存的小块数据进行排序，然后将排序后的页面写回磁盘。</li><li>合并：然后，该算法将排序后的子文件组合成一个更大的文件。</li></ol><h3 id="双向归并排序">双向归并排序</h3><p>该算法最基本的版本是双向合并排序。该算法在排序阶段读取每个页面，对其进行排序，然后将排序后的版本写回磁盘。然后，在合并阶段，它使用三个缓冲页。它从磁盘读取两个已排序的页面，并将它们合并到第三个缓冲页中。它从磁盘读取两个已排序的页面，并将它们合并到第三个缓冲页面中。每当第三个页面填满时，它就会被写回磁盘并替换为空白页。每组排序好的页面称为一个运行。然后，算法会以递归方式将这些运行合并在一起。</p><p>如果 N 是数据页的总数，则该算法将总共遍历数据 1 +⌈logN⌉次（第一步排序为 1，然后递归合并为 ⌈logN⌉ 次）。总 I/O 成本为 2N×（传递次数），因为每次传递对每个页面执行一次 I/O 读取和一次 I/O写入。</p><h3 id="通用k路归并排序">通用（K路）归并排序</h3><p>该算法的通用版本允许 DBMS 使用三个以上的缓冲页。设 B为可用的缓冲页总数。然后，在排序阶段，算法可以一次读取 B 页，并将 ⌈N/B⌉个已排序的运行写回到磁盘。合并阶段还可以在每次传递中组合最多 B - 1次运行，再次使用一个缓冲页面来存储组合数据并根据需要写回磁盘。在广义版本中，该算法执行⌈1 + log<sub>B-1</sub> ⌈N/B⌉⌉次传递（一次用于排序阶段，log<sub>B-1</sub>⌈N/B⌉次用于合并阶段）。然后，总 I/O 成本为 2N×（传递次数），因为它必须在每次传递中对每个页面进行读取和写入。</p><h3 id="双缓冲优化">双缓冲优化</h3><p>外部合并排序的一个优化是在系统处理当前运行的同时，在后台预取下一次运行并将其存储在第二个缓冲区中。通过持续利用磁盘，这可以减少每一步I/O请求的等待时间。此优化需要使用多个线程，因为预取应该在当前运行的计算过程中进行。</p><h3 id="使用b树">使用B+树</h3><p>对于 DBMS 来说，使用现有的 B+树索引来辅助排序有时比使用外部合并排序算法更有优势。具体来说，如果索引是聚集索引，则DBMS 只需遍历 B+树即可。由于索引是聚集的，因此数据将以正确的顺序存储，因此 I/O访问将是连续的。这意味着它总是比外部合并排序更好，因为不需要计算。另一方面，如果索引是非聚集的，则遍历树几乎总是更糟糕，因为每个记录可以存储在任何页面中，因此几乎所有记录访问都需要读取磁盘。</p><h2 id="聚合">2 聚合</h2><p>查询计划中的聚合运算符将一个或多个元组的值折叠为单个标量值。有两种方法可以实现聚合：(1)排序和 (2) 哈希。</p><h3 id="排序-1">排序</h3><p>DBMS 首先根据 GROUP BY键对元组进行排序。如果缓冲池中所有内容都适合，则可以使用内存排序算法（例如快速排序），如果数据大小超出内存，则使用外部合并排序算法。然后，DBMS对排序后的数据执行顺序扫描以计算聚合。运算符的输出将按键排序。</p><p>执行排序聚合时，对查询操作进行排序以最大限度提高效率非常重要。例如，如果查询需要过滤，则最好先执行过滤，然后对过滤后的数据进行排序，以减少需要排序的数据量。</p><h3 id="哈希">哈希</h3><p>对于计算聚合而言，散列比排序更节省计算成本。DBMS在扫描表时会填充临时哈希表。对于每条记录，检查哈希表中是否已经存在条目，并执行适当的修改。如果哈希表的大小太大而无法放入内存中，则DBMS 必须将其溢出到磁盘。实现此操作分为两个阶段：</p><ul><li>分区：使用哈希函数 h1根据目标哈希键将元组拆分为磁盘上的分区。这会将所有匹配的元组放入同一个分区。DBMS通过输出缓冲区将分区溢出到磁盘。</li><li>再哈希：对于磁盘上的每个分区，将其页面读入内存，并基于第二个哈希函数h2（其中 h1 ！=h2）构建内存哈希表。然后遍历该哈希表的每个存储桶，将匹配的元组汇集在一起以计算聚合。这假设每个分区都适合内存。</li></ul><p>在 ReHash 阶段，DBMS 可以存储形式 (GroupByKey→RunningValue)的对来计算聚合。RunningValue的内容取决于聚合函数。要将新元组插入哈希表：</p><ul><li>如果找到匹配的 GroupByKey，则适当更新 RunningValue。</li><li>否则插入一个新的 (GroupByKey→RunningValue) 对。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="DBMS" scheme="http://polaris3003.github.io/tags/DBMS/"/>
    
    <category term="元组聚合" scheme="http://polaris3003.github.io/tags/%E5%85%83%E7%BB%84%E8%81%9A%E5%90%88/"/>
    
    <category term="元组排序算法" scheme="http://polaris3003.github.io/tags/%E5%85%83%E7%BB%84%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LSM-Tree</title>
    <link href="http://polaris3003.github.io/2024/11/19/The%20Log-Structured%20Merge-Tree(LSM-Tree)/"/>
    <id>http://polaris3003.github.io/2024/11/19/The%20Log-Structured%20Merge-Tree(LSM-Tree)/</id>
    <published>2024-11-19T10:57:39.000Z</published>
    <updated>2025-02-11T09:26:28.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="section"></h1><h1 id="the-log-structured-merge-treelsm-tree">The Log-StructuredMerge-Tree(LSM-Tree)</h1><h2 id="摘要">摘要</h2><p>高性能事务系统应用程序通常会在历史记录表中插入行，以提供活动跟踪，同时这个事务系统会产生日志记录用作系统恢复。两种类型的生成信息都可以从高效索引中受益。一个众所周知的例子是TPC-A基准应用程序，它经过修改以支持对特定帐户的帐户活动历史记录进行有效查询。这需要在快速增长的历史记录表上按帐户ID 建立索引。遗憾的是，标准的基于磁盘的索引结构（例如 B树）将有效地使实时维护此类索引的事务 I/O成本加倍，从而使总系统成本增加高达百分之五十。显然，需要一种以低成本维护实时索引的方法。日志结构合并树(LSM 树)是一种基于磁盘的数据结构，旨在为长期经历高记录插入（和删除）率的文件提供低成本索引。LSM树使用一种延迟和批量处理索引更改的算法，以一种类似于合并排序的有效方式将更改从基于内存的组件级联到一个或多个磁盘组件。在此过程中，所有索引值都可以通过内存组件或磁盘组件之一持续检索（除了非常短暂的锁定期）。该算法与传统的访问方法（如B树）相比，极大地减少了磁盘臂的运动次数，并将提高在那些传统访问方法中磁盘臂成本对于插入操作超过存储介质成本的领域中的性价比。LSM树方法还可以推广到插入和删除以外的操作。但是，需要立即响应的索引查找在某些情况下会损失I/O 效率，因此 LSM树在索引插入比检索条目的查找更常见的应用程序中最为有用。例如，这似乎是历史表和日志文件的共同属性。第6 节的结论将 LSM树访问方法中内存和磁盘组件的混合使用与人们通常理解的在内存中缓冲磁盘页面的混合方法的优势进行了比较。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="misc" scheme="http://polaris3003.github.io/categories/misc/"/>
    
    
    <category term="存储结构" scheme="http://polaris3003.github.io/tags/%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/"/>
    
    <category term="数据库" scheme="http://polaris3003.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Paxos Made Simple</title>
    <link href="http://polaris3003.github.io/2024/10/09/Paxos%20Made%20Simple/"/>
    <id>http://polaris3003.github.io/2024/10/09/Paxos%20Made%20Simple/</id>
    <published>2024-10-09T11:50:17.000Z</published>
    <updated>2025-02-11T09:25:58.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="paxos-made-simple">Paxos Made Simple</h1><center><h2>摘要</h2></center><center><font color="IndianRed">Paxos 算法用简单的英语表达时非常简单。</font></center><h2 id="简介">1 简介</h2><p>用于实现容错分布式系统的 Paxos算法一直被认为难以理解，可能是因为许多读者最初看的是希腊语。事实上，它是最简单、最明显的分布式算法之一。其核心是共识算法——“synod”算法。下一节将展示这种共识算法几乎不可避免地遵循我们希望它满足的属性。最后一部分将解释完整的Paxos算法。这个算法是通过将共识算法直接应用到构建分布式系统的有限状态机方法中得到的。这种方法应该是众所周知的，因为它是分布式系统理论中被引用次数最多的文章的主题。</p><h2 id="共识算法">2 共识算法</h2><h3 id="问题">2.1 问题</h3><p>假设可以提出价值的进程集合。共识算法确保选择提出值中的一个。如果没有提出任何值，则不应选择任何值。如果已经选择了一个值，那么进程应该能够学习所选的值。共识的安全要求是：</p><ul><li>只能选出已提议的值</li><li>只有一个值能被选出</li><li>进程永远不会知道某个值已被选出，除非它确实已被选出。</li></ul><p>我们不会尝试指定精确的存活要求。但是，目标是确保最终选择某个建议值，并且如果选择了某个值，则进程最终可以学习该值。</p><p>我们让共识算法中的三个角色由三类代理来执行：proposer、acceptor和learner。在一种实现中，单个进程可以充当多个代理，但这里我们不关心从代理到进程的映射。</p><p>假设代理能通过发送消息来相互通信。我们使用惯用的异步、非拜占庭模型，其中</p><ul><li>代理以任意速度运行，可能因停止而失败，也可能重新启动。由于在选择一个值然后重新启动后所有代理都可能会失败，因此除非已失败并重新启动的代理可以记住某些信息，否则解决方案是不可能的。</li><li>消息的传送时间可以任意长，可以重复，也可以丢失，但它们不会被破坏。</li></ul><h3 id="选择值">2.2 选择值</h3><p>选择值的最简单方法是使用单个接受代理。提议者向接受者发送提议，接受者选择收到的第一个提议值。虽然简单，但这个解决方案并不令人满意，因为接受者的失败使得任何进一步的进展都不可能。</p><p>因此，让我们尝试另一种选择值的方法。让我们使用多个接受者代理，而不是单个接受者。提议者将提议值发送给一组接受者。接受者可以接受提议的值。当足够多的接受者接受该值时，就会选择该值。多大才算足够够？为了确保只选择一个值，我们可以让一个足够大的集合由任意大多数代理组成。因为任何两个多数都至少有一个共同的接受者，所以如果接受者最多可以接受一个值，那么这种方法就有效。（在许多论文中都观察到了大多数的明显概括，显然是从LeslieLampor开始的）</p><p>在没有失败或消息丢失的情况下，即使单个提议者只提出一个值，我们也希望选择一个值。这表明了要求：</p><blockquote><p><font color="purple">P1 接受者必须接受它收到的第一个提案</font></p></blockquote><p>但这个要求带来了一个问题。不同的提议者可能会在同一时间提出多个值，从而导致每个接受者都接受了一个值，但没有一个值被大多数接受者接受的情况。即使只有两个提议的值，如果每个值都被大约一半的接受者接受，那么单个接受者的失败可能会导致无法了解选择了哪个值。</p><p>P1以及仅当大多数接受者接受时才选择某个值的要求意味着必须允许接受者接受多个提案。我们通过为每个提案分配一个（自然）编号来跟踪接受者可能接受的不同提案，因此提案由提案编号和值组成。为了防止混淆，我们要求不同的提案有不同的编号。如何实现取决于其实现，至今为止我们只是假设。当具有该值的单个提案被大多数接受者接受时，就会选择一个值。在这种情况下，我们说该提案（及其价值）已被选择。</p><p>我们可以允许选择多个提案，但我们必须保证所有选择的提案具有相同的值。通过对提案编号进行归纳，足以保证：</p><blockquote><p><font color="purple">P2<sup>a</sup> 如果选择了值为 v的提案，则选择的每个编号较高的提案都具有值 v。</font></p></blockquote><p>我们仍然维护 P1以确保选择某些提案。由于通信是异步的，因此可以选择某个从未收到过任何提案的特定接受者的提案。假设一个新的提议者“启动”并发布了一个具有不同值的更高编号的提议。P1要求 c 接受该提案，违反了 P2<sup>a</sup> 。维持 P1 和 P2<sup>a</sup>需要加强 P2<sup>a</sup> 以：</p><blockquote><p><font color="purple">P2<sup>b</sup> 如果选择了值为 v的提案，则任何提案者发布的每个编号较高的提案都具有值 v。</font></p></blockquote><p>由于提案必须由提案者发出才能被接受者接受，因此 P2<sup>b</sup> 意味着P2<sup>a</sup> ，而 P2<sup>a</sup> 又意味着 P2 。</p><p>为了发现如何满足P2<sup>b</sup>，让我们考虑如何证明它成立。我们假设选择了一些编号为 m且值为 v 的提案，并表明任何编号为 n &gt; m 的提案也具有值v。为了使证明过程更简单，我们通过在 n上使用归纳法来进行，这样我们就可以证明在额外假设下，编号为 n的提案具有值 v，即假设在 m 到 n-1 之间的每个编号的提案都具有值 v，其中 i: :j 表示从 i 到 j 的一系列数字集合。对于要选择的编号为 m的提案，必须存在某个由大多数接受者组成的集合 C，使得 C中的每个接受者都接受它。将此与归纳假设相结合，选择 m 的假设意味着：</p><blockquote><p><font color="purple">C 中的每个接受者都接受了编号为 m ~ (n - 1)的提案，并且任何接受者接受的编号为 m ~ (n - 1) 的提案的值含有v。</font></p></blockquote><p>由于任何由大多数接受者组成的集合 S 至少包含 C的一个成员，因此我们可以通过确保维持以下不变量来得出结论，编号为 n的提案具有值 v：</p><blockquote><p><span style="color: purple;"> P2<sup>c</sup>对于任意的值v和编号n，如果发出了一个带有值v和编号n的提案，那么存在一个由大多数接受者组成的集合S，满足以下条件之一：<br>a. 集合S中的任何接受者都没有接受过编号小于n的任何提案。<br> b.值v是集合S中的接受者所接受的所有编号小于n的提案中编号最高的那个提案的值。</span></p></blockquote><p>因此，我们可以通过保持 P2<sup>c</sup> 的不变性来满足 P2<sup>b</sup>。</p><p>为了保持 P2<sup>c</sup> 的不变性，想要发布编号为 n的提案的提案者必须学习编号小于 n的最高编号提案（如果有的话），该提案已经或将被每个接受者以某种多数接受。了解已经被接受的提案很容易；预测未来的接受情况却很难。提议者并不试图预测未来，而是通过做出不会发生此类接受的承诺来控制未来。换句话说，提议者要求接受者不再接受任何编号小于n 的提案。这导致了以下发布提案的算法：</p><ol type="1"><li><p>提议者选择一个新的提议编号n，并向某个接受者集合中的每个成员发送请求，要求其做出以下回应：</p><ol type="1"><li>承诺不再接受编号小于 n 的提案，并且</li><li>已接受的小于 n 的最大数字的提案（如果有）。</li></ol><p>我将这样的请求称为编号为 n 的准备请求。</p></li><li><p>如果提议者从大多数接受者那里收到了请求的响应，那么它可以发出一个编号为n、值为v的提案，其中v是响应中编号最高的提案的值，或者如果响应者没有报告任何提案，v可以是提议者选择的任何值。</p></li></ol><p>提议者通过向一组接受者发送接受提议的请求来发布提议。（这不需要是响应初始请求的同一组接受器）我们将其称为接受请求。</p><p>这描述了提议者的算法。那么接受者呢？它可以接收来自提议者的两种请求：准备请求和接受请求。接受器可以忽略任何请求而不会影响安全性。因此，我们只需要说明何时允许它响应请求。它总是可以响应准备请求。它可以响应接受请求，接受提议，前提是它没有承诺不这样做。换句话说：</p><blockquote><p><font color="purple">P1<sup>a</sup>如果接受者没有响应过编号大于n的准备请求，那么它可以接受一个编号为n的提案。</font></p></blockquote><p>观察到 P1<sup>a</sup> 包含 P1。</p><p>我们现在有一个完整的算法来选择一个满足所需安全属性的值——假设唯一的提案编号。通过一次小优化得到了最终的算法。</p><p>假设一个接受者收到一个编号为 n的准备请求，但是它已经响应了一个编号大于 n的准备请求，从而承诺不接受任何新的编号为 n的提议。那么接受者就没有理由响应新的准备请求，因为它不会接受提议者想要发布的编号为n的提案。因此，我们让接受者忽略此类准备请求。我们还让接受者忽略已接受提案的准备请求。</p><p>通过这种优化，接受者只需要记住它曾经接受过的编号最高的提案，以及它响应过的编号最高的准备请求的编号。因为P2<sup>c</sup>无论发生什么故障都必须保持不变，所以即使接受器发生故障然后重新启动，它也必须记住此信息。请注意，提议者可以随时放弃一项提议并忘记它——只要它永远不会尝试发布具有相同编号的另一个提议。</p><p>将提议者和接受者的行为放在一起，我们看到该算法分为以下两个阶段运行。</p><p><strong>阶段一：</strong></p><p>（a）提议者选择一个提案编号 n，并向大多数接受者发送编号为 n的准备请求</p><p>（b）如果接受者收到一个准备请求，其编号 n大于它已经响应的任何准备请求的编号，然后它承诺不再接受任何编号小于 n的提案，并接受已接受的编号最高的提案（如果有）。</p><p><strong>阶段二：</strong></p><p>（a）如果提议者收到大多数接受者对其准备请求（编号为n）的回应，然后它向每个接受者发送接受请求，以获得编号为 n 且值为 v的提案，其中 v是响应中编号最高的提案的值，如果响应未报告任何提案，则为任何值。</p><p>（b）如果接受者收到针对编号为 n的提案的接受请求，则会接受该提案，除非它已经响应了编号大于 n的准备请求。</p><p>提议者可以提出多个提议，只要它遵循每个提议的算法即可。它可以在协议执行过程中随时放弃提议。（即使该提案的请求和/或响应可能在该提案被放弃很久之后才到达目的地，正确性仍然得到保持）。如果某个提议者开始尝试发布编号更高的提议，那么放弃该提议可能是个好主意。因此，如果接受者因为已经收到具有更高编号的准备请求而忽略了准备或接受请求，那么它可能应该通知提议者，然后提议者应该放弃其提议。这是一个性能优化，不会影响正确性。</p><h3 id="学习所选值">2.3 学习所选值</h3><p>要了解某个值已被选定，学习者必须发现该提议已被大多数接受者接受。显而易见的算法是让每个接受者在接受提案时响应所有学习者并向他们发送提案。这使得学习者能够尽快找到所选的值，但要求每个接受者对每个学习者做出响应——响应数量等于接受者数量与学习者数量的乘积。</p><p>非拜占庭故障的假设使得一个学习者很容易从另一个学习者那里发现一个值已被接受。我们可以让接受者向杰出的学习者做出接受的回应，当某个值被选中时，该学习者又会通知其他学习者。这种方法需要所有学习者额外进行一轮来发现所选的值。它的可靠性也较低，因为杰出的学习者可能会失败。但它要求的响应数量仅等于接受者数量和学习者数量的总和。</p><p>更一般地，接受者可以对一些杰出的学习者做出接受的回应，每个学习者都可以在选择值时通知所有学习者。使用更大的区分集的学习者以更大的沟通复杂性为代价提供更高的可靠性。</p><p>由于消息丢失，可能存在一个值被选定了，但没有任何一个学习者能够得知。学习者可以询问接受者他们接受了哪些提议，但是接受者的失败可能导致无法知道大多数人是否接受了杰出的提议。在这种情况下，只有当一个新的提案被选中时，学习者才会发现选择了什么值。如果学习者需要知道某个值是否已被选中，它可以让提议者使用上面描述的算法提出一个提议。</p><h3 id="过程">2.4 过程</h3><p>很容易构建这样一种场景，其中两个提议者各自不断发布一系列编号不断增加的提议，但没有一个被选中。提议者p 完成提案编号为 n1 的第 1 阶段。然后，另一个提议者 q 完成提案编号为 n2&gt; n1 的第 1 阶段。提议者 p 对编号为 n1 的提案的第 2阶段接受请求被忽略，因为接受者都承诺不接受任何编号小于 n2的新提案。因此，提议者 p 开始并完成阶段 1，新提议编号为 n3 &gt;n2，导致提议者 q 的第二个阶段 2 接受请求被忽略。依此类推。</p><p>为了保证进展，必须选择一位杰出的提议者作为唯一尝试发布提案的人。如果杰出的提议者能够与大多数接受者成功沟通，并且它使用的提议的数量大于任何已经使用的提议，那么它将成功发布被接受的提议。如果发现某个请求的提案编号更高，则通过放弃提案并重试，杰出的提案者最终将选择一个足够高的提案编号。</p><p>如果系统（提议者、接受者和通信网络）的大部分正常运行，那么就可以通过选举一位杰出的提议者来实现活跃性。菲舍尔（Fischer）、林奇（Lynch）和帕特森（Paterson）的著名成果意味着，选举提议者的可靠算法必须使用随机性或实时性——例如，使用超时。但无论选举成功或失败，安全都是有保障的。</p><h3 id="实现">2.5 实现</h3><p>Paxos算法假设一个进程网络。在其共识算法中，每个进程都扮演提议者、接受者和学习者的角色。算法选择一个领导者，该领导者扮演着杰出提议者和杰出学习者的角色。Paxos共识算法正是上面描述的算法，其中请求和响应都作为普通消息发送。（响应消息标有相应的提案编号以避免混淆。）稳定存储用于在故障期间保存，用于维护接受器必须记住的信息。接受器在实际发送响应之前将其预期响应记录在稳定存储中。</p><p>剩下的就是描述保证不会发布两个具有相同编号的提案的机制。不同的提议者从不相交的数字集中选择他们的数字，因此两个不同的提议者永远不会提出具有相同数字的提案。每个提议者都会记住（在稳定存储中）它尝试发布的最高编号的提议，并以比它已经使用过的任何提议编号更高的提议编号开始第1 阶段。</p><h2 id="实现状态机">3 实现状态机</h2><p>实现分布式系统的一个简单方法是作为向中央服务器发出命令的客户端集合。服务器可以被描述为一个按照某种顺序执行客户端命令的确定性状态机。状态机具有当前状态；它通过将命令作为输入并产生输出和新状态来执行步骤。例如，分布式银行系统的客户可能是出纳员，状态机状态可能由所有用户的账户余额组成。提款是通过执行状态机命令来执行的，当且仅当账户余额大于提款金额时，该命令才会减少账户余额，并输出新旧余额。</p><p>如果使用单个中央服务器的实现在该服务器发生故障时也会失败。因此，我们使用一组服务器，每个服务器都独立实现状态机。因为状态机是确定性的，所以如果所有服务器都执行相同的命令序列，那么所有服务器将产生相同的状态和输出序列。发出命令的客户端可以使用任何服务器为其生成的输出。</p><p>为了保证所有服务器执行相同的状态机命令序列，我们实现了 Paxos共识算法的独立实例序列，第 i 个实例选择的值是序列中的第 i个状态机命令。每个服务器在算法的每个实例中扮演所有角色（提议者、接受者和学习者）。目前，我假设服务器集是固定的，因此共识算法的所有实例都使用相同的代理集合。</p><p>在正常操作中，会选举出一个单独的服务器作为领导者，这个领导者在共识算法的所有实例中充当杰出的提议者（唯一尝试发出提议的一方）。客户端将命令发送给领导者，领导者决定每个命令在序列中的出现位置。如果领导者决定某个客户端命令应该是第135 个命令，它会尝试选择该命令作为共识算法的第 135个实例的值。这通常会成功，它可能因为宕机而失败，或者因为另一个服务器也认为自己是领导者，并且对第135个命令应该是什么有不同的看法。但是共识算法确保最多可以选择一个命令作为第135 个命令。</p><p>这种方法效率的关键在于，在 Paxos 共识算法中，要提议的值直到第 2阶段才会被选择。回想一下，在完成提议者算法的第 1阶段后，要么确定要提议的值，要么提议者可以自由提议任何值。</p><p>现在，我将介绍 Paxos状态机实现在正常操作期间的工作原理。稍后，我将讨论可能出错的内容。我会考虑当前任领导者刚刚失败并且选择了新的领导者时会发生什么。（系统启动是一种特殊情况，尚未提出任何命令）。</p><p>新领导者是共识算法的所有实例的学习者，应该知道已经选择的大多数命令。假设它知道命令1-134、138 和 139，即共识算法的实例 1-134、138 和 139中选择的值。（我们稍后将看到命令序列中的这种差距是如何出现的。然后，它执行实例135-137 的阶段 1 以及所有大于 139的实例。（我将在下面描述如何做到这一点。假设这些执行的结果确定了要在实例135 和 140中建议的值，但在所有其他实例中使建议的值不受约束。然后，领导者对实例 135和 140 执行阶段 2，从而选择命令 135 和 140。</p><p>领导服务器以及学习领导服务器知道的所有命令的任何其他服务器现在可以执行命令1-135。但是，它无法执行命令 138–140，它也知道这一点，因为尚未选择命令136 和 137。领导者可以将客户端请求的接下来的两个命令视为命令 136 和137。相反，我们让它立即填补空白，如命令 136 和 137，一个特殊的 “no-op”命令，保持状态不变。（它通过执行共识算法的实例 136 和 137 的第 2阶段来实现此目的。选择这些 no-op 命令后，可以执行命令 138-140。</p><p>命令 1-140 现已选定。领导者还完成了所有大于 140 个共识算法的实例的第1 阶段，并且可以在这些实例的第 2 阶段中自由提出任何值。它将命令编号 141分配给客户端请求的下一个命令，并将其建议作为共识算法实例 141 的第 2阶段中的值。它建议将接收的下一个客户端命令作为命令 142，依此类推。</p><p>领导者可以在得知其建议的命令 141 已被选中之前提出命令142。它在提议命令 141 时发送的所有消息都有可能丢失，并且命令 142可能在任何其他服务器了解领导者提议的命令 141 之前被选择。当 leader在实例 141 中未能收到对其第 2阶段消息的预期响应时，它将重新传输这些消息。如果一切顺利，将选择其提议的命令。但是，它可能会首先失败，从而在所选命令的序列中留下空白。通常，假设领导者可以提前获取α 命令，也就是说，它可以在选择命令 1 到 i 之后提出命令 i + 1 到i+α。然后可能会出现高达 α-1 个命令的差距。</p><p>新选择的领导对共识算法的无限多个实例执行阶段 1 — 在上面的场景中，实例135-137 和所有大于 139的实例。对所有实例使用相同的提议编号，它可以通过向其他服务器发送一条合理的短消息来实现此目的。在阶段1 中，仅当接受者已经收到来自某个提议者的阶段 2消息时，接受者才会以不简单的 OK 进行响应。（在此方案中，仅实例 135 和140出现这种情况。因此，服务器（充当接受者）可以使用一条合理短的消息响应所有实例。因此，执行阶段1 的这些无限多个实例不会造成问题。</p><p>由于领导者失败和新领导者的选举应该是罕见的事件，因此执行状态机命令（即就命令/值达成共识）的有效成本是仅执行共识算法的第2 阶段的成本。可以证明，Paxos 共识算法的第 2阶段在存在故障的情况下达成协议的成本是任何算法中最低的。因此，Paxos算法本质上是最优的。</p><p>对系统正常运行的讨论假设始终只有一个领导者，除了当前领导者失败和新领导者选举之间的短暂时期。在异常情况下，leader选举可能会失败。如果没有服务器充当leader，则不会提出新命令。如果多个服务器认为他们是领导者，那么他们都可以在共识算法的同一实例中提出值，这可能会阻止选择任何值。但是，安全性得到了保留— 两个不同的服务器永远不会在选择作为第 i个状态机命令的值上产生分歧。选举一名领导人只是为了确保进展。</p><p>如果服务器集可以更改，那么必须有某种方法可以确定哪些服务器实现了共识算法的哪些实例。最简单的方法是通过状态机本身。当前的服务器集可以成为状态的一部分，并且可以使用常规状态机命令进行更改。我们可以允许领导者提前获得α命令，方法是让执行共识算法的实例i + α 的服务器集在执行第 i 个状态机命令后由状态指定。这允许对任意复杂的reconfiguration 算法进行简单实现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mit6.824" scheme="http://polaris3003.github.io/categories/mit6-824/"/>
    
    
    <category term="分布式系统" scheme="http://polaris3003.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    
    <category term="mit6.824" scheme="http://polaris3003.github.io/tags/mit6-824/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture9</title>
    <link href="http://polaris3003.github.io/2024/07/18/%E7%AC%AC%E4%B9%9D%E8%AF%BE%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <id>http://polaris3003.github.io/2024/07/18/%E7%AC%AC%E4%B9%9D%E8%AF%BE%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</id>
    <published>2024-07-18T12:47:51.000Z</published>
    <updated>2025-02-11T09:25:04.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第九课索引并发控制">第九课：索引并发控制</h1><h2 id="索引并发控制">1 索引并发控制</h2><p>到目前为止，我们假设我们讨论的数据结构是单线程的。然而，大多数 DBMS需要允许多个线程安全地访问数据结构，以利用额外的 CPU 核心并隐藏磁盘 I/O停顿。</p><p>有些系统使用单线程模型。将单线程数据结构转换为多线程数据结构的一种简单方法是使用读写锁，但效率不高。</p><p>并发控制协议是 DBMS用于确保共享对象上的并发操作得到“正确”结果的方法。</p><p>协议的正确性标准可能会有所不同：</p><ul><li><strong>逻辑正确：</strong>这意味着线程能够读取它应该读取的值，例如线程应该读回它之前写入的值。</li><li><strong>物理正确：</strong>这意味着对象的内部表示是健全的，例如数据结构中不存在会导致线程读取无效内存位置的指针</li></ul><p>出于本讲座的目的，我们只关心强制执行物理正确性。我们将在后面的课中重新审视逻辑正确性。</p><h2 id="locks-vs.-latches">2 Locks vs. Latches</h2><p>在讨论 DBMS 如何保护其内部元素时，锁和闩锁之间存在重要区别。</p><h3 id="locks">Locks</h3><p>锁时一种更高层次的逻辑原语，用于保护数据库中的内容（例如元组，表或者整个数据库），防止其他事务的干扰。一个事务在其整个执行期间都会持有锁。数据库系统可以向用户公开运行查询时持有的锁。应该有一些更高级别的机制来检测死锁和回滚更改。</p><h3 id="latches">Latches</h3><p>锁存器是低级保护原语，用于来自其他线程的 DBMS内部数据结构（例如数据结构、内存区域）的关键部分。锁存器会在数据库系统中短暂保留一个简单的操作（即页锁存器）。锁存器有两种模式：</p><ul><li><strong>读：</strong>允许多个线程同时读取同一个项目。即使另一个线程已经在读模式下获取了锁存器，线程也可以在读模式下获取该锁存器。</li><li><strong>写：</strong>只允许一个线程访问该项目。如果另一个线程在任何模式下持有锁存器，则线程无法获取写锁存器。持有写锁存器的线程还会阻止其他线程获取读锁存器。</li></ul><h2 id="latch实现">3 Latch实现</h2><p>Latch实现应该具有较小的内存占用，并且在没有争用时可以有一条快速路径来获取锁存器。</p><p>用于实现锁存器的底层原语是通过现代 CPU提供的原子指令。这样，线程可以检查内存位置的内容以查看它是否具有特定值。</p><p>有多种方法可以在 DBMS中实现锁存器。每种方法在工程复杂性和运行时性能方面都有不同的权衡。这些测试和设置步骤以原子方式执行（即，没有其他线程可以更新测试和设置步骤之间的值。</p><h3 id="test-and-set-spin-latch-tas-自旋锁">Test-and-Set Spin Latch(TAS) （自旋锁）</h3><p>自旋锁存器是操作系统互斥体的更有效替代方案，因为它由 DBMS控制。自旋锁存器本质上是线程尝试更新的内存位置（例如，将布尔值设置为true）。线程执行 CAS 来尝试更新内存位置。DBMS可以控制如果无法获得锁存器会发生什么情况。它可以选择重试（例如，使用while 循环）或允许操作系统取消调度它。因此，此方法为 DBMS提供了比操作系统互斥体更多的控制权，在操作系统互斥体中，如果无法获取锁存器，则将控制权交给操作系统。</p><ul><li>举例：std::atomic<T></T></li><li>优点:锁存/解锁操作非常高效（在 x86 上使用单指令锁定/解锁）。</li><li>缺点:不可扩展，也不适合缓存，因为使用多个线程，CAS指令将在不同的线程中执行多次。这些浪费的指令会在高竞争环境中堆积起来；尽管线程没有做有用的工作，但对操作系统来说它们看起来很忙。这会导致缓存一致性问题，因为线程正在轮询其他CPU 上的缓存线。</li></ul><h3 id="阻塞操作系统mutex">阻塞操作系统Mutex</h3><p>锁存器的一种可能实现是操作系统内置的互斥基础设施。 Linux 提供了futex（快速用户空间互斥体），它由 (1) 用户空间中的自旋锁存器和 (2)操作系统级互斥体组成。如果 DBMS可以获取用户空间锁存器，则锁存器被设置。尽管它包含两个内部锁存器，但它对于DBMS 来说却显示为单个锁存器。如果 DBMS无法获取用户空间锁存器，那么它会进入内核并尝试获取更昂贵的互斥锁。DBMS无法获取第二个互斥体，然后线程通知操作系统它在互斥体上被阻塞，然后它被取消调度。</p><p>操作系统互斥在 DBMS内部通常是一个坏主意，因为它由操作系统管理并且开销很大</p><ul><li>举例：std::mutex</li><li>优点：使用简单并且在DBMS中不需要额外coding</li><li>缺点：由于操作系统调度，成本昂贵且不可扩展（每次锁定/解锁调用大约 25ns）。</li></ul><h3 id="读写latches">读写Latches</h3><p>互斥锁和自旋锁存器不区分读/写（即，它们不支持不同的模式）。DBMS需要一种允许并发读取的方法，因此如果应用程序有大量读取，它将具有更好的性能，因为读取者可以共享资源而不是等待。</p><p>读写器锁存器允许锁存器保持在读或写模式。它追踪有多少个线程持有锁存器并等待在每种模式下获取锁存器。读写器锁存器使用前两个锁存器实现之一作为原语，并具有额外的逻辑来处理读写器队列，这些队列是每种模式下对锁存器的请求的队列。不同的DBMS 对于如何处理队列可以有不同的策略。</p><p>需要注意的一件事是，不同的读写锁实现具有不同的等待策略。有读者优先锁、作者优先锁和公平读写锁。不同操作系统和pthread 实现中的行为有所不同。</p><ul><li>举例：std::shared_mutex</li><li>优点：允许并发读</li><li>缺点：DBMS必须管理读/写队列以避免饥饿。由于额外的元数据，存储开销比自旋锁存器更大。</li></ul><h2 id="哈希表latch">4 哈希表Latch</h2><p>由于线程访问数据结构的方式有限，因此很容易支持静态哈希表中的并发访问。例如，当从槽移动到下一个槽时（即自上而下），所有线程都沿相同方向移动。线程一次也只能访问一个页面/槽。因此，在这种情况下不可能出现死锁，因为没有两个线程可以竞争对方持有的锁存器。当我们需要调整表的大小时，我们只需对整个表进行全局锁存即可执行操作。</p><p>动态哈希方案（例如，可扩展）中的锁存是一种更复杂的方案，因为有更多的共享状态需要更新，但一般方法是相同的。</p><p>有两种方法支持哈希表中的锁存，它们的锁存粒度不同:</p><ul><li><strong>页级锁存器：</strong>每个页面都有自己的读写器锁存器来保护其全部内容。线程在访问页面之前获取读或写锁存器。这会降低并行性，因为一次可能只有一个线程可以访问一页，但是对于单个线程来说，访问一页中的多个槽会很快，因为它只需要获取一个锁存器。</li><li><strong>槽级锁存器：</strong>每个插槽都有自己的闩锁。这增加了并行性，因为两个线程可以访问同一页面上的不同插槽。但它增加了访问表的存储和计算开销，因为线程必须为其访问的每个槽获取锁存器，并且每个槽必须为锁存器存储数据。DBMS可以使用单模式锁存器（即自旋锁存器）来减少元数据和计算开销，但代价是一些并行性。</li></ul><p>还可以直接使用比较和交换 (CAS)指令创建无锁存线性探测哈希表。通过尝试将特殊的“空”值与我们希望插入的元组进行比较和交换，可以实现在槽处的插入。如果失败，我们可以探测下一个槽，继续直到成功。</p><h2 id="b树latch">5 B+树Latch</h2><p>B+Tree 锁存的挑战是防止以下两个问题：</p><ul><li>多个线程同时尝试修改节点的内容。</li><li>一个线程遍历树，而另一个线程拆分/合并节点。</li></ul><p>"Latch crabbing/coupling"是一种协议，它允许多个线程同时访问或修改B+树。基本思路如下：</p><ol type="1"><li>获得父节点的锁</li><li>获得子节点的锁</li><li>如果子节点被认为“安全”，则释放父节点的锁。“安全”节点是指更新时不会分裂、合并或重新分配的节点。换句话说，一个节点是“安全的”如果<ul><li>插入：它不是满的</li><li>删除：它至少半满</li></ul></li></ol><p>请注意，读锁存器不需要担心“安全”条件。</p><p><strong>基本锁抓取协议：</strong></p><ul><li>搜索：从根开始向下，重复获取子级的闩锁，然后解锁父级。</li><li>插入/删除：从根开始向下，根据需要获取 X个锁存器。一旦孩子被锁住，检查是否安全。如果孩子安全，则释放其所有祖先的锁</li></ul><p>从正确性的角度来看，锁存器释放的顺序并不重要。然而，从性能的角度来看，最好释放树中较高位置的锁存器，因为它们会阻止对大部分叶节点的访问。</p><p><strong>改进的锁抓取协议：</strong>基本锁抓取算法的问题在于，事务总是在每次插入/删除操作的根上获取独占锁.这限制了并行性。相反，我们可以假设必须调整大小（即拆分/合并节点）的情况很少见，因此事务可以获取直至叶节点的共享锁存器。每个事务都会假设到目标叶节点的路径是安全的，并使用READ锁存器和螃蟹来到达它并进行验证。如果叶节点不安全，那么我们将中止并执行之前的算法，获取WRITE 锁存器。</p><ul><li>搜索：与以前相同的算法。</li><li>插入/删除：设置读锁就像搜索一样，转到叶子，然后在叶子上设置写锁。如果叶子不安全，则释放所有先前的锁存器，并使用先前的插入/删除协议重新启动事务。</li></ul><p><strong>叶子结点扫描</strong></p><p>这些协议中的线程以“自上而下”的方式获取锁存器。这意味着线程只能从低于其当前节点的节点获取锁存器。如果所需的锁不可用，则线程必须等待直到它变得可用。鉴于此，永远不会出现僵局。</p><p>然而，叶节点扫描很容易出现死锁，因为现在我们有线程尝试同时在两个不同方向获取排它锁（例如，线程1 尝试删除，线程 2执行叶节点扫描）。索引锁存器不支持死锁检测或避免。</p><p>因此，程序员处理这个问题的唯一方法是通过编码规则。叶节点同级锁存器获取协议必须支持“无等待”模式。也就是说，B+树代码必须处理失败的锁存获取。由于锁旨在（相对）短暂地保持，因此如果线程尝试获取叶节点上的锁但该锁不可用，则它应该快速中止其操作（释放其持有的任何闩锁）并重新启动操作。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="哈希表" scheme="http://polaris3003.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="并发控制" scheme="http://polaris3003.github.io/tags/%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    
    <category term="索引结构" scheme="http://polaris3003.github.io/tags/%E7%B4%A2%E5%BC%95%E7%BB%93%E6%9E%84/"/>
    
    <category term="锁 (Locks)" scheme="http://polaris3003.github.io/tags/%E9%94%81-Locks/"/>
    
    <category term="闩锁 (Latches)" scheme="http://polaris3003.github.io/tags/%E9%97%A9%E9%94%81-Latches/"/>
    
    <category term="自旋锁 (Spin Locks)" scheme="http://polaris3003.github.io/tags/%E8%87%AA%E6%97%8B%E9%94%81-Spin-Locks/"/>
    
    <category term="B+树" scheme="http://polaris3003.github.io/tags/B-%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>why kafka so fast?</title>
    <link href="http://polaris3003.github.io/2024/07/16/Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F/"/>
    <id>http://polaris3003.github.io/2024/07/16/Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F/</id>
    <published>2024-07-16T02:30:17.000Z</published>
    <updated>2025-02-11T09:25:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="kafka为什么这么快">Kafka为什么这么快？</h1><p>kafka是一个成熟的消息队列，一直以性能高著称，它之所以能够实现高吞吐量和低延迟，主要是由于以下几个方面的优化。</p><h2 id="消息发送">消息发送</h2><ol type="1"><li><strong>批量发送：</strong>Kafka通过将多个消息打包成一个批次，减少了网络传输和磁盘写入的次数，从而提高了消息的吞吐量和传输效率。</li><li><strong>异步发送：</strong>生产者可以异步发送消息，不必等待每个消息的确认，这大大提高了消息发送的效率。</li><li><strong>消息压缩：</strong>支持对消息进行压缩，减少网络传输的数据量。</li><li><strong>并行发送：</strong>通过将数据分布在不同的分区（Partitions）中，生产者可以并行发送消息，从而提高了吞吐量。</li></ol><h2 id="消息存储">消息存储</h2><ol type="1"><li><strong>零拷贝技术：</strong>Kfaka使用零拷贝技术来避免了数据的拷贝操作，降低了内存和CPU的使用率，提高了系统的性能。</li><li><strong>磁盘顺序写入：</strong>Kafka把消息存储在磁盘上，且以顺序的方式写入数据。顺序写入比随机写入速度快很多，因为它减少了磁头寻道时间。避免了随机读写带来的性能损耗，提高了磁盘的使用效率。</li><li><strong>页缓存：</strong>Kafka将起数据存储在磁盘中，但在访问数据时，它会先将数据加载到操作系统的页缓存中，并在页缓存中保留一份副本，从而实现快速的数据访问。</li><li><strong>稀疏索引：</strong>Kafka存储消息是通过分段的日志文件，每个分段都有自己的索引文件。这些索引文件中的条目不是对分段中的每条消息都建立索引，而是每隔一定数量的消息建立一个索引点，这就构成了稀疏索引。稀疏索引减少了索引大小，使得加载到内存中的索引更小，提高了查找特定消息的效率。</li><li><strong>分区和副本：</strong>Kafka采用分区和副本的机制，可以将数据分散到多个节点上进行处理，从而实现了分布式的高可用性和负载均衡。</li></ol><h2 id="消息消费">消息消费</h2><ol type="1"><li><strong>消费者群组：</strong>通过消费者群组可以实现消息的负载均衡和容错处理。</li><li><strong>并行消费：</strong>不同的消费者可以独立地消费不同的分区，实现消费的并行处理。</li><li><strong>批量拉取：</strong>Kafka支持批量拉取消息，可以一次性拉取多个消息进行消费。减少网络消耗，提升性能。</li></ol><table><thead><tr><th><strong>生产消息</strong></th><th><strong>存储消息</strong></th><th><strong>消费消息</strong></th></tr></thead><tbody><tr><td>批量发送</td><td>零拷贝技术</td><td>消费者群组</td></tr><tr><td>异步发送</td><td>磁盘顺序写入</td><td>并行消费</td></tr><tr><td>消息压缩</td><td>页缓存</td><td>批量拉取</td></tr><tr><td>并行发送</td><td>稀疏索引</td><td></td></tr><tr><td></td><td>分区和副本</td><td></td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mq" scheme="http://polaris3003.github.io/categories/mq/"/>
    
    
    <category term="高性能" scheme="http://polaris3003.github.io/tags/%E9%AB%98%E6%80%A7%E8%83%BD/"/>
    
    <category term="批量发送" scheme="http://polaris3003.github.io/tags/%E6%89%B9%E9%87%8F%E5%8F%91%E9%80%81/"/>
    
    <category term="异步发送" scheme="http://polaris3003.github.io/tags/%E5%BC%82%E6%AD%A5%E5%8F%91%E9%80%81/"/>
    
    <category term="消息压缩" scheme="http://polaris3003.github.io/tags/%E6%B6%88%E6%81%AF%E5%8E%8B%E7%BC%A9/"/>
    
    <category term="并行发送" scheme="http://polaris3003.github.io/tags/%E5%B9%B6%E8%A1%8C%E5%8F%91%E9%80%81/"/>
    
    <category term="零拷贝技术" scheme="http://polaris3003.github.io/tags/%E9%9B%B6%E6%8B%B7%E8%B4%9D%E6%8A%80%E6%9C%AF/"/>
    
    <category term="磁盘顺序写入" scheme="http://polaris3003.github.io/tags/%E7%A3%81%E7%9B%98%E9%A1%BA%E5%BA%8F%E5%86%99%E5%85%A5/"/>
    
    <category term="页缓存" scheme="http://polaris3003.github.io/tags/%E9%A1%B5%E7%BC%93%E5%AD%98/"/>
    
    <category term="稀疏索引" scheme="http://polaris3003.github.io/tags/%E7%A8%80%E7%96%8F%E7%B4%A2%E5%BC%95/"/>
    
    <category term="分区和副本" scheme="http://polaris3003.github.io/tags/%E5%88%86%E5%8C%BA%E5%92%8C%E5%89%AF%E6%9C%AC/"/>
    
    <category term="消费者群组" scheme="http://polaris3003.github.io/tags/%E6%B6%88%E8%B4%B9%E8%80%85%E7%BE%A4%E7%BB%84/"/>
    
    <category term="并行消费" scheme="http://polaris3003.github.io/tags/%E5%B9%B6%E8%A1%8C%E6%B6%88%E8%B4%B9/"/>
    
    <category term="批量拉取" scheme="http://polaris3003.github.io/tags/%E6%89%B9%E9%87%8F%E6%8B%89%E5%8F%96/"/>
    
  </entry>
  
  <entry>
    <title>茶7.15-7.19</title>
    <link href="http://polaris3003.github.io/2024/07/15/%E8%8C%B67.15-7.19/"/>
    <id>http://polaris3003.github.io/2024/07/15/%E8%8C%B67.15-7.19/</id>
    <published>2024-07-15T02:44:51.000Z</published>
    <updated>2025-02-11T09:24:46.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tea7.15-7.19">Tea7.15-7.19</h1><h2 id="mon">Mon</h2><p><a href="https://codeforces.com/problemset/problem/1922/C">ClosestCities_161C</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e5，m 之和≤1e5。<br>每组数据输入 n(2≤n≤1e5) 和长为 n 的严格递增数组 a(0≤a[i]≤1e9)。<br>然后输入 m(1≤m≤1e5) 和 m 个询问，每个询问输入两个数 x 和 y，范围 [1,n]且 x≠y。</p><p>数轴上有 n 个点，点 i 的坐标为 a[i]。<br>有两种移动方式：</p><ol type="1"><li>从点 i 移动到离它最近的点，花费是1。保证每个点只有唯一的离它最近的点。</li><li>从点 i 移动到点 j，花费是 |a[i]-a[j]|。</li></ol><p>对于每个询问，输出从点 x 移动到点 y 的最小花费。</p><p>输入<br>1<br>5<br>0 8 12 15 20<br>5<br>1 4<br>1 5<br>3 4<br>3 2<br>5 1<br>输出<br>3<br>8<br>1<br>4<br>14</p><p><strong>Sol:</strong></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-function">vi <span class="hljs-title">near</span><span class="hljs-params">(n)</span></span>;<br>    near[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    near[n<span class="hljs-number">-1</span>] = n<span class="hljs-number">-2</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        near[i] = <span class="hljs-built_in">abs</span>(a[i] - a[i<span class="hljs-number">-1</span>])&gt;<span class="hljs-built_in">abs</span>(a[i]-a[i<span class="hljs-number">+1</span>])? i<span class="hljs-number">+1</span>:i<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// print(near);</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    <span class="hljs-function">vll <span class="hljs-title">suml</span><span class="hljs-params">(n)</span>,<span class="hljs-title">sumr</span><span class="hljs-params">(n)</span></span>;<br>    suml[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// BUG(near[i-1]);</span><br>        <span class="hljs-comment">// BUG(i);</span><br>        suml[i] = suml[i<span class="hljs-number">-1</span>];<br>        suml[i] += near[i<span class="hljs-number">-1</span>]==i?<span class="hljs-number">1</span>:<span class="hljs-built_in">abs</span>(a[i]-a[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-comment">// BUG(suml[i]);</span><br>    &#125;<br>    <span class="hljs-comment">// print(suml);</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    sumr[n<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        sumr[i] = sumr[i<span class="hljs-number">+1</span>];<br>        sumr[i] += near[i<span class="hljs-number">+1</span>]==i?<span class="hljs-number">1</span>:<span class="hljs-built_in">abs</span>(a[i]-a[i<span class="hljs-number">+1</span>]);<br>    &#125;<br>    <span class="hljs-comment">// print(sumr);</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span>(q--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l--;r--;<br>        <span class="hljs-keyword">if</span>(l &lt; r) &#123;<br>            cout &lt;&lt; suml[r] - suml[l] &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; sumr[r] - sumr[l] &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="feb">Feb</h2><p><a href="https://codeforces.com/problemset/problem/1891/C">Smilo andMonsters_907C</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>一开始 cnt = 0。<br>有两种操作，每种都可以执行任意次。<br>第一种：把一个大于 0 的 a[i] 减少 1，然后 cnt += 1。<br>第二种：把一个大于等于 cnt 的 a[i] 减少 cnt，然后 cnt = 0。</p><p>把所有 a[i] 都变成 0，最少要操作多少次？</p><p>输入<br>4<br>4<br>1 3 1 1<br>4<br>1 2 1 1<br>6<br>3 2 1 5 2 4<br>2<br>1 6<br>输出<br>4<br>4<br>11<br>5</p><p><strong>Sol:</strong></p><p>提示 1：从特殊情况入手。如果有一个数非常大，最优操作是什么样的？</p><p>如果有一个数非常大，可以把其他数都通过操作一搞定，最后把操作二用到这个数上。</p><p>这启发我们，用操作一操作小的数，用操作二操作大的数，可以让总操作次数尽量小。</p><p>也可以反过来思考：如果用操作一操作大的数，操作二操作小的数，就会因为操作二的限制，导致操作二必须执行很多次。</p><p>提示 2：把 cnt理解为能量，操作一积累能量，操作二释放能量，但释放多少，其实可以自己决定。</p><p>设 s = sum(a)，left = ceil(s/2)。</p><p>把 a 从小到大排序。不断地把 left 减少 a[i]，直到 left &lt; a[i]为止。 此时我们积累了足够的能量，剩余的 n-i 个数（i 从 0开始）全部用操作二搞定。</p><p>答案为 ceil(s/2) + n-i。 <a href="https://codeforces.com/problemset/submission/1891/270160606">代码</a></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; a[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span> + a[<span class="hljs-number">0</span>] % <span class="hljs-number">2</span> + (a[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>?<span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-function">vll <span class="hljs-title">sum</span><span class="hljs-params">(n)</span></span>;<br>    sum[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> right = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (sum[n<span class="hljs-number">-1</span>] - sum[i] &gt;= sum[n<span class="hljs-number">-1</span>] / <span class="hljs-number">2</span>) &#123;<br>            right = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//BUG(mid);</span><br>    <span class="hljs-comment">//BUG(right);</span><br>    cout &lt;&lt; n - right - <span class="hljs-number">1</span> + sum[n<span class="hljs-number">-1</span>] / <span class="hljs-number">2</span> + sum[n<span class="hljs-number">-1</span>] % <span class="hljs-number">2</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed">Wed</h2><p><a href="https://codeforces.com/problemset/problem/1893/B">NeutralTonality_908B</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5，m 之和≤2e5。<br>每组数据输入 n(1≤n≤2e5) m(1≤m≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，长为 m的数组 b(1≤b[i]≤1e9)。</p><p>把 b 中所有元素以任意顺序在任意位置插入 a 中，得到数组 c。<br>例如 a=[3,1,1]，b=[9,4,5]，插入后可以是 c=[3,1,4,1,5,9]。</p><p>你需要使 LIS(c) 最短。（LIS 是最长严格递增子序列）<br>输出任意符合要求的 c。</p><p>输入<br>7<br>2 1<br>6 4<br>5<br>5 5<br>1 7 2 4 5<br>5 4 1 2 7<br>1 9<br>7<br>1 2 3 4 5 6 7 8 9<br>3 2<br>1 3 5<br>2 4<br>10 5<br>1 9 2 3 8 1 4 7 2 9<br>7 8 5 4 6<br>2 1<br>2 2<br>1<br>6 1<br>1 1 1 1 1 1<br>777<br>输出<br>6 5 4<br>1 1 7 7 2 2 4 4 5 5<br>9 8 7 7 6 5 4 3 2 1<br>1 3 5 2 4<br>1 9 2 3 8 8 1 4 4 7 7 2 9 6 5<br>2 2 1<br>777 1 1 1 1 1 1</p><p><strong>Sol：</strong></p><p>构造题。</p><p>从特殊到一般，思考如下情况：</p><p>a 单调递减。</p><p>a 单调递增。</p><p>min(a) = a[0]</p><p>min(a) ≠ a[0]</p><p>构造方法： 先把 b 从大到小排序。然后双指针遍历 a 和 b 合并成 c，在把a[i] 加到 c 之前，必须把 &gt;= a[i] 的 b[j] 都加到 c。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span>,<span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, m<span class="hljs-number">-1</span>) cin &gt;&gt; b[i];<br>    <span class="hljs-built_in">rsort</span>(b);<br>    vi c;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(b[l] &gt;= a[i] &amp;&amp; l &lt; m) &#123;<br>            c.<span class="hljs-built_in">pb</span>(b[l]);<br>            l++;<br>        &#125;<br>        c.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(l &lt; m) &#123;<br>        c.<span class="hljs-built_in">pb</span>(b[l]);<br>        l++;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(c);cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu">Thu</h2><p><a href="https://codeforces.com/problemset/problem/1167/E">RangeDeleting 65E</a></p><p>输入 n(1≤n≤1e6) x(1≤x≤1e6) 和长为 n 的数组 a(1≤a[i]≤x)。</p><p>定义 D(a,L,R) 为删除 a 中所有元素值在 [L,R]中的元素后，剩余的元素组成的数组（不改变顺序）。</p><p>输出有多少对 (L,R) 满足 1&lt;=L&lt;=R&lt;=x 且 D(a,L,R)是非降数组，即相邻元素左边 &lt;= 右边。</p><p>输入<br>3 3<br>2 3 1<br>输出 4</p><p>输入<br>7 4<br>1 3 1 2 2 4 3<br>输出 6</p><p><strong>Sol:</strong></p><p>本题是近期打卡题<a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/">【力扣2972. 统计移除递增子数组的数目 II】</a>的变形题。</p><p>由于思路和代码都非常接近，推荐先把力扣那题做了。</p><p><strong>核心思路：删除元素后，对于剩余的每个元素，考察其出现位置的区间，这些区间必须不相交。</strong></p><p>记录每个元素首次和最后一次出现的位置。</p><p>定义 ps[v].l 表示元素 v 首次出现的位置，ps[v].r 表示元素 v最后一次出现的位置。</p><p>用闭区间 [ps[v].l, ps[v].r] 表示元素 v。</p><p>对于剩余元素中的两个数 v 和 w，如果 v &lt; w，那么区间 [ps[v].l,ps[v].r] 必须在区间 [ps[w].l, ps[w].r] 的左侧，即 ps[v].r &lt;ps[w].l。</p><p>首先考虑一个简单情况：1 到 x 中的每个数都在数组 a 中。</p><p>和力扣 2972 题代码一样，双指针，把「元素值比大小」改成 ps[v].r &lt;ps[w].l 这样的「区间左右端点比大小」即可。</p><p>本题的一个难点是，如果有元素不在 a中，怎么算清楚这种情况，尤其是不能重复统计。</p><p>首先把 ps 中的元素值在 a 中的区间提取出来，得到数组 b。</p><p>其中 b[i].l 和 b[i].r 是第 i 个区间的左右端点，b[i].v 是第 i个区间对应的元素值。</p><p>看上去在 b 数组上「区间左右端点比大小」就行，怎么把不在 a中的元素值考虑进来呢？</p><p>和 2972 题 <a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/solution/shuang-zhi-zhen-on-shi-jian-o1-kong-jian-2hsz/">灵神的题解</a>一样，首先讨论删除后缀的情况，然后讨论一般情况。</p><p>删除后缀 b[k] 到 b[n-1]，其中 n 是 b 的长度，k &lt;= i+1。</p><p>那么删除的范围，最小值 &lt;= b[i+1].v，最大值 &gt;=b[n-1].v，根据乘法原理，这一共有 b[i+1].v * (x + 1 - b[n-1].v) 个。</p><p>然后讨论删除的不是后缀的情况。</p><p>删除 b[k] 到 b[j-1]，保留 b[j] 到 b[n-1]，那么删除的范围，最小值&lt;= b[i+1].v，最大值在左闭右开区间 [b[j-1].v, b[j].v)中，根据乘法原理，这一共有 b[i+1].v * (b[j].v - b[j-1].v) 个。</p><p><a href="https://codeforces.com/contest/1167/submission/271313557">Code</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n, x, y;<br>    cin &gt;&gt; n &gt;&gt; x;<br>    node *ps = <span class="hljs-keyword">new</span> node[x + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (ps[y].l == INT_MAX) &#123;<br>            ps[y].l = i;<br>            ps[y].v = y;<br>        &#125;<br>        ps[y].r = i;<br>    &#125;<br>    vector&lt;node&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(ps[i].r &gt;= <span class="hljs-number">0</span>)&#123;<br>            b.<span class="hljs-built_in">emplace_back</span>(ps[i]);<br>        &#125;<br>    &#125;<br>    n = b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n - <span class="hljs-number">1</span> &amp;&amp; b[i].r &lt; b[i + <span class="hljs-number">1</span>].l) i ++;<br>    <span class="hljs-keyword">if</span>(i == n - <span class="hljs-number">1</span>)&#123;<br>        cout &lt;&lt; x * (x + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = b[i + <span class="hljs-number">1</span>].v * (x + <span class="hljs-number">1</span> - b[n - <span class="hljs-number">1</span>].v);<br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; (j == n - <span class="hljs-number">1</span> || b[j].r &lt; b[j + <span class="hljs-number">1</span>].l))&#123;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; b[i].r &gt;= b[j].l) i --;<br>        ans += b[i + <span class="hljs-number">1</span>].v * (b[j].v - b[j - <span class="hljs-number">1</span>].v);<br>        j --;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span>[] ps;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri">Fri</h2><p><a href="https://codeforces.com/problemset/problem/1185/G2">Playlistfor Polycarp_568G</a></p><p>输入 n(1≤n≤50) 和 T(1≤T≤2500)。有 n 首歌。<br>然后输入 n 行，每行两个数 t(1≤t≤50) 和 g(1≤g≤3)，表示第 i首歌的时长和类型。</p><p>你需要从这 n 首歌中选出若干首歌，组成一个播放列表，满足：<br>1. 总时长为 T。<br>2. 没有重复歌曲。<br>3. 相邻歌曲的类型不同。注意这个列表只播放一次，所以不考虑首尾。</p><p>有多少种方案？注意歌曲的顺序不同，也算不同的方案。<br>答案模 1e9+7。</p><p>输入<br>3 3<br>1 1<br>1 2<br>1 3<br>输出 6</p><p>输入<br>3 3<br>1 1<br>1 1<br>1 3<br>输出 2</p><p>输入<br>4 10<br>5 3<br>2 1<br>3 2<br>5 1<br>输出 10</p><h3 id="sol"><strong>Sol:</strong></h3><h4 id="初步分析">初步分析：</h4><p>原问题可以拆分成如下两个问题：</p><ol type="1"><li>不考虑总时长（以及歌曲的排列），计算从这 n 首歌中选出 i 个类型 1，j个类型 2，k 个类型 3，且相邻歌曲类型不同的方案数。</li><li>不考虑相邻歌曲类型不同（以及歌曲的排列），计算从这 <em>n</em>首歌中选出 <em>i</em> 个类型 1，<em>j</em> 个类型 2，<em>k</em> 个类型3，且总时长为 <em>t</em> 的方案数。</li></ol><p>两个方案数相乘，再乘上排列数 i<em>!</em>j<em>!</em>k!，就可以得到从这n 首歌中选出 i 个类型 1，j 个类型 2，k 个类型 3，总时长为 t且相邻歌曲类型不同的方案数。</p><blockquote><p>另一种理解方式：相当于有若干个格子和三种颜色，问题 1负责涂色（保证相邻格子颜色不同），问题 2（乘上i<em>!</em>j<em>!</em>k*!）负责给每个格子放上具体的歌曲（颜色要匹配）。</p></blockquote><p>枚举所有的i，j，k，累加方案数，即为答案。</p><h4 id="问题1">问题1:</h4><p>不考虑总时长（以及歌曲的排列），计算从这n首歌中选出i个类型1，j个类型2，k个类型3，且相邻歌曲类型不同的方案数。</p><p>用<strong>状态机DP</strong>解决。</p><p>定义<span class="math inline">\(c_{i,j,k,x}\)</span>表示从这n首歌中选出i个类型1，j个类型2，k个类型3，且最后一首歌的类型为x且响铃歌曲类型不同的方案书。</p><p>枚举上一首歌的类型，那么有<br><span class="math display">\[c_{i+1,j,k,1} = c_{i,j,k,2} + c_{i,j,k,3}\\c_{i+1,j,k,2} = c_{i,j,k,1} + c_{i,j,k,3}\\c_{i+1,j,k,3} = c_{i,j,k,1} + c_{i,j,k,2}\]</span><br>这里用刷表法转移</p><p>初始值<span class="math inline">\(c_{1,0,0,1}=c_{0,1,0,2}=c_{0,0,1,3}= 1\)</span></p><h4 id="问题2">问题2</h4><p>不考虑相邻歌曲类型不同（以及歌曲的排列），计算从这n首歌中选出i个类型1，j个类型2，k个类型3，且总时长为t的方案数。</p><p>用多维0-1背包解决。</p><p><strong>优化前</strong></p><p>定义<span class="math inline">\(f_{p,i,j,k,t}\)</span>表示从前p首歌中选出i个类型1，j个类型2，k个类型3，且总时长为t的方案数。需要O(n<sup>4</sup>T)的时间和空间。</p><p><strong>优化</strong></p><p>考虑继续拆分问题：</p><ul><li>计算从这n首歌中选出i个类型1，且总时长为t的方案数。记为<span class="math inline">\(f_{i,t}\)</span>。</li><li>计算从这n首歌中选出j个类型2，k个类型3，且总时长为T-t的总方案数。记为<span class="math inline">\(g_{j,k,T-t}\)</span>。</li></ul><p>两个方案数相乘，就是问题2的方案数。</p><h4 id="汇总">汇总</h4><p>枚举i,j,k。</p><p>从这n首歌中选出i个类型1，j个类型2，k个类型3，总时长为t且相邻歌曲类型不同的方案数为<br><span class="math display">\[w_{i,j,k} =i!j!k!*(c_{i,j,k,1}+c_{i,j,k,2}+c_{i,j,k,3})*\sum_{t=0}^T{f_{i,t}g_{j,k,T-t}}\]</span><br>答案为<br><span class="math display">\[\sum_{i=0}^{cnt_1}\sum_{j=0}^{cnt_2}\sum_{k=0}^{cnt_3}w_{i,j,k}\]</span><br>其中cnt<sub>x</sub>为输入的n首歌中的类型为x的歌曲个数。</p><p>代码实现时，类型改成0，1，2。</p><p><strong><a href="https://codeforces.com/contest/1185/submission/271339996">Code</a>:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, tot, w, tp;<br>    cin &gt;&gt; n &gt;&gt; tot;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tot + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">2</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tot + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br>    g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; w &gt;&gt; tp;<br>        tp--;<br>        <span class="hljs-keyword">if</span> (tp == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = cnt[<span class="hljs-number">0</span>]; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = tot; t &gt;= w; t--) &#123;<br>                    <span class="hljs-built_in">add</span>(f[j + <span class="hljs-number">1</span>][t], f[j][t - w]);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">is</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>            is[tp] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = cnt[<span class="hljs-number">1</span>]; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = cnt[<span class="hljs-number">2</span>]; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = tot; t &gt;= w; t--) &#123;<br>                        <span class="hljs-built_in">add</span>(g[j + is[<span class="hljs-number">1</span>]][k + is[<span class="hljs-number">2</span>]][t], g[j][k][t - w]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cnt[tp]++;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fac</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &gt; &gt; <span class="hljs-built_in">c</span>(cnt[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>, vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &gt;(cnt[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;(cnt[<span class="hljs-number">2</span>] + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))));<br>    c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    c[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= cnt[<span class="hljs-number">0</span>]; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= cnt[<span class="hljs-number">1</span>]; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= cnt[<span class="hljs-number">2</span>]; k++) &#123;<br>                <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt;= tot; t++) &#123;<br>                    sum = (sum + f[i][t] * g[j][k][tot - t]) % mod;<br>                &#125;<br>                <span class="hljs-built_in">add</span>(ans, fac[i] * fac[j] % mod * fac[k] % mod * (c[i][j][k][<span class="hljs-number">0</span>] + c[i][j][k][<span class="hljs-number">1</span>] + c[i][j][k][<span class="hljs-number">2</span>]) % mod * sum);<br>                <span class="hljs-built_in">add</span>(c[i + <span class="hljs-number">1</span>][j][k][<span class="hljs-number">0</span>], c[i][j][k][<span class="hljs-number">1</span>] + c[i][j][k][<span class="hljs-number">2</span>]);<br>                <span class="hljs-built_in">add</span>(c[i][j + <span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], c[i][j][k][<span class="hljs-number">0</span>] + c[i][j][k][<span class="hljs-number">2</span>]);<br>                <span class="hljs-built_in">add</span>(c[i][j][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], c[i][j][k][<span class="hljs-number">0</span>] + c[i][j][k][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="codeforces" scheme="http://polaris3003.github.io/categories/codeforces/"/>
    
    
    <category term="数据结构" scheme="http://polaris3003.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://polaris3003.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="贪心算法" scheme="http://polaris3003.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://polaris3003.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="DFS（深度优先搜索）" scheme="http://polaris3003.github.io/tags/DFS%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/"/>
    
    <category term="树形DP" scheme="http://polaris3003.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="并查集" scheme="http://polaris3003.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="最短路径" scheme="http://polaris3003.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="动态规划" scheme="http://polaris3003.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="分治法" scheme="http://polaris3003.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>why using mq?</title>
    <link href="http://polaris3003.github.io/2024/07/15/MQ/"/>
    <id>http://polaris3003.github.io/2024/07/15/MQ/</id>
    <published>2024-07-15T02:10:17.000Z</published>
    <updated>2025-02-11T09:25:52.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么要使用消息队列">为什么要使用消息队列？</h1><p>使用消息队列的主要目的主要记住这几个关键词：<code>解耦</code>、<code>异步</code>、<code>削峰填谷</code></p><p><strong>解耦：</strong>在一个复杂的系统中，不同的模块或服务之间可能需要相互依赖，如果直接函数调用或者API调用的方式，会造成模块之间的耦合，当其中一个模块发生改变时，需要同时修改调用方和被调用方的代码。而使用消息队列作为中间件，不同的模块可以将消息发送到消息队列中，不需要知道具体的接收方是谁，接收方可以独立地消费消息，实现了模块之间的解耦。</p><p><strong>异步：</strong>有些操作比较耗时，例如发送邮件、生成报表等，如果使用同步的方式处理，会阻塞主线程或者进程，导致系统的性能下降，而使用消息队列，可以将这些操作封装成消息，放入消息队列中，异步地处理这些操作，不影响主流程的执行，提高了系统的性能和响应速度。</p><p><strong>削峰填谷：</strong>削峰填谷是一种在高并发场景下平衡系统压力的技术，通常用于平衡系统在高峰期和低谷期的资源利用率，提高系统的吞吐量和响应速度。在削峰填谷的过程中，通常使用消息队列作为缓冲区，将请求放入消息队列中，然后在系统负载低的时候进行处理。这种方式可以将系统的峰值压力分散到较长的时间段内，减少瞬时压力对系统的影响，从而提高系统的稳定性和可靠性。</p><p>另外消息队列还有一下优点：</p><ol type="1"><li><strong>可靠性高：</strong>消息队列通常具有高可靠性，可以实现消息的持久化存储、消息的备份和故障恢复等功能，保证消息不会丢失。</li><li><strong>扩展性好：</strong>通过增加消息队列实例或者添加消费组实例，可以实现消息队列的水平扩展，提高系统的处理能力。</li><li><strong>灵活性高：</strong>消息队列通常支持多种消息传递模式，如点对点模式和发布/订阅模式，可以根据不同的业务场景选择不同的模式。</li></ol><h2 id="kafkaactivemqrabbitmq和rocketmq都有哪些区别">Kafka、ActiveMQ、RabbitMQ和RocketMQ都有哪些区别？</h2><p>Kafka、ActiveMQ、RabbitMQ和RocketMQ都是常见的消息中间件，它们都提供了高性能、高可用、可扩展的消息传递机制，但它们之间也有以下一些区别：</p><ol type="1"><li><p><strong>消息传递模型：</strong>Kafka主要支持发布-订阅模型，ActiveMQ、RabbitMQ和RocketMQ则同时支持点对点和发布-订阅两种模型。</p></li><li><p><strong>性能和吞吐量：</strong>Kafka在数据处理和数据分发方面表现出色，可以处理每秒数百万条消息，而ActiveMQ、RabbitMQ和RocketMQ的吞吐量相对较低。</p></li><li><p><strong>消息分区和负载均衡：</strong>Kafka将消息划分为多个分区，并分布在多个服务器上，实现负载均衡和高可用性。ActiveMQ和RabbitMQ和RocketMQ也支持消息分区和负载均衡，但实现方式不同，例如RabbitMQ使用了一种叫做Sharding的机制。</p></li><li><p><strong>开发和部署复杂度：</strong>Kafka相对比较简单，易于使用和部署，但在实现一些高级功能时需要进行一些复杂的配置。ActiveMQ、RabbitMQ和RocketMQ则提供了更多的功能和选项，也更加灵活，但相应地会增加开发和部署的复杂度。</p></li><li><p><strong>社区和生态：</strong>Kafka、ActiveMQ、RabbitMQ和RocketMQ都拥有庞大的社区和完善的生态系统，但Kafka和RocketMQ目前的发展势头比较迅猛，社区活跃度也相对较高。</p></li><li><p><strong>功能支持：</strong></p><table><thead><tr><th></th><th>优先级队列</th><th>延迟队列</th><th>死信队列</th><th>重试队列</th><th>消费模式</th><th>事务消息</th></tr></thead><tbody><tr><td>Kafka</td><td>不支持</td><td>不支持，可以间接实现延迟队列</td><td>无</td><td>不直接支持，可以通过消费者逻辑来实现重试逻辑。</td><td>主要是拉模式</td><td>支持事务，但限于消息生产。</td></tr><tr><td>RocketMQ</td><td>支持</td><td>直接支持延迟队列，可以设定消息的延迟时间。</td><td>支持</td><td>支持重试队列，可以自动或手动将消息重新发送。</td><td>支持推和拉两种模式</td><td>支持事务消息。</td></tr><tr><td>RabbitMQ</td><td>支持</td><td>支持延迟队列，可以通过插件或者消息TTL和死信交换来实现。</td><td>支持</td><td>可以实现重试机制，但需要通过消息属性和额外配置来手动设置。</td><td>主要是推模式，但也可以实现拉模式</td><td>支持基本的消息事务。</td></tr><tr><td>ActiveMQ</td><td>支持</td><td>支持</td><td>支持</td><td>支持重试机制，可以配置消息重发策略。</td><td>支持推和拉两种模式</td><td>支持消息事务。</td></tr></tbody></table></li></ol><h2 id="如何选型">如何选型？</h2><p>在选择消息队列技术时，需要根据实际业务需求和系统特点来选择，以下是一些参考因素：</p><ol type="1"><li>性能和吞吐量：如果需要处理海量数据，需要高性能和高吞吐量，那么Kafka是一个不错的选择。</li><li>可靠性：如果需要保证消息传递的可靠性，包括数据不丢失和消息不重复投递，那么RocketMQ和RabbitMQ都提供了较好的可靠性保证。</li><li>消息传递模型：如果需要支持发布-订阅和点对点模型，那么RocketMQ和RabbitMQ是一个不错的选择。如果只需要发布-订阅模型，Kafka则是一个更好的选择。</li><li>消息持久化：如果需要更快地持久化消息，并且支持高效的消息查询，那么Kafka是一个不错的选择。如果需要更加传统的消息持久化方式，那么RocketMQ和RabbitMQ可以满足需求。</li><li>开发和部署复杂度：Kafka比较简单，易于使用和部署，但在实现一些高级功能时需要进行一些复杂的配置。RocketMQ和RabbitMQ提供了更多的功能和选项，也更加灵活，但相应地会增加开发和部署的复杂度。</li><li>社区和生态：Kafka、RocketMQ和RabbitMQ都拥有庞大的社区和完善的生态系统，但Kafka和RocketMQ目前的发展势头比较迅猛，社区活跃度也相对较高。</li><li>实现语言方面，kafka是基于scala和java开发的，rocketmq、activemq等都是基于java语言的，rabbitmq是基于erlang的。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="mq" scheme="http://polaris3003.github.io/categories/mq/"/>
    
    
    <category term="解耦" scheme="http://polaris3003.github.io/tags/%E8%A7%A3%E8%80%A6/"/>
    
    <category term="异步" scheme="http://polaris3003.github.io/tags/%E5%BC%82%E6%AD%A5/"/>
    
    <category term="削峰填谷" scheme="http://polaris3003.github.io/tags/%E5%89%8A%E5%B3%B0%E5%A1%AB%E8%B0%B7/"/>
    
    <category term="高可用性" scheme="http://polaris3003.github.io/tags/%E9%AB%98%E5%8F%AF%E7%94%A8%E6%80%A7/"/>
    
    <category term="高吞吐量" scheme="http://polaris3003.github.io/tags/%E9%AB%98%E5%90%9E%E5%90%90%E9%87%8F/"/>
    
    <category term="负载均衡" scheme="http://polaris3003.github.io/tags/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1/"/>
    
    <category term="消息持久化" scheme="http://polaris3003.github.io/tags/%E6%B6%88%E6%81%AF%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    
    <category term="事务消息" scheme="http://polaris3003.github.io/tags/%E4%BA%8B%E5%8A%A1%E6%B6%88%E6%81%AF/"/>
    
  </entry>
  
  <entry>
    <title>茶7.8-7.12</title>
    <link href="http://polaris3003.github.io/2024/07/08/%E8%8C%B67.8-7.12/"/>
    <id>http://polaris3003.github.io/2024/07/08/%E8%8C%B67.8-7.12/</id>
    <published>2024-07-08T07:44:51.000Z</published>
    <updated>2025-02-11T09:24:42.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶7.8-7.12">茶7.8-7.12</h1><h2 id="mon">Mon</h2><p><a href="https://codeforces.com/problemset/problem/1927/D">Find theDifferent Ones!_923D</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5，q 之和≤2e5。<br>每组数据输入 n(2≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e6)，下标从 1开始。<br>然后输入 q(1≤q≤2e5) 和 q 个询问，每个询问输入两个数 LR(1≤L&lt;R≤n)。</p><p>对于每个询问，输出在 [L,R] 内的两个下标 i 和 j，满足 a[i] ≠a[j]。<br>如果不存在，输出 "-1 -1"。</p><p>样例太长，请在原题查看。</p><p><strong>Sol:</strong></p><p>定义 left[i] 表示在 a[i] 左侧的不等于 a[i] 的最近元素下标。</p><p>递推：如果 a[i] = a[i-1] 则 left[i] = left[i-1]，否则 left[i] =i-1。</p><p>回答询问时，如果 left[R] &lt; L 则输出 -1 -1，否则输出 left[R] 和R。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-function">vi <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span></span>;<br>    nxt[n<span class="hljs-number">-1</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        nxt[i] = a[i] == a[i<span class="hljs-number">+1</span>] ? nxt[i<span class="hljs-number">+1</span>] : i<span class="hljs-number">+1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> q;<br>    cin&gt;&gt;q;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        l--;<br>        <span class="hljs-keyword">if</span>(nxt[l]&lt;r)&#123;<br>            cout&lt;&lt;l<span class="hljs-number">+1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;nxt[l]<span class="hljs-number">+1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue">Tue</h2><p><a href="https://codeforces.com/problemset/problem/1670/C" class="uri">https://codeforces.com/problemset/problem/1670/C</a></p><p>输入 T(≤1e5) 表示 T 组数据。所有数据的 n 之和 ≤5e5。<br>每组数据输入 n(1≤n≤1e5) 和两个 1<sub>n</sub> 的排列 a 和 b，<br>然后输入数组 d，保证 d[i] 是 {0,a[i],b[i]} 中的一个。</p><p>构造一个 1<sub>n</sub> 的排列 c，满足：<br>如果 d[i]&gt;0，那么 c[i] 必须是 d[i]，否则 c[i] 可以是 a[i]，也可以是b[i]。</p><p>你能构造出多少个不同的排列 c？模 1e9+7。<br>保证至少能构造一个排列 c。</p><p>样例太长，请在原题查看。</p><p><strong>Sol:</strong></p><p>从 a[i] 向 b[i] 连边，我们会得到若干个环（没有树枝，因为 a 和 b都是排列）。</p><p>对于长度大于 1 的环，如果不包含 d[i] &gt; 0的点，那么有两种选法。</p><p>比如 1-2-3-1 这个环，每条边可以分别选 1,2,3 也可以分别选 2,3,1。</p><p>所以答案就是 2<sup>m</sup>，其中 m 是长度大于 1 的不含 d[i]&gt;0的环的个数。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      cin &gt;&gt; a[j];<br>      a[j]--;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      cin &gt;&gt; b[j];<br>      b[j]--;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      cin &gt;&gt; d[j];<br>      d[j]--;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      <span class="hljs-keyword">if</span> (d[j] != <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span> (used[d[j]])&#123;<br>          ok = <span class="hljs-literal">false</span>;<br>        &#125;<br>        used[d[j]] = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!ok)&#123;<br>      cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">E</span>(n);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        E[a[j]].<span class="hljs-built_in">push_back</span>(b[j]);<br>        E[b[j]].<span class="hljs-built_in">push_back</span>(a[j]);<br>      &#125;<br>      <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>      <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used2</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        <span class="hljs-keyword">if</span> (!used2[j])&#123;<br>          used2[j] = <span class="hljs-literal">true</span>;<br>          queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>          Q.<span class="hljs-built_in">push</span>(j);<br>          <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>          <span class="hljs-type">bool</span> ok2 = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> v = Q.<span class="hljs-built_in">front</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            cnt++;<br>            <span class="hljs-keyword">if</span> (used[v])&#123;<br>              ok2 = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : E[v])&#123;<br>              <span class="hljs-keyword">if</span> (!used2[w])&#123;<br>                used2[w] = <span class="hljs-literal">true</span>;<br>                Q.<span class="hljs-built_in">push</span>(w);<br>              &#125;<br>            &#125;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (ok2 &amp;&amp; cnt &gt;= <span class="hljs-number">2</span>)&#123;<br>            ans *= <span class="hljs-number">2</span>;<br>            ans %= MOD;<br>          &#125;<br>        &#125;<br>      &#125;<br>      cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed">Wed</h2><p><a href="https://codeforces.com/problemset/problem/1725/M">MovingBoth Hands</a></p><p>输入 n(2≤n≤1e5) m(0≤m≤2e5)，表示一个 n 点 m 边的有向图。节点编号从 1开始。保证图中无自环和重边。<br>然后输入 m 条边，每条边输入 x y w(1≤w≤1e9)，表示一条从 x 到 y 的边权为 w的有向边。</p><p>定义 f(i) 为：有甲乙两人，分别从 1 和 i出发，到达同一个点，两人用时之和的最小值。如果两人无法到达同一个点，则f(i) = -1。<br>输出 f(2), f(3), ..., f(n)。</p><p>输入<br>5 7<br>1 2 2<br>2 4 1<br>4 1 4<br>2 5 3<br>5 4 1<br>5 2 4<br>2 1 1<br>输出<br>1 -1 3 4</p><p><strong>Sol:</strong></p><p>分层图最短路。</p><p>建图：把每条有向边及其反向边加到图中，用一个额外变量 inv表示这条边是否为反向边。</p><p>从 1 到 i 的路径分成两段：</p><p>从 1 到 x，走原图上的边。（记作状态 0）</p><p>从 x 到 i，走反向边。（记作状态 1）</p><p>由于到达每个节点时，都有两个状态，所以相当于在有 2n 个节点的图上跑Dijkstra 算法。</p><p><a href="https://leetcode.cn/problems/network-delay-time/solution/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/">Dijkstra算法介绍</a></p><p>类似状态机 DP，在 Dijkstra 的优先队列中，额外记录一个状态 inv，如果inv=0 表示当前在走原图上的边，如果 inv=1 表示当前在走反向边。</p><p>如果当前状态是 0，那么可以转移到 0 或者 1。</p><p>如果当前状态是 1，那么只能转移到 1。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt; &gt; &gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        adj[u].<span class="hljs-built_in">push_back</span>(&#123;v, w, <span class="hljs-number">0</span>&#125;);<br>        adj[v].<span class="hljs-built_in">push_back</span>(&#123;u, w, <span class="hljs-number">1</span>&#125;);<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> inf = <span class="hljs-number">1e18</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int64_t</span>&gt;&gt; <span class="hljs-built_in">dist</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int64_t</span>&gt;(<span class="hljs-number">2</span>, inf));<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">st</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    priority_queue&lt;tuple&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;tuple&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;tuple&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; hp;<br>    hp.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    dist[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!hp.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, x, rev] = hp.<span class="hljs-built_in">top</span>();<br>        hp.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (st[x][rev]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        st[x][rev] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [y, w, e] : adj[x]) &#123;<br>            <span class="hljs-keyword">if</span> (!rev) &#123;<br>                <span class="hljs-keyword">if</span> (dist[y][e] &gt; dist[x][<span class="hljs-number">0</span>] + w) &#123;<br>                    dist[y][e] = dist[x][<span class="hljs-number">0</span>] + w;<br>                    hp.<span class="hljs-built_in">emplace</span>(dist[y][e], y, e);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (dist[y][<span class="hljs-number">1</span>] &gt; dist[x][<span class="hljs-number">1</span>] + w &amp;&amp; e == <span class="hljs-number">1</span>) &#123;<br>                    dist[y][<span class="hljs-number">1</span>] = dist[x][<span class="hljs-number">1</span>] + w;<br>                    hp.<span class="hljs-built_in">emplace</span>(dist[y][<span class="hljs-number">1</span>], y, e);<br>                &#125;               <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        cout &lt;&lt; (<span class="hljs-built_in">min</span>(dist[i][<span class="hljs-number">0</span>], dist[i][<span class="hljs-number">1</span>]) == <span class="hljs-number">1e18</span> ? <span class="hljs-number">-1</span> : <span class="hljs-built_in">min</span>(dist[i][<span class="hljs-number">0</span>], dist[i][<span class="hljs-number">1</span>])) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu">Thu</h2><p><a href="https://codeforces.com/problemset/problem/582/B" class="uri">https://codeforces.com/problemset/problem/582/B</a></p><p>输入 n(1≤n≤100) t(1≤t≤1e7) 和长为 n 的数组 a(1≤a[i]≤300)。</p><p>把 t 个一样的数组 a 拼接在一起，得到长为 t*n 的数组 b，满足 b[i] =b[i+n]。<br>输出 b 的 LIS 长度。注意这里的 LIS 是非降的，允许元素相等。</p><p>输入<br>4 3<br>3 1 4 2<br>输出<br>5</p><p><strong>Sol:</strong></p><p><a href="https://www.bilibili.com/video/BV1ub411Q7sB/">贪心+二分求LIS</a></p><p>如果 t &lt;= n，那么直接求长为 tn 的数组的 LIS。也就是对数组 a 循环 t次。</p><p>如果 t &gt; n，只需要循环 n 次。</p><p>设最后一轮循环（第 n 轮循环）二分的数组 f 的长度增加了d，那么有如下结论：</p><p>接下来的 t-n 轮循环是不需要跑的，保证每轮循环 f 数组的长度都会增加d。</p><p>例如 a=[2,3,1]，前三轮循环，找到的 LIS 为 [2,3] [1,2,3] [1,1,2,3]</p><p>后面每轮循环都只会让 f 的长度增加 1。相当于每多一轮循环，中间就插入了一个 1。</p><p>猜想：只需要循环 sqrt(n) 左右次即可。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, t, d;<br>    cin &gt;&gt; n &gt;&gt; t;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    vi f;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n &amp;&amp; t &gt; <span class="hljs-number">0</span>; i++) &#123;<br>        <span class="hljs-type">int</span> m = f.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : a) &#123;<br>            <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">lower_bound</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), x + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (j != f.<span class="hljs-built_in">end</span>()) &#123;<br>                *j = x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>        &#125;<br>        d = f.<span class="hljs-built_in">size</span>() - m;<br>        t--;<br>    &#125;<br>    <span class="hljs-comment">//BUG(t);</span><br>    <span class="hljs-comment">//BUG(d);</span><br>    cout &lt;&lt; f.<span class="hljs-built_in">size</span>()+t*d &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri">Fri</h2><p><a href="https://codeforces.com/problemset/problem/1778/F">MaximizingRoot_848F</a></p><p>输入 T(≤5e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(2≤n≤1e5) k(0≤k≤n) 和长为 n 的数组 a(1≤a[i]≤1000)。<br>然后输入一棵无向树的 n-1 条边，节点编号从 1 开始。<br>根节点为 1。节点 i 的点权为 a[i]。</p><p>你可以执行如下操作至多 k 次：<br>选择一个没有操作过的节点 v 和一个整数 x，其中 x 必须满足 x 是子树 v中所有点权的公约数。然后把子树 v 中的每个点权都乘上 x。</p><p>输出操作后，a[1] 最大是多少。</p><p>输入<br>2<br>5 2<br>24 12 24 6 12<br>1 2<br>1 3<br>2 4<br>2 5<br>5 3<br>24 12 24 6 12<br>1 2<br>1 3<br>2 4<br>2 5<br>输出<br>288<br>576</p><p><strong>Sol</strong>:</p><p>提示1：为了让答案尽量大，从上到下操作比较好，还是从下到上操作比较好？</p><p>提示 2：答案一定是 a[1] 乘以它的一个因子。枚举这个因子 d。</p><p>提示 3：DFS这棵树，什么情况下，子树是不需要操作的？什么情况下，子树只需要操作一次？什么情况下，子树只需要操作两次？</p><p><a href="https://www.luogu.com.cn/article/c5cqkwpk">灵神题解</a></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">divisors</span>(mx<span class="hljs-number">+1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mx; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= mx; j+=i) &#123;<br>            divisors[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">ceilSqrt</span><span class="hljs-params">(mx<span class="hljs-number">+1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= mx; i++) &#123;<br>        ceilSqrt[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> x = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">2</span>; p*p &lt;= x; p++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p2 = p*p; x%p2 == <span class="hljs-number">0</span>; x /= p2) &#123;<br>                ceilSqrt[i] *= p;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x % p == <span class="hljs-number">0</span>) &#123;<br>                ceilSqrt[i] *= p;<br>                x /= p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) &#123;<br>            ceilSqrt[i] *= x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> n , t, k;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">g</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> v,w;<br>            cin &gt;&gt; v &gt;&gt; w;<br>            v--;<br>            w--;<br>            g[v].<span class="hljs-built_in">push_back</span>(w);<br>            g[w].<span class="hljs-built_in">push_back</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-function">vi <span class="hljs-title">subGcd</span><span class="hljs-params">(n)</span></span>;<br>        std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs0;<br>        dfs0 = [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span>&#123;<br>            subGcd[v] = a[v];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : g[v]) &#123;<br>                <span class="hljs-keyword">if</span> (w != fa) &#123;<br>                    <span class="hljs-built_in">dfs0</span>(w, v);<br>                    subGcd[v] = <span class="hljs-built_in">gcd</span>(subGcd[v], subGcd[w]);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs0</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> cnt;<br>        std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs;<br>        dfs = [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> d) -&gt; <span class="hljs-type">void</span> &#123;<br>            <span class="hljs-keyword">if</span> (subGcd[v] % d == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (subGcd[v]*subGcd[v]%d == <span class="hljs-number">0</span>) &#123;<br>                cnt++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (g[v].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> || a[v]*a[v]%d &gt; <span class="hljs-number">0</span>) &#123;<br>                cnt = <span class="hljs-number">1e9</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> w : g[v]) &#123;<br>                <span class="hljs-keyword">if</span> (w != fa) &#123;<br>                    <span class="hljs-built_in">dfs</span>(w, v, ceilSqrt[d]);<br>                &#125;<br>            &#125;<br>            cnt++;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : divisors[a[<span class="hljs-number">0</span>]]) &#123;<br>            cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-built_in">dfs</span>(v, <span class="hljs-number">0</span>, d);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt; k) &#123;<br>                cout &lt;&lt; a[<span class="hljs-number">0</span>]*d &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="codeforces" scheme="http://polaris3003.github.io/categories/codeforces/"/>
    
    
    <category term="数据结构" scheme="http://polaris3003.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://polaris3003.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="广度优先搜索（BFS）" scheme="http://polaris3003.github.io/tags/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89/"/>
    
    <category term="环检测" scheme="http://polaris3003.github.io/tags/%E7%8E%AF%E6%A3%80%E6%B5%8B/"/>
    
    <category term="模运算" scheme="http://polaris3003.github.io/tags/%E6%A8%A1%E8%BF%90%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture8</title>
    <link href="http://polaris3003.github.io/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
    <id>http://polaris3003.github.io/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/</id>
    <published>2024-07-04T12:47:51.000Z</published>
    <updated>2025-02-11T09:24:54.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第八课树索引">第八课：树索引</h1><h2 id="表索引">1 表索引</h2><p>数据库系统内部可以使用多种不同的数据结构，例如内部元数据、核心数据存储、临时数据结构或表索引。对于可能设计范围扫描查询的表索引，哈希表可能不是最佳选择，因为它本质上是无序的。</p><p>表索引是表列子集的副本，它被组织和/或排序以便使用这些属性的子集进行有效访问。因此，DBMS可以对表索引执行查找，以更快地找到某些元组，而不是执行顺序扫描。DBMS确保表和索引的内容始终在逻辑上同步。</p><p>每个数据库创建的索引数量之间存在权衡。虽然索引越多查询速度越快，但索引也会占用内存并且需要维护。另外，保持它们同步还存在并发问题。DBMS的工作是找出用于执行查询的最佳索引。</p><h2 id="b树">2 B+树</h2><p>B+树是一种自平衡树数据结构，可保持数据排序并允许在O(log(n))中进行搜索、顺序访问、插入和删除。它针对读取/写入大数据块的面向磁盘的DBMS进行了优化。</p><p>几乎每个支持保序索引的现代DBMS都使用B+树。有种特殊的数据结构叫做B-树，但人们也使用该术语来泛指一类数据结构。原始B-Tree和B+Tree之间的主要区别在于B-Tree在所有节点中存储键和值，而B+树仅在叶节点中存储值。现代B+Tree 实现结合了其他 B-Tree 变体的功能，例如 B链接树中使用的同级指针。</p><p><img src="/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/image-20240702174422330.png" alt="B+树形图" style="zoom:50%;"></p><p>形式上，B+Tree 是一棵 M 路搜索树（其中 M表示节点可以拥有的子节点的最大数量），具有以下属性：</p><ul><li>它是完美平衡的（所有叶子结点都是同一个深度）。</li><li>除根节点外的每个内部节点都至少是半满的（M/2 - 1 &lt;= 键数 &lt;=M-1)。</li><li>每个有k个键的内部节点有k+1个非空子节点。</li></ul><p>B+Tree 中的每个节点都包含一个键/值对数组。</p><p>对于叶节点，键是从索引所基于的属性派生的。虽然根据 B+Tree的定义没有必要，但每个节点的数组几乎总是按键排序。叶节点值的两种方法是记录ID 和元组数据。记录 ID是指指向元组位置的指针，通常是主键。具有元组数据的叶节点存储每个节点中元组的实际内容。</p><p>对于内部节点，值包含指向其他节点的指针，并且键可以被认为是指南针。它们引导树遍历，但不表示叶节点上的键（以及它们的值）。这意味着您可能在内部节点（作为指南）中有一个在叶节点上找不到的键。尽管必须注意，传统上内部节点仅拥有叶节点中存在的那些键。</p><p>根据索引类型（首先为 NULL，最后为NULL），空键将聚集在第一个叶节点或最后一个叶节点中。</p><h3 id="插入">插入</h3><p>要在 B+Tree中插入新条目，必须遍历树并使用内部节点来找出要将键插入到哪个叶节点。</p><ol type="1"><li>找到正确的叶子L</li><li>按排序顺序将新条目添加到 L 中：<ul><li>如果L有足够空间，则操作完成。</li><li>否则将叶子分为两个节点L和L2。均匀地重新分配条目并复制中间键。将指向L2 的条目插入到 L 的父级中。</li></ul></li><li>要分割内部节点，请均匀地重新分配条目，但向上推中间键。</li></ol><h3 id="删除">删除</h3><p>在插入中，当树太满时，我们有时不得不分割叶子，如果删除导致树小于半满，我们必须合并以重新平衡树。</p><ol type="1"><li>找到正确的叶子L</li><li>删除条目：<ul><li>如果 L 至少为半满，则操作完成。</li><li>否则，您可以尝试从兄弟姐妹那里借用来重新分配。</li><li>如果重新分配失败，则合并 L 和同级。</li></ul></li><li>如果发生合并，则必须删除父项中指向 L 的条目。</li></ol><h3 id="选型条件">选型条件</h3><p>由于 B+Tree是按顺序排序的，因此查找遍历速度很快，并且不需要整个键。如果查询提供搜索键的任何属性，则DBMS 可以使用 B+Tree索引。这与哈希索引不同，哈希索引需要搜索键中的所有属性。</p><p><img src="/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/image-20240702193242102.png" alt="图2:要在 B+Tree 上执行前缀搜索，需要查看键上的第一个属性，沿着路径向下并在叶子上执行顺序扫描，以找到所需的所有键。"></p><h3 id="复制键">复制键</h3><p>有两种方法可以在 B+Tree 中复制键。</p><p>第一种方法是附加记录 ID 作为键的一部分。由于每个元组的记录 ID都是唯一的，这将确保所有键都是可识别的。</p><p>第二种方法是允许叶节点溢出到包含重复键的溢出节点。虽然没有存储冗余信息，但这种方式维护和修改比较复杂</p><h3 id="聚集索引">聚集索引</h3><p>表按主键指定的排序顺序存储，作为堆或索引组织的存储。由于某些 DBMS始终使用聚集索引，因此如果表没有显式主键，它们会自动创建隐藏的 row id主键，但其他 DBMS 根本无法使用它们。</p><h3 id="堆聚类">堆聚类</h3><p>元组按照聚类索引指定的顺序在堆页中排序。如果使用聚簇索引的属性来访问元组，DBMS可以直接跳转到页面。</p><h3 id="索引扫描页面排序">索引扫描页面排序</h3><p>由于直接从非聚集索引检索元组效率很低，因此 DBMS可以首先找出它需要的所有元组，然后根据它们的页 id对它们进行排序。这样，每个页面只需提取一次。</p><h2 id="b树设计选择">3 B+树设计选择</h2><h3 id="节点大小">3.1 节点大小</h3><p>根据存储介质的不同，我们可能更喜欢更大或更小的节点大小。例如，存储在硬盘驱动器上的节点的大小通常约为兆字节，以减少查找数据所需的查找次数并分摊读取大量数据所需的昂贵磁盘成本，而内存数据库可能使用小至512 字节的页面大小，以便将整个页面放入 CPU缓存并减少数据碎片。这个选择还可以依赖于工作负载的类型。对于点查询而言，它会更喜欢尽可能小的页面，以减少加载不必要的额外信息的数量，而对于大规模顺序扫描而言，它可能更喜欢大页面以减少需要执行的获取次数。</p><h3 id="合并阈值">3.2 合并阈值</h3><p>虽然 B+Tree有删除后合并下溢节点的规则，但有时暂时违反该规则可能会有益于减少删除操作的次数。例如，急于合并可能会导致抖动，其中大量连续的删除和插入操作会导致不断的拆分和合并。它还允许批量合并，其中多个合并操作同时发生，从而减少了在树上花费昂贵的写入锁存器的时间。</p><p>有一些合并策略会保留树中的小节点并在以后重建它，这使得树不平衡（如在Postgres 中）。我们不会在课上讨论这个问题。</p><h3 id="可变长密钥">3.3 可变长密钥</h3><p>目前我们只讨论了具有固定长度键的B+树。然而，我们可能还希望支持可变长度密钥，例如大密钥的一小部分子集导致大量空间浪费的情况。有几种方法可以做到这一点：</p><ol type="1"><li><p><strong>指针</strong></p><p>我们可以只存储指向键的指针，而不是直接存储键。</p></li><li><p><strong>可变长节点</strong></p><p>我们还可以像平常一样存储密钥并允许可变长度节点。由于处理可变长度节点的内存管理开销很大，这通常是不可行的并且基本上不被使用。</p></li><li><p><strong>填充</strong></p><p>我们可以将每个键的大小设置为最大键的大小，并填充所有较短的键，而不是改变键的大小。在大多数情况下，这是对内存的巨大浪费，因此也看不到任何人使用它。</p></li><li><p><strong>键映射/间接</strong></p><p>几乎每个人都使用的方法是将键替换为单独字典中键值对的索引。这提供了显着的空间节省和潜在的快捷点查询（因为索引指向的键值对与叶节点指向的键值对完全相同）。由于字典索引值的大小较小，可以在索引的旁边放置每个键的前缀，这样在索引搜索和叶节点扫描时，如果前缀与搜索键不完全相同，可能并不需要追踪指针。</p></li></ol><p><img src="/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/image-20240703155322520.png" alt="图3:键映射/间接的示例。该映射存储键的一个小前缀，以及指向键值对的指针。"></p><h3 id="节点内搜索">3.4 节点内搜索</h3><p>一旦我们到达一个节点，我们仍然需要在该节点内搜索（要么从内部节点找到下一个节点，要么在叶节点中找到我们的键值）。虽然这相对简单，但仍然需要考虑一些权衡：</p><ol type="1"><li><p><strong>线性</strong></p><p>最简单的解决方案是扫描节点中的每个键，直到找到我们的键。一方面，我们不必担心对键进行排序，从而使插入和删除速度更快。另一方面，这是相对低效的，并且每次搜索的复杂度为O(n)。这可以使用 SIMD（或等效）指令进行矢量化。</p></li><li><p><strong>二分</strong></p><p>更有效的搜索解决方案是保持每个节点排序并使用二分搜索来查找键。这就像跳转到节点中间并根据键之间的比较向左或向右旋转一样简单。这种方式的搜索效率要高得多，因为这种方法每次搜索的复杂度仅为O(ln(n))。然而，插入变得更加昂贵，因为我们必须维护每个节点的排序。</p></li><li><p><strong>插值法</strong></p><p>这种方式的搜索效率要高得多，因为这种方法每次搜索的复杂度仅为O(ln(n))。然而，插入变得更加昂贵，因为我们必须维护每个节点的排序。此方法利用存储的有关节点的任何元数据（例如最大元素、最小元素、平均值等），并使用它来生成键的大致位置。例如，如果我们在节点中查找8，并且我们知道 10 是最大键，10−(n+ 1) 是最小键（其中 n是每个节点中键的数量），那么我们知道从最大键开始向下搜索 2个槽，因为在这种情况下，距离最大键 1 个槽的键必须是9。尽管这是我们给出的最快的方法，但由于它对具有某些属性（如整数）和复杂性的密钥的适用性有限，因此该方法仅在学术数据库中出现。</p></li></ol><h2 id="优化">4 优化</h2><h3 id="指针swizzling">4.1 指针swizzling</h3><p>因为B+Tree的每个节点都存储在缓冲池中的一个页面中，所以每次加载新页面时，我们都需要从缓冲池中获取它，需要锁存和查找。要完全跳过此步骤，我们可以存储实际的原始指针来代替页面ID（称为“swizzling”），从而完全防止缓冲池获取。我们可以在正常遍历索引时简单地存储页面查找的结果指针，而不是手动获取整个树并手动放置指针。请注意，我们必须跟踪哪些指针被混合，并在它们指向的页面被取消固定和受害时将它们解调回页面ID。</p><h3 id="批量插入">4.2 批量插入</h3><p>当 B+Tree最初构建时，必须以通常的方式插入每个键将导致不断的分裂操作。由于我们已经给出了叶子同级指针，因此如果我们构造叶节点的排序链表，然后使用每个叶节点的第一个键从下往上轻松构建索引，则数据的初始插入会更有效。请注意，根据我们的上下文，我们可能希望尽可能紧密地包装叶子以节省空间，或者在每个叶子中留出空间，以便在需要分割之前允许更多插入。</p><h3 id="前缀压缩">4.3 前缀压缩</h3><p>大多数时候，当我们在同一个节点中拥有键时，每个键的某些前缀都会有部分重叠（因为相似的键最终会在排序的B+Tree中紧邻彼此）。我们可以简单地将前缀存储在节点的开头一次，然后只在每个槽中包含每个键的唯一部分，而不是多次将此前缀存储为每个键的一部分。</p><p><img src="/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/image-20240703162033096.png" alt="图 4：前缀压缩的示例。由于键按字典顺序排列，因此它们可能共享一些前缀。"></p><h3 id="删除重复数据">4.4 删除重复数据</h3><p>在允许非唯一键的索引的情况下，我们最终可能会得到包含相同键并附加不同值的叶节点。对此的一种优化可能是只写入一次密钥，然后在其后面写入所有关联的值。</p><h3 id="后缀截断">4.5 后缀截断</h3><p>大多数情况下，内部节点中的键条目仅用作路标，而不是其实际键值（即使索引中存在某个键，我们仍然必须搜索到底部以确保它没有被删除）。我们可以通过仅存储将探测器正确路由到正确节点所需的最小前缀来利用这一点。</p><h3 id="写入优化的-b-树">4.6 写入优化的 B+ 树</h3><p>拆分/合并节点操作的成本很高。因此，B-Tree 的某些变体（例如Bε-Tree）会记录内部节点中的更改，并稍后将更新向下传播到叶节点。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="B+树" scheme="http://polaris3003.github.io/tags/B-%E6%A0%91/"/>
    
    <category term="表索引" scheme="http://polaris3003.github.io/tags/%E8%A1%A8%E7%B4%A2%E5%BC%95/"/>
    
    <category term="插入" scheme="http://polaris3003.github.io/tags/%E6%8F%92%E5%85%A5/"/>
    
    <category term="删除" scheme="http://polaris3003.github.io/tags/%E5%88%A0%E9%99%A4/"/>
    
    <category term="选型条件" scheme="http://polaris3003.github.io/tags/%E9%80%89%E5%9E%8B%E6%9D%A1%E4%BB%B6/"/>
    
    <category term="复制键" scheme="http://polaris3003.github.io/tags/%E5%A4%8D%E5%88%B6%E9%94%AE/"/>
    
    <category term="聚集索引" scheme="http://polaris3003.github.io/tags/%E8%81%9A%E9%9B%86%E7%B4%A2%E5%BC%95/"/>
    
    <category term="堆聚类" scheme="http://polaris3003.github.io/tags/%E5%A0%86%E8%81%9A%E7%B1%BB/"/>
    
  </entry>
  
  <entry>
    <title>茶7.1-7.5</title>
    <link href="http://polaris3003.github.io/2024/07/01/%E8%8C%B67.1-7.5/"/>
    <id>http://polaris3003.github.io/2024/07/01/%E8%8C%B67.1-7.5/</id>
    <published>2024-07-01T07:44:51.000Z</published>
    <updated>2025-02-11T09:24:38.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶7.1-7.5">茶7.1-7.5</h1><h2 id="mon.">Mon.</h2><p><a href="https://codeforces.com/problemset/problem/1840/D">Wooden ToyFestival_878D</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>一条街道上有 n 个工厂，第 i 个工厂的位置是 a[i]。<br>你需要建造 3 个仓库，仓库的位置由你决定，必须是整数。<br>每个工厂生产的物品要运到离其最近的仓库。</p><p>定义 d(i) = 第 i 个工厂到离其最近的仓库的距离。<br>设 M = 所有 d(i) 的最大值。<br>最小化 M，也就是最小化最大的工厂到仓库的距离。</p><p>输入<br>5<br>6<br>1 7 7 9 9 9<br>6<br>5 4 2 1 30 60<br>9<br>14 19 37 59 1 4 4 98 73<br>1<br>2<br>6<br>3 10 1 17 15 11<br>输出<br>0<br>2<br>13<br>0<br>1<br>解释<br>样例 1：在 1,7,9 处建仓库，最远距离为 0。<br>样例 2：在 3,30,60 处建仓库，最远距离为 2。<br>样例 3：在 14,50,85 处建仓库，最远距离为 13。</p><p><strong>Sol:</strong></p><p>二分答案+贪心。</p><p>把 a 从小到大排序。</p><p>设答案为 m，那么第一段（第一个仓库对应的工厂）的范围是 [a[0],a[0]+2m]，</p><p>二分找 a 中第一个大于 a[0]+2m 的数 a[i]，那么第二段的范围是 [a[i],a[i]+2m]。</p><p>继续二分，找 a 中第一个大于 a[i]+2m 的数 a[j]，那么第三段的范围是[a[j], a[j]+2m]。</p><p>如果 a[j]+2m &gt;= a[n-1]，那么 check 是 true，否则是 false。 注意i=n 和 j=n 的情况。</p><p>二分上界：可以直接写 1e9 或者 a[n-1]-a[0]，下面讨论更精细的上界。</p><p>假设答案 x 一定成立，那么极限情况下第一段是 [a0, a0+2x]，第二段是[a0+2x+1, a0+4x+1]，第三段是 [a0+4x+2, a0+6x+2]，所以有 a[0]+6x+2 &lt;=a[n-1]</p><p>解得 x &gt;= ceil((a[n-1]-a[0]-2) / 6) = floor((a[n-1]-a[0]+3) /6)</p><p>所以（开区间的）二分上界是 floor((a[n-1]-a[0]+3) / 6)。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=(a[n<span class="hljs-number">-1</span>] - a[<span class="hljs-number">0</span>] + <span class="hljs-number">3</span>) / <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i<span class="hljs-number">+1</span>&lt;a.<span class="hljs-built_in">size</span>()&amp;&amp;a[i<span class="hljs-number">+1</span>]-a[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">2</span>*m)&#123;<br>            ++i;<br>        &#125;<br>        <span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;a.<span class="hljs-built_in">back</span>()-a[j<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">2</span>*m)&#123;<br>            --j;<br>        &#125;<br>        ++i;--j;<br>        <span class="hljs-keyword">if</span> (i &gt; j || a[j] - a[i] &lt;= <span class="hljs-number">2</span> * m) &#123;<br>            r = m;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = m;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;r&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue">Tue</h2><p><a href="https://codeforces.com/problemset/problem/1903/C">Theofanis'Nightmare_912C</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤1e5) 和长为 n 的数组 a(-1e8≤a[i]≤1e8)。</p><p>你需要把 a 分割成若干非空段，假设分割成了 k 段，那么得分为：<br>第一段的元素和 * 1 + 第二段的元素和 * 2 + ... + 第 k 段的元素和 * k</p><p>例如 [1,2,3,4] 分成两段 [1,2] 和 [3,4]，得分为<br>(1+2) * 1 + (3+4) * 2</p><p>输出最大得分。</p><p>输入<br>4<br>6<br>1 -3 7 -6 2 5<br>4<br>2 9 -5 -3<br>8<br>-3 -4 2 -5 1 10 17 23<br>1<br>830<br>输出<br>32<br>4<br>343<br>830</p><p><strong>Sol:</strong></p><p>等价转换。</p><p>和式可以视作 a 的若干后缀和之和。</p><p>例如 [1,2,3,4] 分成两段 [1,2] 和 [3,4]，得分为</p><p>(1+2) * 1 + (3+4) * 2 = (1+2+3+4) + (3+4)</p><p>所以计算 a 的所有后缀和，取其中大于 0的后缀和相加，即为答案。注意整个数组的和一定要加进答案。</p><p>注意用 64 位整数。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    ll ans = <span class="hljs-number">0</span>;<br>    ll s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        s += a[i];<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || s &gt; <span class="hljs-number">0</span>) &#123;<br>            ans += s;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed">Wed</h2><p><a href="https://codeforces.com/problemset/problem/1849/D" class="uri">https://codeforces.com/problemset/problem/1849/D</a></p><p>输入 n(1≤n≤2e5) 和长为 n 的数组 a(0≤a[i]≤2)。</p><p>最初，数组的每个元素都是蓝色的。<br>有两种类型的操作：<br>- 支付一枚硬币，选择一个蓝色元素，将其涂成红色。<br>- 选择一个不等于 0 的红色元素和与其相邻的蓝色元素，将红色元素的数值减少1，然后将蓝色元素涂成红色。<br>把每个元素都涂成红色，最少要支付多少金币？</p><p>输入<br>3<br>0 2 0<br>输出 1</p><p>输入<br>4<br>0 0 1 1<br>输出 2</p><p>输入<br>7<br>0 1 0 0 1 0 2<br>输出 4</p><p><strong>Sol:</strong></p><p><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solution/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-zuspx/">分组循环</a>+贪心。</p><p>内层循环寻找非 0 的段（连续子数组）。</p><p>对于非 0 的段（下标从 i 到 j），把端点 i 或者 j涂成红色后，最终整个段都会变成红色。 如果段中没有 2，那么 i-1 或者 j+1会变成红色，取决于一开始涂的是哪个端点。</p><p>贪心来说，优先把左边的变成红色，即如果 i&gt;0 且 i-1 不是红色，那么把i-1 变成红色，否则把 j+1 变成红色。</p><p>如果段中有 2，那么把 2 涂成红色，最终 i-1 和 j+1 都会变成红色。</p><p>答案为段的个数，加上最后剩下的蓝色 0 的个数。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span>) &#123;<br>            ans++;<br>            i++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> st = i;<br>        <span class="hljs-type">bool</span> h2 = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(; i &lt; n &amp;&amp; a[i]&gt;<span class="hljs-number">0</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">2</span>) &#123;<br>                h2=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        ans++;<br>        <span class="hljs-keyword">if</span> (st&gt;<span class="hljs-number">0</span> &amp;&amp; a[st<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>) &#123;<br>            ans--;<br>            <span class="hljs-keyword">if</span> (!h2) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>            a[i] = <span class="hljs-number">1</span>;<br>            i++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu">Thu</h2><p><a href="https://codeforces.com/problemset/problem/455/C">Civilization_260C</a></p><p>输入 n m(0≤m&lt;n≤3e5) 和 q(1≤q≤3e5)。<br>然后输入一个森林的 m 条边。注：森林由多棵树组成。<br>然后输入 q 个询问，格式如下：<br>"1 x"：输出节点 x 所在的树的直径。<br>"2 x y"：如果节点 x 和节点 y在同一棵树，什么也不做；否则在这两棵树之间连一条边，要求连边后，得到的新树的直径最小。<br>所有输入的节点编号均从 1 开始。</p><p>输入<br>6 0 6<br>2 1 2<br>2 3 4<br>2 5 6<br>2 3 2<br>2 5 3<br>1 1<br>输出<br>4</p><p><strong>Sol:</strong></p><p>在 <a href="https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/solutions/2826587/lian-jie-zhi-jing-zhong-dian-pythonjavac-0e1c/">周赛第四题</a>的基础上，套一个带权并查集。</p><p>初始化：跑树形 DP 的同时，把树上的每个节点 x 和根节点 i合并。在根节点 i 处记录直径信息 d[i]。</p><p>合并：按照周赛第四题的做法更新直径，如果要把 y 合并到 x 上，那么更新d[x] = max(d[x], d[y], (d[x]+1)/2+(d[y]+1)/2+1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> inf = numeric_limits&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;::<span class="hljs-built_in">max</span>();<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dsu</span><br>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; fa, siz;<br>    <span class="hljs-built_in">dsu</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-built_in">init</span>(n);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        fa.<span class="hljs-built_in">resize</span>(n);<br>        siz.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            fa[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> t = x;<br>        <span class="hljs-keyword">while</span> (fa[x] != x)<br>        &#123;<br>            x = fa[x];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (t != x)<br>        &#123;<br>            <span class="hljs-type">int</span> p = t;<br>            fa[p] = x;<br>            t = fa[t];<br>        &#125;<br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> root1 = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> root2 = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (root1 != root2)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (root1 &lt; root2)<br>            &#123;<br>                fa[root2] = root1;<br>                siz[root2] += siz[root1];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                fa[root1] = root2;<br>                siz[root1] += siz[root2];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> root = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">return</span> siz[root];<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-function">dsu <span class="hljs-title">dsu</span><span class="hljs-params">(n<span class="hljs-number">+1</span>)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a].<span class="hljs-built_in">pb</span>(b);<br>        g[b].<span class="hljs-built_in">pb</span>(a);<br>        dsu.<span class="hljs-built_in">merge</span>(a, b);<br>    &#125;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt; &gt; <span class="hljs-built_in">st</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        dis[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> bfs = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">int</span><br>    &#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<br>        st[x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(x, <span class="hljs-number">0</span>));<br>        pair&lt;ll, ll&gt; tag = <span class="hljs-built_in">make_pair</span>(-inf, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t = pq.<span class="hljs-built_in">front</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> a = t.first, dis = t.second;<br>            <span class="hljs-keyword">if</span> (dis &gt; tag.first)<br>            &#123;<br>                tag.first = dis;<br>                tag.second = a;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : g[a])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (st[b][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    st[b][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(b, dis + <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        ll ans = -inf;<br>        st[tag.second][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(tag.second, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t = pq.<span class="hljs-built_in">front</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            ll a = t.first, dis = t.second;<br>            ans = <span class="hljs-built_in">max</span>(ans, dis);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : g[a])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (st[b][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    st[b][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>                    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(b, dis + <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>        &#123;<br>            dis[i] = <span class="hljs-built_in">bfs</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// for (int i = 1; i &lt;= n; i++)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; i &lt;&lt; &quot; this dis &quot; &lt;&lt; dis[i] &lt;&lt; endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">while</span> (q--)<br>    &#123;<br>        <span class="hljs-type">int</span> t;<br>        cin &gt;&gt; t;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            cout &lt;&lt; dis[dsu.<span class="hljs-built_in">find</span>(x)] &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-keyword">if</span> (!dsu.<span class="hljs-built_in">same</span>(x, y))<br>            &#123;<br>                <br>                <span class="hljs-type">int</span> fa1 = dsu.<span class="hljs-built_in">find</span>(x);<br>                <span class="hljs-type">int</span> fa2 = dsu.<span class="hljs-built_in">find</span>(y);<br>                <span class="hljs-type">int</span> d1 = dis[fa1];<br>                <span class="hljs-type">int</span> d2 = dis[fa2];<br>                dsu.<span class="hljs-built_in">merge</span>(x, y);<br>                <span class="hljs-type">int</span> d = <span class="hljs-built_in">max</span>(&#123;d1, d2, (d1 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + (d2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;);<br>                <span class="hljs-keyword">if</span> (fa1 &lt; fa2)<br>                &#123;<br>                    dis[fa1] = d;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dis[fa2] = d;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri">Fri</h2><p><a href="https://codeforces.com/problemset/problem/633/F">TheChocolate Spree</a></p><p>输入 n(2≤n≤1e5) 和长为 n 的数组a(1≤a[i]≤1e9)，表示每个节点的点权。<br>然后输入一棵树的 n-1 条边，节点编号从 1 开始。</p><p>你需要从这棵树中，选出两条不相交的路径，也就是没有节点会同时出现在两条路径中。<br>输出这两条路径的节点点权之和的最大值。</p><p>输入<br>9<br>1 2 3 4 5 6 7 8 9<br>1 2<br>1 3<br>1 4<br>1 5<br>1 6<br>1 7<br>1 8<br>1 9<br>输出 25</p><p>输入<br>2<br>20 10<br>1 2<br>输出 30</p><p><strong>Sol:</strong></p><p>如果只有一条路径，做法类似求 <a href="https://www.bilibili.com/video/BV17o4y187h1/">树的直径</a>，把路径分解成左右两条链，dfs 返回从叶子到当前节点的最长链。</p><p><strong>方法一：两次 DFS（换根 DP）</strong></p><p>提示：枚举边，删除这条边，把这棵树一分为二，每部分只需要计算一条最大路径和。</p><p>分类讨论：</p><p>如果两条路径分别在两棵不相交子树中，那么做法和求直径是一样的，设当前节点为v，维护前面遍历的 v的儿子子树的最大路径和，加上当前儿子子树的最大路径和。</p><p>dfs 除了返回最长链，还要返回子树最大路径和。</p><p>如果两条路径分别在两棵相交子树中，考虑换根 DP，一条路径在子树 w中，另一条路径从 v 开始的以下三条链中选两条：</p><p>v - w1 子树中的最长链（其中 w1 != w）</p><p>v - w2 子树中的最长链（其中 w2 != w）</p><p>v - 从父节点过来的最长链（在换根的过程中计算）</p><p><a href="https://codeforces.com/problemset/submission/633/268735935">代码一</a></p><p><strong>方法二：一次 DFS</strong></p><p>如右图所示，下文把： 从叶子往上到 v 的路径称作「链」。</p><p><img src="/2024/07/01/%E8%8C%B67.1-7.5/image-20240705143418240.png" alt="dfs"></p><p>由两条链拼成的路径叫做「路」。</p><p>由链 + 路组成的复合结构叫做「链路」。</p><p>注意链路中的链和路不一定在一起，可能间隔很远。</p><p>分类讨论，遍历 v 的子树列表时，假设当前遍历到子树 w，得到其「w链」「w 路」「w 链路」，同时维护遍历过的子树的「最大链」「含 v最大路」「不含 v 最大路」「最大链路」。其中「最大链」「最大链路」已经把a[v] 算进去了。</p><p>如图，答案是以下三种情况的最大值： <img src="/2024/07/01/%E8%8C%B67.1-7.5/image-20240705143402152.png" alt="dfs"></p><p>max(含 v 最大路, 不含 v 最大路) + w 路</p><p>最大链 + w 链路</p><p>最大链路 + w 链</p><p>其中「最大链路」是以下三种情况的最大值：</p><p>w 链路 + a[v]</p><p>不含 v 最大路 + w 链 + a[v]</p><p>最大链 + w 路</p><p>注意链路这一复合结构，一定是链在上，路在下，不然无法往上加点。不能是【含 v 最大路 + w 链】。</p><p>这也是为什么我们要区分这两种最大路。</p><p>含 v 最大路的计算方式同直径，取最大链 + w 链的最大值。</p><p>而最大链又是 w 链 + a[v] 的最大值。注意变量更新的顺序。</p><p>不含 v 最大路是 w 路的最大值。</p><p><a href="https://codeforces.com/problemset/submission/633/268854936">代码二</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, ans = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; g;<br><span class="hljs-function">tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-type">int</span> val = a[v];<br>    <span class="hljs-type">int</span> maxChain = val;<br>    <span class="hljs-type">int</span> maxPathV = val;<br>    <span class="hljs-type">int</span> maxPathW = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxChainPath = val;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : g[v]) &#123;<br>        <span class="hljs-keyword">if</span> (w == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">auto</span> [chainW, pathW, chainPathW] = <span class="hljs-built_in">dfs</span>(w, v);<br>        ans = <span class="hljs-built_in">max</span>(&#123;ans, maxPathV + pathW, maxPathW + pathW, maxChain + chainPathW, maxChainPath + chainW&#125;);<br>        maxChainPath = <span class="hljs-built_in">max</span>(&#123;maxChainPath, chainPathW + val, maxPathW + chainW + val, maxChain + pathW&#125;);<br>        maxPathV = <span class="hljs-built_in">max</span>(maxPathV, maxChain + chainW);<br>        maxPathW = <span class="hljs-built_in">max</span>(maxPathW, pathW);<br>        maxChain = <span class="hljs-built_in">max</span>(maxChain, chainW + val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;maxChain, <span class="hljs-built_in">max</span>(maxPathV, maxPathW), maxChainPath&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    a.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    g.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        --v; --w;<br>        g[v].<span class="hljs-built_in">push_back</span>(w);<br>        g[w].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="codeforces" scheme="http://polaris3003.github.io/categories/codeforces/"/>
    
    
    <category term="数据结构" scheme="http://polaris3003.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    <category term="图论" scheme="http://polaris3003.github.io/tags/%E5%9B%BE%E8%AE%BA/"/>
    
    <category term="贪心算法" scheme="http://polaris3003.github.io/tags/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
    
    <category term="二分查找" scheme="http://polaris3003.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
    <category term="DFS（深度优先搜索）" scheme="http://polaris3003.github.io/tags/DFS%EF%BC%88%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%89/"/>
    
    <category term="树形DP" scheme="http://polaris3003.github.io/tags/%E6%A0%91%E5%BD%A2DP/"/>
    
    <category term="并查集" scheme="http://polaris3003.github.io/tags/%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    
    <category term="最短路径" scheme="http://polaris3003.github.io/tags/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
    
    <category term="动态规划" scheme="http://polaris3003.github.io/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    
    <category term="分治法" scheme="http://polaris3003.github.io/tags/%E5%88%86%E6%B2%BB%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture7</title>
    <link href="http://polaris3003.github.io/2024/07/01/%E7%AC%AC%E4%B8%83%E8%AF%BE%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <id>http://polaris3003.github.io/2024/07/01/%E7%AC%AC%E4%B8%83%E8%AF%BE%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</id>
    <published>2024-07-01T06:30:51.000Z</published>
    <updated>2025-02-11T09:25:10.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第七课哈希表">第七课：哈希表</h1><h2 id="数据结构">1 数据结构</h2><p>DBMS 对系统内部的许多不同部分使用各种数据结构。一些例子包括：</p><ul><li><strong>内部元数据：</strong>这是跟踪有关数据库和系统状态的信息的数据。比如：页表，页目录</li><li><strong>核心数据存储：</strong>数据结构用作数据库中元组的基础存储。</li><li><strong>临时数据结构：</strong>DBMS可以在处理查询时动态构建临时数据结构以加速执行（例如，用于连接的哈希表）。</li><li><strong>表索引：</strong>辅助数据结构可用于更轻松地查找特定元组。</li></ul><p>在实现DBMS的数据结构时，需要考虑两个主要的设计决策：</p><ol type="1"><li>数据组织：我们需要弄清楚如何布局存储以及在数据结构内存储哪些信息以支持高效访问。</li><li>并发性：我们还需要思考如何让多个线程访问数据结构而不引起问题，确保数据保持正确和健全。</li></ol><h2 id="哈希表">2 哈希表</h2><p>哈希表实现了将键映射到值的关联数据抽象数据类型。它平均提供O（1）操作复杂度（最坏情况下为O（n））和O（n）存储复杂度。请注意，即使平均操作复杂度为O（1），在现实世界中也存在需要考虑的常数因子优化。</p><p>哈希表实现由两个方面组成：</p><ul><li><strong>哈希函数：</strong>这告诉我们如何将大的密钥空间映射到更小的域中。它用于计算存储桶或槽数组的索引。我们需要考虑快速执行和冲突率之间的权衡。在一个极端，我们有一个哈希函数，它总是返回一个常量（非常快，但一切都是冲突）。在另一个极端，我们有一个“完美”的哈希函数，没有冲突，但需要很长时间才能计算。理想的设计是介于两者之间。</li><li><strong>哈希方案：</strong>这告诉我们如何处理哈希后的密钥冲突。在这里，我们需要考虑分配一个大的哈希表以减少冲突和在发生冲突时必须执行额外的指令之间的权衡</li></ul><h2 id="哈希函数">3 哈希函数</h2><p>哈希函数接受任何键作为其输入。然后它返回该键的整数表示（即“哈希”）。该函数的输出是确定性的（即相同的密钥应始终生成相同的哈希输出）。</p><p>DBMS 不需要使用加密安全哈希函数（例如SHA-256），因为我们不需要担心保护密钥内容。这些哈希函数主要由 DBMS内部使用，因此信息不会泄漏到系统外部。一般来说，我们只关心哈希函数的速度和碰撞率。</p><p>目前最先进的哈希函数是 Facebook XXHash3。</p><h2 id="静态哈希方案">4 静态哈希方案</h2><p>静态哈希方案是哈希表大小固定的一种方案。这意味着如果DBMS耗尽了哈希表中的存储空间，那么它必须从头开始重建更大的哈希表，这是非常昂贵的。通常新哈希表的大小是原始哈希表的两倍。</p><p>为了减少浪费的比较次数，避免散列密钥的冲突很重要。通常，我们使用的槽数是预期元素数的两倍。</p><p>以下假设在现实中通常不成立：</p><ol type="1"><li>提前知道元素的数量</li><li>键是不唯一的</li><li>存在完美的哈希函数</li></ol><p>因此，我们需要适当选择哈希函数和哈希模式。</p><h3 id="线性探查哈希">4.1 线性探查哈希</h3><p>这是最基本的哈希方案。它通常也是最快的。它使用数组槽的循环缓冲区。哈希函数将键映射到槽。当发生冲突时，我们线性搜索相邻的槽，直到找到一个开放的槽。对于查找，我们可以检查键散列到的槽，并线性搜索，直到找到所需的条目。如果我们到达一个空槽或迭代哈希表中的每个槽，则该键不在表中。请注意，这意味着我们必须将键和值都存储在槽中，以便我们可以检查条目是否是所需的条目。删除则更加棘手。我们必须小心从槽中删除条目，因为这可能会阻止将来的查找找到已放在现在空槽下方的条目。这个问题有两种解决方案：</p><ul><li>最常见的方法是使用“墓碑”。我们没有删除该条目，而是将其替换为“逻辑删除”条目，该条目告诉未来的查找继续扫描。</li><li>另一种选择是在删除条目后移动相邻数据以填充现在的空槽。但是，我们必须小心，只移动最初移动的条目。这在实践中很少实现，因为当我们拥有大量密钥时，它的成本非常高。</li></ul><p><strong>非唯一键：</strong>在同一键可能与多个不同值或元组关联的情况下，有两种方法。</p><ul><li><strong>单独的链表：</strong>我们不存储带有键的值，而是存储一个指向单独存储区域的指针，该存储区域包含所有值的链表，这可能会溢出到多个页面。</li><li><strong>冗余键：</strong>更常见的方法是简单地在表中多次存储相同的键。即使我们这样做，所有线性探测仍然有效。</li></ul><p><strong>优化：</strong></p><p>有多种方法可以进一步优化此哈希方案：</p><ul><li>基于数据类型或键大小的专用哈希表实现：它们存储数据、执行拆分等的方式可能有所不同。例如，如果我们有字符串键，我们可以在原始哈希表中存储较小的字符串，而对于较大的字符串仅存储指针或哈希。</li><li>将元数据存储在单独的数组中：一个示例是将空槽/逻辑删除信息存储在打包位图中作为页头的一部分或存储在单独的哈希表中，这将帮助我们避免查找已删除的键。</li><li>维护哈希表及其槽的版本：由于为哈希表分配内存非常昂贵，因此我们可能希望重复重用相同的内存。要清除表并使其条目无效，我们可以增加表的版本计数器，而不是将每个槽标记为已删除/空。如果槽版本与表版本不匹配，则槽可以被视为空。</li></ul><p>Google的absl::flat_hash_map是线性探针哈希的最先进的实现。</p><h3 id="cuckoo哈希">4.2 Cuckoo哈希</h3><p>这种方法不再使用一个单一的哈希表，而是维护多个具有不同哈希函数的哈希表。这些哈希函数使用相同的算法（例如XXHash、CityHash），通过使用不同的种子值为相同的键生成不同的哈希值。</p><p>当我们插入时，我们会检查每个表并选择一个具有空闲插槽的表（如果有多个表都有一个插槽，可以比较负载因子，或者更常见的，随机选择一个表）。如果没有表有空闲插槽，我们会选择（通常是随机选择一个）并驱逐旧条目。然后我们将旧条目重新哈希到另一个表中。在极少数情况下，我们可能会陷入一个循环。如果发生这种情况，我们可以使用新的哈希函数种子重建所有哈希表（不太常见）或使用更大的表重建哈希表（更常见）。</p><p>Cuckoo 哈希保证 O(1) 查找和删除，但插入可能更昂贵。</p><p><strong>教授注：</strong>Cuckoo哈希的本质是多个哈希函数将一个键映射到不同的槽。在实践中，Cuckoo哈希是通过多个哈希函数来实现的，这些函数将一个键映射到单个哈希表中的不同槽。此外，由于散列可能并不总是O(1)，Cuckoo散列查找和删除的成本可能超过 O(1)。</p><h2 id="动态哈希方案">5 动态哈希方案</h2><p>静态散列方案要求 DBMS知道它想要存储的元素数量。否则，如果需要增大/缩小表的大小，则必须重建表。</p><p>动态哈希方案能够根据需要调整哈希表的大小，而无需重建整个表。这些方案以不同的方式执行大小调整，可以最大化读取或写入。</p><h3 id="链式哈希">5.1 链式哈希</h3><p>这是最常见的动态哈希方案。 DBMS为哈希表中的每个槽维护一个存储桶的链表。散列到同一槽的键被简单地插入到该槽的链表中。</p><p>为了查找一个元素，我们散列到它的存储桶，然后扫描它。这可以通过在存储桶指针列表中额外存储布隆过滤器来优化，这会告诉我们链表中是否不存在某个键，并帮助我们避免在这种情况下进行查找。</p><h3 id="可扩展哈希">5.2 可扩展哈希</h3><p>链式哈希的改进变体，它分割存储桶而不是让链永远增长。这种方法允许哈希表中的多个槽位置指向同一个桶链。</p><p>重新平衡哈希表背后的核心思想是在拆分时移动存储桶条目，并增加要检查的位数以查找哈希表中的条目。这意味着DBMS 只需要在分割链的桶内移动数据；所有其他桶保持不变。</p><ul><li>DBMS维护全局和局部深度位计数，确定在槽数组中查找存储桶所需的位数</li><li>当存储桶已满时，DBMS会拆分存储桶并重新排列其元素。如果分割桶的局部深度小于全局深度，则新的桶将被添加到现有的槽数组中。否则，DBMS将槽数组的大小加倍以容纳新的存储桶，并增加全局深度计数器。</li></ul><h3 id="线性哈希">5.3 线性哈希</h3><p>该方案不会在桶溢出时立即拆分桶，而是维护一个 split指针来跟踪下一个要拆分的桶。无论这个指针是否指向溢出的桶，DBMS总是会分裂。溢出标准由实现决定。</p><ul><li>当任何桶溢出时，在指针位置分裂桶。添加新的槽条目和新的哈希函数，并应用此函数对拆分存储桶中的键进行重新哈希。</li><li>如果原始哈希函数映射到先前已被分割指针指向的槽，则应用新的哈希函数来确定键的实际位置。</li><li>当指针到达最后一个槽时，删除原来的哈希函数并将指针移回到开头。</li></ul><p>如果split指针下面的最高bucket是空的，我们还可以删除该bucket，并将split指针反向移动，从而缩小哈希表的大小。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="哈希表" scheme="http://polaris3003.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
    <category term="静态哈希方案" scheme="http://polaris3003.github.io/tags/%E9%9D%99%E6%80%81%E5%93%88%E5%B8%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="动态哈希方案" scheme="http://polaris3003.github.io/tags/%E5%8A%A8%E6%80%81%E5%93%88%E5%B8%8C%E6%96%B9%E6%A1%88/"/>
    
    <category term="线性探查哈希" scheme="http://polaris3003.github.io/tags/%E7%BA%BF%E6%80%A7%E6%8E%A2%E6%9F%A5%E5%93%88%E5%B8%8C/"/>
    
    <category term="Cuckoo哈希" scheme="http://polaris3003.github.io/tags/Cuckoo%E5%93%88%E5%B8%8C/"/>
    
    <category term="链式哈希" scheme="http://polaris3003.github.io/tags/%E9%93%BE%E5%BC%8F%E5%93%88%E5%B8%8C/"/>
    
    <category term="可扩展哈希" scheme="http://polaris3003.github.io/tags/%E5%8F%AF%E6%89%A9%E5%B1%95%E5%93%88%E5%B8%8C/"/>
    
    <category term="线性哈希" scheme="http://polaris3003.github.io/tags/%E7%BA%BF%E6%80%A7%E5%93%88%E5%B8%8C/"/>
    
  </entry>
  
  <entry>
    <title>茶6.24-6.28</title>
    <link href="http://polaris3003.github.io/2024/06/24/%E8%8C%B66.24-6.28/"/>
    <id>http://polaris3003.github.io/2024/06/24/%E8%8C%B66.24-6.28/</id>
    <published>2024-06-24T07:44:51.000Z</published>
    <updated>2025-02-11T09:24:36.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶6.24-6.28">茶6.24-6.28</h1><h2 id="mon">Mon</h2><p><a href="https://codeforces.com/problemset/problem/1759/E" class="uri">https://codeforces.com/problemset/problem/1759/E</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤2e5) h(1≤h≤1e6) 和长为 n 的数组 a(1≤a[i]≤1e8)。</p><p>一开始你有一个数 sum，初始值为 h。<br>每次操作，你可以选择如下三种操作的其中一个：</p><ol type="1"><li>删除一个 小于sum的 a[i]，然后把 sum 增加 floor(a[i]/2)。</li><li>sum *= 2，该操作至多执行 2 次。</li><li>sum *= 3，该操作至多执行 1 次。</li></ol><p>输出最多可以删除多少个数。</p><p>输入<br>8<br>4 1<br>2 1 8 9<br>3 3<br>6 2 60<br>4 5<br>5 1 100 5<br>3 2<br>38 6 3<br>1 1<br>12<br>4 6<br>12 12 36 100<br>4 1<br>2 1 1 15<br>3 5<br>15 1 13<br>输出<br>4<br>3<br>3<br>3<br>0<br>4<br>4<br>3</p><p><strong>Sol：</strong></p><p>枚举 <em>2 和 </em>3 的使用顺序，有三种情况：</p><p><em>2 </em>2 *3</p><p><em>2 </em>3 *2</p><p><em>3 </em>2 *2</p><p>对于每种顺序，贪心从小到大遍历 a（所以需要把 a 排序），如果 a[i]&gt;= 当前数字就使用乘法。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(vll a, ll sum, ll* f)</span> </span>&#123;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span>(now == a.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[now] &lt; sum) &#123;<br>            sum += a[now++]/<span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>)&#123;<br>            sum *= f[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n,sum;<br>    cin&gt;&gt;n&gt;&gt;sum;<br>    <span class="hljs-function">vll <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a);<br>    ll now = <span class="hljs-number">0</span>;<br>    ll f1[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;ll f2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;ll f3[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-built_in">f</span>(a,sum,f1),<span class="hljs-built_in">max</span>(<span class="hljs-built_in">f</span>(a,sum,f2),<span class="hljs-built_in">f</span>(a,sum,f3))) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue">Tue</h2><p><a href="https://codeforces.com/contest/1883/problem/F">You Are SoBeautiful_905F</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n(1≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>输出 a 有多少个非空连续子数组 b，满足 b 是 a的唯一子序列（不存在其他的子序列等于 b）。</p><p>输入<br>6<br>1<br>1<br>2<br>1 1<br>3<br>1 2 1<br>4<br>2 3 2 1<br>5<br>4 5 4 5 4<br>10<br>1 7 7 2 3 4 3 2 1 100<br>输出<br>1<br>1<br>4<br>7<br>4<br>28</p><p>考察子数组最左边和最右边的元素。</p><p>条件一：子数组最左边的元素 a[L]，其左侧不能有等于 a[L]的元素，否则子序列不唯一。</p><p>条件二：子数组最右边的元素 a[R]，其右侧不能有等于 a[R]的元素，否则子序列不唯一。</p><p>结论：满足这两个条件，则子序列是唯一的。</p><p>证明：用反证法证明。</p><p>假设子序列不唯一，那么另一个子序列的不同下标一定位于 [L,R]内部（如果位于 [L,R]外面就破坏了条件一或条件二），但是这个范围内的所有下标我们都选了，不可能存在一个子序列没有而另一个子序列有的情况，矛盾，故原命题成立。</p><p>怎么计算子数组个数呢？ 前后缀分解。</p><p>处理出每个 a[i] 首次和最后一次出现的位置。（实际只需要处理最后一次）枚举 a[i] 作为左端点，那么 a[i] 必须是首次出现的元素，我们还需要知道&gt;=i 的且是最后一次出现的元素的个数，具体见代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    mii r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        r[a[i]]=i;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; vis;<br>    <span class="hljs-type">int</span> rs = r.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[a[i]]) &#123;<br>            vis[a[i]] = <span class="hljs-literal">true</span>;<br>            ans += rs; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (r[a[i]] == i) &#123;<br>            rs--;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed">Wed</h2><p><a href="https://codeforces.com/problemset/problem/1862/E">Kolya andMovie Theatre_894E</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br>每组数据输入 n m(1≤m≤n≤2e5) d(1≤d≤1e9) 和长为 n 的数组a(-1e9≤a[i]≤1e9)。</p><p>从 a 中选一个长度至多为 m 的子序列 b。<br>设 b 的最后一个数在 a 中的下标为 i，定义 f(b)=sum(b)-i*d。（下标从 1开始）<br>你需要最大化 f(b)。如果 b 是空的，那么 f(b)=0。</p><p>注：子序列不一定连续。</p><p>输入<br>6<br>5 2 2<br>3 2 5 4 6<br>4 3 2<br>1 1 1 1<br>6 6 6<br>-82 45 1 -77 39 11<br>5 2 2<br>3 2 5 4 8<br>2 1 1<br>-1 2<br>6 3 2<br>-8 8 -2 -1 9 0<br>输出<br>2<br>0<br>60<br>3<br>0<br>7</p><p><strong>Sol:</strong></p><p>枚举最后一个数的下标 i=1,2,3,...,n，同时维护前 m 大的正数。</p><p>那么答案就是【堆中元素之和 - i*d】的最大值。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, d;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; s;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> cur = sum + a[i] - d * (i + <span class="hljs-number">1</span>);<br>        ans = <span class="hljs-built_in">max</span>(ans, cur);<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            s.<span class="hljs-built_in">insert</span>(&#123;a[i], i&#125;);<br>            sum += a[i];<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt;= m) &#123;<br>                <span class="hljs-comment">// BUG(s.begin()-&gt;first);</span><br>                sum -= (s.<span class="hljs-built_in">begin</span>()-&gt;first);<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu">Thu</h2><p><a href="https://codeforces.com/contest/1851/problem/G">The GreatEqualizer_894E</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5，m 之和 ≤2e5，q之和 ≤2e5。<br>每组数据输入 n(2≤n≤2e5) m(1≤m≤2e5)，表示一个 n 点 m边的无向图。节点编号从 1 开始。保证图中无自环和重边。<br>然后输入长为 n 的数组 h(1≤h[i]≤1e9)。每个节点有一座山，第 i 座山的高度为h[i]。<br>然后输入 m 条边。<br>然后输入 q(1≤q≤2e5) 和 q 个询问，每个询问输入 a b e(0≤e≤1e9)。</p><p>从第 i 座山移动到和 i 相邻的第 j 座山，你的能量会减少h[j]-h[i]。如果这个值是负数则你会增加能量。<br>只有在移动后能量 &gt;= 0 的情况下才能从 i 移动到 j。<br>对于每个询问，回答：在你初始能量为 e 的情况下，能否从第 a 座山移动到第 b座山？输出 YES 或 NO。注意节点编号从 1 开始。</p><p>样例太长，请在原题查看。</p><p>离线+并查集。</p><p><strong>Sol：</strong></p><p>根据题意，从 a 到 b，路径上的山的高度必须都 &lt;= h[a] + e。</p><p>把询问按照 h[a]+e 从小到大排序，把 h也从小到大排序（带上下标一起排序）。</p><p>双指针遍历询问和 h 数组，对于所有高度 &lt;= h[a]+e 的山 x，我们将 x及其高度 &lt;= x 的邻居用并查集合并。</p><p>合并后，如果发现 a 和 b 被合并在一起，就说明可以从 a 到 b。</p><p>为了找到 x 的所有高度 &lt;= x 的邻居，在读取 m 条边时，总是把 h值大的点指向 h 值小的点。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dsu</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Dsu</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : f(n), siz(n, <span class="hljs-number">1</span>) &#123;</span> std::<span class="hljs-built_in">iota</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> f[x] == x ? x : f[x] = <span class="hljs-built_in">find</span>(f[x]); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        siz[x] += siz[y];<br>        f[y] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vi <span class="hljs-title">h</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; h[i];<br>    <span class="hljs-function">vector&lt;pii&gt; <span class="hljs-title">es</span><span class="hljs-params">(m)</span></span>;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt; &gt; events;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[u, v] : es) &#123;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        --u; --v;<br>        events.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">max</span>(h[u], h[v]), <span class="hljs-number">-1</span>, u, v&#125;);<br>    &#125;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, e;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; e;<br>        --u; --v;<br>        events.<span class="hljs-built_in">push_back</span>(&#123;(h[u] + e), i, u, v&#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(events);<br>    <span class="hljs-function">Dsu <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, id, u, v] : events) &#123;<br>        <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span> &amp;&amp; id &lt; q) &#123;<br>            ans[id] = dsu.<span class="hljs-built_in">same</span>(u, v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dsu.<span class="hljs-built_in">merge</span>(u, v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;q; i++) &#123;<br>            cout &lt;&lt; (ans[i]?<span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri">Fri</h2><p><a href="https://codeforces.com/problemset/problem/797/F">Mice andHoles_edu19F</a></p><p>输入 n(1≤n≤5000) 和 m(1≤m≤5000)。<br>然后输入长为 n 的数组 a(-1e9≤a[i]≤1e9)，表示在数轴上有 n个一样的小球，第 i 个小球的位置是 a[i]。<br>然后输入 m 行，每行两个数 pi(-1e9≤pi≤1e9) 和 ci(1≤ci≤5000)，表示有 m个洞，第 i 个洞的位置是 pi，能容纳 ci 个小球。</p><p>把所有小球都移入洞中，移动距离之和的最小值是多少？<br>如果无法满足，输出 -1。</p><p>输入<br>4 5<br>6 2 8 9<br>3 6<br>2 1<br>3 6<br>4 7<br>4 7<br>输出 11</p><p>输入<br>7 2<br>10 20 30 40 50 45 35<br>-1000000000 10<br>1000000000 1<br>输出 7000000130</p><p><strong>Sol:</strong></p><p>划分型 DP + 单调队列优化。</p><p>没做过划分型 DP 的可以看看 <a href="https://leetcode.cn/circle/discuss/tXLS3i/">动态规划题单</a></p><p>不了解单调队列的可以看看<a href="https://www.bilibili.com/video/BV1bM411X72E/">【基础算法精讲27】</a></p><p>首先有如下贪心结论：</p><p>把小球和洞按照位置从小到大排序，那么最左边的若干个小球（可能 0个）进第一个洞，接下来的若干小球（可能 0 个）进第二个洞，依此类推。</p><p>于是问题变成，把 a 分成若干段，第 i 段的小球（不能超过 ci 个）进第 i个洞，移动距离之和为 sum(abs(a[j] - pi) for j in 这一段)</p><p>按照划分型 DP 的套路，定义：</p><p>f[i] [j] = a[:j] 进前 i 个洞的距离和</p><p>注意这个定义 j=0 表示没有小球，j=1 表示第一个小球，j=n表示所有小球。</p><p>考虑最后一个子数组的小球进第 i 个洞的距离和。</p><p>枚举最后一个子数组的左端点 L，从 f[i-1] [L] 转移到 f[i] [j]，考虑a[L:j] 对最优解的影响，设 abs(a[j]-pi) 的前缀和数组为 s，那么有</p><p>f[i] [j] = min{ f[i-1] [L] + s[j] - s[L] } = min{ f[i-1] [L] - s[L] }+ s[j]</p><p>其中 L 属于区间 [j-ci,j]。如果 L=j 表示没有小球移动到第 i 个洞。</p><p>由于上式随着 j 的变大，L的最小值也在变大，所以是一个滑动窗口最小值问题，可以用单调队列优化。</p><p>单调队列保存 (f[i-1] [j] - s[j],j)，注意额外保存下标。由于计算的是最小值，右边遇到更小的可以把左边更大（或者相等）的弹出，所以是单调队列从左到右是严格递增的，队首就是转移来源的最小值。</p><p>即 f[i] [j] = 队首 + s[j]。 如果队首的下标 &lt; j -ci，那么弹出队首。</p><p>初始值 f[0] [0] = 0, f[0] [j] = inf (j &gt;= 1)。</p><p>最后答案为 f[m] [n]。</p><p>代码实现时，由于队列中保存了 f[i-1] [.] 的信息，所以 f数组的第一个维度可以去掉。</p><p><strong>Code(学习一下):</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">5005</span>][<span class="hljs-number">5005</span>],a[<span class="hljs-number">5005</span>],b[<span class="hljs-number">5005</span>],c[<span class="hljs-number">5005</span>];<br>pair &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; d[<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">D</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(x,y)-<span class="hljs-built_in">min</span>(x,y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n,m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>cin &gt;&gt; a[i];<br><span class="hljs-built_in">sort</span>(a<span class="hljs-number">+1</span>,a+n<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>cin &gt;&gt; d[i].first &gt;&gt; d[i].second;<br><span class="hljs-built_in">sort</span>(d<span class="hljs-number">+1</span>,d+m<span class="hljs-number">+1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) b[i]=d[i].first,c[i]=d[i].second;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>dp[i][j]=<span class="hljs-number">1e18</span>;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-type">int</span> w[<span class="hljs-number">5005</span>]=&#123;&#125;,qzh[<span class="hljs-number">5005</span>]=&#123;&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>qzh[j]=<span class="hljs-built_in">D</span>(b[i],a[j])+qzh[j<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++) w[j]=dp[i<span class="hljs-number">-1</span>][j]-qzh[j];<br><span class="hljs-type">int</span> q[<span class="hljs-number">5005</span>]=&#123;&#125;,head=<span class="hljs-number">1</span>,tail=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>&#123;<br><span class="hljs-keyword">while</span>(head&lt;=tail&amp;&amp;w[q[tail]]&gt;w[j]) --tail;<br><span class="hljs-keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;j-c[i]) ++head;<br>q[++tail]=j;<br>dp[i][j]=qzh[j]+w[q[head]];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dp[m][n]&gt;<span class="hljs-number">8e17</span>) dp[m][n]=<span class="hljs-number">-1</span>;<br>cout &lt;&lt; dp[m][n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="codeforces" scheme="http://polaris3003.github.io/categories/codeforces/"/>
    
    
    <category term="Dynamic Programming" scheme="http://polaris3003.github.io/tags/Dynamic-Programming/"/>
    
    <category term="Greedy Algorithm" scheme="http://polaris3003.github.io/tags/Greedy-Algorithm/"/>
    
    <category term="Subsequence" scheme="http://polaris3003.github.io/tags/Subsequence/"/>
    
    <category term="Prefix Sum" scheme="http://polaris3003.github.io/tags/Prefix-Sum/"/>
    
    <category term="Binary Search" scheme="http://polaris3003.github.io/tags/Binary-Search/"/>
    
    <category term="Codeforces" scheme="http://polaris3003.github.io/tags/Codeforces/"/>
    
    <category term="Sorting" scheme="http://polaris3003.github.io/tags/Sorting/"/>
    
    <category term="Offline Queries" scheme="http://polaris3003.github.io/tags/Offline-Queries/"/>
    
    <category term="Union-Find" scheme="http://polaris3003.github.io/tags/Union-Find/"/>
    
    <category term="Monotonic Queue" scheme="http://polaris3003.github.io/tags/Monotonic-Queue/"/>
    
  </entry>
  
  <entry>
    <title>CMU15445-lecture6</title>
    <link href="http://polaris3003.github.io/2024/06/17/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    <id>http://polaris3003.github.io/2024/06/17/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/</id>
    <published>2024-06-17T08:57:51.000Z</published>
    <updated>2025-02-11T09:25:06.000Z</updated>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第六课缓冲池">第六课：缓冲池</h1><h2 id="介绍">1 介绍</h2><p>DBMS负责管理其内存并在磁盘上来回移动数据。由于在大多数情况下，数据无法直接在磁盘中进行操作，因此任何数据库必须能够有效地将表示为文件的数据从磁盘移动到内存中，以便可以使用。交互的示意图如图一所示。理想情况下，从执行引擎的角度来看，它应该“看起来”好像所有数据都在内存中。它不必担心如何将数据提取到内存中。</p><p><img src="/2024/06/17/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/image-20240617170556181.png" alt="图1"></p><p>思考这个问题的另一种方式是从空间和时间控制的角度来考虑。</p><p>空间控制是指页面在磁盘上物理写入的位置。空间控制的目标是使经常一起使用的页面在磁盘上尽可能物理地靠近。</p><p>时间控制是指何时将页面读入内存以及何时将其写入磁盘。时间控制旨在最大限度地减少因必须从磁盘读取数据而导致的停顿数量。</p><h2 id="locks-vs.-latchs">2 Locks vs. Latchs</h2><p>在讨论DBMS如何保护其内部元素时，我们需要区分locks和latchs</p><p><strong>Locks：</strong>锁是一种更高级别的逻辑原语，可保护数据库的内容（例如元组、表、数据库）免受其他事务的影响。事务将在其整个持续时间内保持锁定。数据库系统可以向用户公开在运行查询时持有哪些锁。需要能够回滚更改。</p><p><strong>Latchs：</strong>latch是一种低级保护原语，DBMS用于其内部数据结构（例如哈希表、内存区域）中的关键部分。Latchs仅在执行操作期间被保持。不需要能够回滚更改。</p><h2 id="缓冲池">3 缓冲池</h2><p>缓冲池是从磁盘读取的页面的内存缓存。它本质上是在数据库内部分配的一个大内存区域，用于存储从磁盘获取的页面。</p><p>缓冲池的内存区域组织为固定大小页面的数组。每个数组条目称为一个帧。当DBMS请求一页时，会将其从磁盘复制到缓冲池的其中一个帧。当一个页面被请求时，数据库系统能先查找缓冲池。只有这个页面没有找到时，系统才会从磁盘中获取这个页面的一个copy。脏页被缓冲并且不会立即写回。缓冲池的内存组织图见图2。</p><p><img src="/2024/06/17/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/image-20240617172314457.png" alt="图2"></p><h3 id="缓冲池元数据">缓冲池元数据</h3><p>缓冲池必须维护某些元数据才能有效且正确地使用。</p><p>首先，页表是内存中的哈希表，用于跟踪当前内存中的页面。它将页面 ID映射到缓冲池中的帧位置。由于缓冲池中页面的顺序不一定反映磁盘上的顺序，因此这个额外的间接层允许识别池中的页面位置。</p><p>注意：不要将页表与页目录混淆，页目录是从页 id到数据库文件中页位置的映射。对页目录的所有更改都必须记录在磁盘上，以便DBMS 在重新启动时能够找到。</p><p>页表还维护每页的附加元数据、脏标志和引脚/引用计数器。</p><p>每当线程修改页面时，都会设置脏标志。这向存储管理器表明该页必须写回磁盘。</p><p>引脚/引用计数器跟踪当前正在访问该页面（读取或修改它）的线程数。线程在访问页面之前必须增加计数器。如果页面的引脚计数大于零，则不允许存储管理器从内存中逐出该页面。固定不会阻止其他事务同时访问该页面。</p><h2 id="内存分配策略">内存分配策略</h2><p>数据库中的内存根据两种策略分配给缓冲池。</p><p>全局策略涉及 DBMS应该做出的决策，以使正在执行的整个工作负载受益。它考虑所有活动事务以找到分配内存的最佳决策。</p><p>另一种选择是本地策略，它做出的决策将使单个查询或事务运行得更快，即使这对整个工作负载不利。本地策略将帧分配给特定事务，而不考虑并发事务的行为。</p><p>大多数系统结合使用全局视图和局部视图。</p><h2 id="缓冲池优化">4 缓冲池优化</h2><p>有多种方法可以优化缓冲池以适应应用程序的工作负载。</p><h3 id="多缓冲池">多缓冲池</h3><p>DBMS可以出于不同目的维护多个缓冲池（即每个数据库缓冲池、每个页面类型缓冲池）。然后，每个缓冲池都可以采用针对存储在其中的数据量身定制的本地策略。此方法有助于减少锁存争用并提高局部性。</p><p>将所需页面映射到缓冲池的两种方法是对象 ID 和散列。</p><p>对象 ID 涉及扩展记录 ID以具有对象标识符。然后通过对象标识符，可以维护从对象到特定缓冲池的映射。</p><p>另一种方法是散列，其中 DBMS 对页面 id进行散列以选择要访问的缓冲池。</p><h3 id="预获取">预获取</h3><p>DBMS还可以通过基于查询计划预取页面来进行优化。然后，在处理第一组页面时，可以将第二组页面预取到缓冲池中。DBMS在顺序访问多个页面时通常使用此方法。缓冲池管理器还可以预取树索引数据结构中的叶页。</p><h3 id="扫描共享同步扫描">扫描共享（同步扫描）</h3><p>查询游标可以重用从存储或运算符计算中检索的数据。这允许多个查询附加到扫描表的单个游标。如果一个查询开始扫描并且已经有一个查询在执行此操作，则DBMS 会将第二个查询的游标附加到现有游标。DBMS跟踪第二个查询与第一个查询的连接位置，以便在到达数据结构末尾时完成扫描。</p><h3 id="旁路缓冲池">旁路缓冲池</h3><p>顺序扫描操作符不会将获取的页面存储在缓冲池中以避免开销。相反，内存对于正在运行的查询来说是本地的。如果操作员需要读取磁盘上连续的大量页面，则此方法非常有效。缓冲池旁路还可以用于临时数据（排序、连接）。</p><h2 id="缓存替换策略">5 缓存替换策略</h2><p>当DBMS需要释放帧以为新页面腾出空间时，它必须决定从缓冲池里移除哪个页面。</p><p>替换策略是 DBMS实现的一种算法，用于在需要空间时决定从缓冲池中逐出哪些页。</p><p>替换策略的实施目标是提高正确性、准确性、速度和元数据开销。</p><h3 id="最近最少使用lru">最近最少使用（LRU）</h3><p>最近最少使用的替换策略维护每个页面上次访问时间的时间戳。 DBMS选择逐出具有最早时间戳的页面。该时间戳可以存储在单独的数据结构中，例如队列，以允许排序并通过减少驱逐时的排序时间来提高效率。</p><h3 id="clock">CLOCK</h3><p>CLOCK 策略是 LRU的近似，不需要每页单独的时间戳。在CLOCK策略中，每个页面都被赋予一个参考位。当访问页面时，设置为1。</p><p>为了形象化这一点，请使用“时钟指针”将页面组织在循环缓冲区中。扫描时检查页面的位是否设置为1。如果是，则设置为零，如果否，则将其逐出。通过这种方式，时钟指针可以记住驱逐之间的位置。</p><p><img src="/2024/06/17/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/image-20240618143256776.png" alt="图3"></p><h3 id="备选方案">备选方案</h3><p>LRU 和 CLOCK 替换策略存在许多问题。</p><p>也就是说，LRU 和 CLOCK容易受到顺序泛洪的影响，其中缓冲池的内容由于顺序扫描而被损坏。由于顺序扫描会快速读取许多页面，因此缓冲池会被填满，并且来自其他查询的页面会被逐出，因为它们将具有较早的时间戳。在这种情况下，最新的时间戳并不能准确反映我们实际想要驱逐的页面。</p><p>针对LRU和CLOCK策略的缺点，存在三种解决方案。</p><p>一种解决方案是 LRU-K，它将最后 K个引用的历史记录作为时间戳进行跟踪，并计算后续访问之间的间隔。该历史记录用于预测下次访问页面的时间。</p><p>另一个优化是每个查询的本地化。 DBMS根据每个事务/查询选择要驱逐的页面。这可以最大限度地减少每个查询对缓冲池的污染。</p><p>最后，优先级提示允许事务在查询执行期间根据每个页面的上下文告诉缓冲池页面是否重要。</p><h3 id="脏页">脏页</h3><p>有两种方法可以处理含有脏位的页面。最快的选择是删除缓冲池中任何未脏的页面。较慢的方法是将脏页写回磁盘以确保其更改被持久化。</p><p>这两种方法说明了快速驱逐与将来不会再次读取的脏写页面之间的权衡。</p><p>避免不必要地写出页面问题的一种方法是后台写入。通过后台写入，DBMS可以定期遍历页表并将脏页写入磁盘。当脏页被安全写入时，DBMS可以逐出该页或只是取消设置脏标志。</p><h2 id="其他内存池">6 其他内存池</h2><p>DBMS需要内存来存储元组和索引以外的内容。这些其他内存池可能并不总是由磁盘支持，具体取决于实现。</p><ul><li>排序+连接缓冲区</li><li>查询缓存</li><li>维护缓冲器</li><li>日志缓冲区</li><li>字典缓存</li></ul><h2 id="操作系统页面缓存">7 操作系统页面缓存</h2><p>大多数磁盘操作都是通过操作系统 API进行的。除非另有明确说明，否则操作系统维护自己的文件系统缓存。</p><p>大多数 DBMS 使用直接 I/O来绕过操作系统的缓存，以避免页面的冗余副本以及必须管理不同的逐出策略。</p><p>Postgres 是使用操作系统页面缓存的数据库系统的示例。</p><h2 id="磁盘io调度">8 磁盘IO调度</h2><p>DBMS维护内部队列来跟踪来自整个系统的页面读/写请求。任务的优先级是根据以下几个因素确定的：</p><ul><li>顺序IO和随机IO</li><li>关键路径任务与后台任务</li><li>表、索引、日志、临时数据</li><li>事务信息</li><li>基于用户的SLA</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;link rel=&quot;stylesheet&quot; class=&quot;aplayer-secondary-style-marker&quot; href=&quot;&#92;assets&#92;css&#92;APlayer.min.css&quot;&gt;&lt;script src=&quot;&#92;assets&#92;js&#92;APlayer.min.js&quot; cla</summary>
      
    
    
    
    <category term="cmu15445" scheme="http://polaris3003.github.io/categories/cmu15445/"/>
    
    
    <category term="Buffer Pool" scheme="http://polaris3003.github.io/tags/Buffer-Pool/"/>
    
    <category term="Locks vs. Latches" scheme="http://polaris3003.github.io/tags/Locks-vs-Latches/"/>
    
    <category term="Page Table" scheme="http://polaris3003.github.io/tags/Page-Table/"/>
    
    <category term="Global vs. Local Memory Allocation" scheme="http://polaris3003.github.io/tags/Global-vs-Local-Memory-Allocation/"/>
    
    <category term="Multi-Buffer Pool" scheme="http://polaris3003.github.io/tags/Multi-Buffer-Pool/"/>
    
    <category term="Prefetching" scheme="http://polaris3003.github.io/tags/Prefetching/"/>
    
    <category term="Scan Sharing" scheme="http://polaris3003.github.io/tags/Scan-Sharing/"/>
    
    <category term="Bypassing Buffer Pool" scheme="http://polaris3003.github.io/tags/Bypassing-Buffer-Pool/"/>
    
    <category term="Cache Replacement Policies" scheme="http://polaris3003.github.io/tags/Cache-Replacement-Policies/"/>
    
    <category term="LRU (Least Recently Used)" scheme="http://polaris3003.github.io/tags/LRU-Least-Recently-Used/"/>
    
    <category term="CLOCK Algorithm" scheme="http://polaris3003.github.io/tags/CLOCK-Algorithm/"/>
    
    <category term="LRU-K" scheme="http://polaris3003.github.io/tags/LRU-K/"/>
    
    <category term="Priority Hints" scheme="http://polaris3003.github.io/tags/Priority-Hints/"/>
    
    <category term="Dirty Pages" scheme="http://polaris3003.github.io/tags/Dirty-Pages/"/>
    
    <category term="Background Writing" scheme="http://polaris3003.github.io/tags/Background-Writing/"/>
    
    <category term="Other Memory Pools" scheme="http://polaris3003.github.io/tags/Other-Memory-Pools/"/>
    
    <category term="Operating System Page Cache" scheme="http://polaris3003.github.io/tags/Operating-System-Page-Cache/"/>
    
    <category term="Direct I/O" scheme="http://polaris3003.github.io/tags/Direct-I-O/"/>
    
    <category term="Disk I/O Scheduling" scheme="http://polaris3003.github.io/tags/Disk-I-O-Scheduling/"/>
    
    <category term="Sequential vs. Random I/O" scheme="http://polaris3003.github.io/tags/Sequential-vs-Random-I-O/"/>
    
  </entry>
  
</feed>

<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>茶</title>
    <link href="/2025/01/07/Tea/"/>
    <url>/2025/01/07/Tea/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tea"><a class="markdownIt-Anchor" href="#tea"></a> Tea</h1><h2 id="20250107"><a class="markdownIt-Anchor" href="#20250107"></a> 20250107</h2><h3 id="problem"><a class="markdownIt-Anchor" href="#problem"></a> Problem</h3><p><a href="https://codeforces.com/problemset/problem/2048/C">Kevin and Binary Strings</a></p><p>输入 T(≤1e3) 表示 T 组数据。所有数据的字符串长度之和 ≤5000。</p><p>每组数据输入长度 ≤5000 的 01 字符串 s。保证 s 的第一个字符是 ‘1’。</p><p>你需要在 s 中选择两个非空子串（可以重叠，可以有前导零），将其视作两个二进制数，计算 XOR。</p><p>目标是最大化 XOR。</p><p>输出你选择的两个子串的左右端点 l1 r1 l2 r2，下标从 1 开始。</p><p>如果答案不止一种，输出其中任意一个。</p><h3 id="example"><a class="markdownIt-Anchor" href="#example"></a> Example</h3><p>Input</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dns"><span class="hljs-number">5</span><br><span class="hljs-number">111</span><br><span class="hljs-number">1000</span><br><span class="hljs-number">10111</span><br><span class="hljs-number">11101</span><br><span class="hljs-number">1100010001101</span><br></code></pre></td></tr></table></figure><p>Output</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">2 </span><span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">3</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">3</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">5</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span><br><span class="hljs-symbol">3 </span><span class="hljs-number">4</span> <span class="hljs-number">1</span> <span class="hljs-number">5</span><br><span class="hljs-symbol">1 </span><span class="hljs-number">13</span> <span class="hljs-number">1</span> <span class="hljs-number">11</span><br></code></pre></td></tr></table></figure><h3 id="solution"><a class="markdownIt-Anchor" href="#solution"></a> Solution</h3><p>1.其中一个子串必然是 s，如果比 s 还短，那 XOR 必然比 s 小。</p><p>2.找到 s 的最左边的 0，这个 0 一定要改成 1，得到的 XOR 一定比不改更大。</p><p>3.设这个 0 的下标为 i，那么另一个子串的长度必须恰好等于 n-i，因为我们要【右对齐】计算 XOR。</p><p>4.暴力枚举所有长为 n-i 的子串。</p><p>5.如果 s 没有 0，那么输出 1 n 1 1。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin &gt;&gt; s;<br>    <span class="hljs-type">int</span> n = s.<span class="hljs-built_in">size</span>(), idx = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">4</span>)</span></span>;<br>    ans[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    ans[<span class="hljs-number">1</span>] = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            idx = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> len = n - idx, mx = <span class="hljs-number">0</span>;<br>    ans[<span class="hljs-number">2</span>] = ans[<span class="hljs-number">3</span>] = idx + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; idx &amp;&amp; i + len &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;1&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>, k = idx + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (k &lt; n &amp;&amp; s[k] != s[j]) &#123;<br>                j++;<br>                k++;<br>            &#125;<br>            <span class="hljs-type">int</span> sz = j - i;<br>            <span class="hljs-keyword">if</span> (sz &gt; mx) &#123;<br>                mx = sz;<br>                ans[<span class="hljs-number">2</span>] = i + <span class="hljs-number">1</span>;<br>                ans[<span class="hljs-number">3</span>] = i + len;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>        cout &lt;&lt; ans[i] &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i==<span class="hljs-number">3</span>];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="20250108"><a class="markdownIt-Anchor" href="#20250108"></a> 20250108</h2><h3 id="problem-2"><a class="markdownIt-Anchor" href="#problem-2"></a> Problem</h3><p><a href="https://codeforces.com/problemset/problem/2045/A">Scrambled Scrabble</a></p><p>输入长度 ≤5000 的字符串 s，只包含大写英文字母。</p><p>字母 AEIOU 是元音。Y 可以是元音也可以是辅音。<br />其余字母为辅音。特别地，可以把 NG 连在一起，当作一个辅音。</p><p>定义音节为一个辅音 + 一个元音 + 一个辅音。例如 CAR，KING 等等。<br />定义单词为由一个或多个音节串联得到的字符串。例如 KINGDOM 是由 KING + DOM 两个音节组成。</p><p>从 s 中删除零个或多个字母，然后重新排列剩余的字母，组成单词。<br />输出最长单词长度。<br />如果无法组成单词，输出 0。</p><h3 id="example-2"><a class="markdownIt-Anchor" href="#example-2"></a> Example</h3><p>输入 ICPCJAKARTA<br />输出 9</p><p>输入 NGENG<br />输出 5</p><p>输入 YYY<br />输出 3</p><p>输入 DANGAN<br />输出 6</p><p>输入 AEIOUY<br />输出 0</p><h3 id="solution-2"><a class="markdownIt-Anchor" href="#solution-2"></a> Solution</h3><ol><li>首先统计每种字母的出现次数</li><li>计算元音数(a)、Y数(y)、辅音数(b)和NG组合数(ng)</li><li>考虑不同情况下能组成的最长单词：<ul><li>如果NG组合充足，每个音节可以是5个字母（如NGENG）</li><li>如果普通辅音充足，每个音节是3个字母，可能额外使用NG</li><li>如果元音较多，需要根据辅音数量来限制</li><li>其他情况下尽可能组成3字符音节</li></ul></li><li>时间复杂度:O(n),空间复杂度O(1)</li></ol>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture13</title>
    <link href="/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/"/>
    <url>/2024/12/03/%E7%AC%AC%E5%8D%81%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86II/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十三课查询处理ii"><a class="markdownIt-Anchor" href="#第十三课查询处理ii"></a> 第十三课：查询处理II</h1><h2 id="1-背景"><a class="markdownIt-Anchor" href="#1-背景"></a> 1 背景</h2><p>前面关于查询执行的讨论都假设查询由单个工作器（即线程）执行。然而，在实践中，查询通常由多个工作器并行执行。</p><p>并行执行为 DBMS 提供了许多关键优势：</p><ul><li>提高吞吐量（每秒更多查询）和延迟（每个查询所用时间更少）的性能。</li><li>从 DBMS 外部客户端的角度来看，响应能力和可用性有所提高。</li><li>潜在降低总拥有成本 (TCO)。此成本包括硬件采购和软件许可，以及部署 DBMS 的人工开销和运行机器所需的能源。</li></ul><p>DBMS 支持两种类型的并行性：查询间并行性和查询内并行性。</p><h2 id="2-并行vs分布式数据库"><a class="markdownIt-Anchor" href="#2-并行vs分布式数据库"></a> 2 并行vs分布式数据库</h2><p>在并行和分布式系统中，数据库分布在多个“资源”上以提高并行性。这些资源可能是计算资源（例如，CPU 内核、CPU 插槽、GPU、附加机器）或存储资源（例如，磁盘、内存）。</p><p>区分并行和分布式系统非常重要。</p><ul><li><strong>并行DBMS</strong> 在并行 DBMS 中，资源或节点在物理上彼此接近。这些节点通过高速互连进行通信。假设资源之间的通信不仅快速，而且廉价可靠。</li><li><strong>分布式DBMS</strong> 在分布式 DBMS 中，资源可能彼此相距甚远；这可能意味着数据库跨越世界不同地区的机架或数据中心。因此，资源通过公共网络进行通信时，互连速度较慢，节点之间的通信成本较高，故障不容忽视。</li></ul><p>即使数据库可能在物理上分布在多个资源上，但它在应用程序看来仍然是一个逻辑数据库实例。因此，针对单节点 DBMS 执行的 SQL 查询应该在并行或分布式 DBMS 上生成相同的结果。</p><h2 id="3-处理模型"><a class="markdownIt-Anchor" href="#3-处理模型"></a> 3 处理模型</h2><p>DBMS 进程模型定义系统如何支持来自多用户应用程序/环境的并发请求。DBMS 由多个工作器组成，负责代表客户端执行任务并返回结果。应用程序可能会同时发送一个或多个大型请求，这些请求必须分配给不同的工作程序。</p><p>DBMS 可能采用两种主要进程模型：每个工作者进程和每个工作者线程。第三种常见的数据库使用模式采用嵌入式方法。</p><img src="../imgs/第十三课：查询处理II/image-20241203205321890.png" alt="图1：每个工作者进程模型" id="image1"><h3 id="每个工作者进程"><a class="markdownIt-Anchor" href="#每个工作者进程"></a> 每个工作者进程</h3><p>最基本的方法是每个工作进程。在这里，每个工作进程都是一个单独的操作系统进程，因此依赖于操作系统调度程序。应用程序发送请求并打开与数据库系统的连接。一些调度程序接收请求，选择其中一个工作进程来管理连接。应用程序现在直接与负责执行查询请求的工作进程进行通信。此事件序列如<a href="#image1">图 1 </a>所示。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture11</title>
    <link href="/2024/11/28/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/"/>
    <url>/2024/11/28/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十一课连接算法"><a class="markdownIt-Anchor" href="#第十一课连接算法"></a> 第十一课：连接算法</h1><h2 id="1-连接"><a class="markdownIt-Anchor" href="#1-连接"></a> 1 连接</h2><p>良好的数据库设计的目标是尽量减少信息重复量。这就是为什么表格是基于规范化理论组成的。因此需要连接来重建原始表格。</p><p>本课程将介绍用于合并两个表的内部等值连接算法。等值连接算法连接键相等的表。这些算法可以调整以支持其他连接。</p><h3 id="运算符输出"><a class="markdownIt-Anchor" href="#运算符输出"></a> 运算符输出</h3><p>对于在连接属性上匹配的元组 r <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> R 和元组 s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> S，连接运算符将 r 和 s 连接在一起形成一个新的输出元组。</p><p>实际上，连接运算符生成的输出元组的内容各不相同。这取决于 DBMS 的查询处理模型、存储模型和查询本身。连接运算符输出的内容有多种方法。</p><ul><li><strong>数据</strong>：这种方法将外表和内表中属性的值复制到仅针对该运算符的中间结果表中的元组中。这种方法的优点是查询计划中未来的操作符永远不需要返回基表来获取更多数据。缺点是这需要更多内存来实现整个元组。这称为实例化。DBMS 还可以进行额外的计算并省略查询中以后不需要的属性以进一步优化这种方法。</li><li><strong>记录ID</strong>：在这种方法中，DBMS 仅复制连接键以及匹配元组的记录 ID。这种方法非常适合列存储，因为 DBMS 不会复制查询不需要的数据。这称为延迟实现。</li></ul><h3 id="成本分析"><a class="markdownIt-Anchor" href="#成本分析"></a> 成本分析</h3><p>这里用于分析不同连接算法的成本指标是用于计算连接的磁盘 I/O 数量。这包括从磁盘读取数据以及将任何中间数据写入磁盘所产生的 I/O。</p><p>请注意，只考虑计算连接时的 I/O，而不考虑输出结果时产生的 I/O。这是因为输出成本取决于数据，而且任何连接算法的输出都是相同的，因此不同算法之间的成本不会改变。</p><blockquote><p>本课中使用的变量：</p><ul><li>R表（内表）中有M个页表，共m个元组</li><li>S表（外表）中有N个页表，共n个元组</li></ul></blockquote><p>一般来说，许多算法/优化可以在某些情况下降低连接成本，但没有一种算法可以在所有情况下都运行良好。</p><h2 id="2-嵌套循环连接"><a class="markdownIt-Anchor" href="#2-嵌套循环连接"></a> 2 嵌套循环连接</h2><p>从高层次上讲，这种类型的连接算法由两个嵌套的 for 循环组成，它们对两个表中的元组进行迭代，并逐对比较它们。如果元组与连接谓词匹配，则输出它们。外层 for 循环中的表称为外表，内层 for 循环中的表称为内表。</p><p>DBMS 总是希望使用“较小”的表作为外表。较小可以是元组数量或页面数量。DBMS 还会希望在内存中缓冲尽可能多的外表。它还可以尝试利用索引在内表中查找匹配项。</p><h3 id="简单嵌套循环连接"><a class="markdownIt-Anchor" href="#简单嵌套循环连接"></a> 简单嵌套循环连接</h3><p>对于外表中的每个元组，将其与内表中的每个元组进行比较。这是最糟糕的情况，DBMS 必须对外表中的每个元组进行整个内表扫描，而没有任何缓存或访问局部性。</p><p><strong>复杂度</strong>：M + (m * N)</p><h3 id="块嵌套循环连接"><a class="markdownIt-Anchor" href="#块嵌套循环连接"></a> 块嵌套循环连接</h3><p>对于外表中的每个块，从内表获取每个块并比较这两个块中的所有元组。该算法执行的磁盘访问较少，因为 DBMS 扫描内表以查找每个外表块，而不是每个元组。</p><p><strong>复杂度</strong>：M + (M * N)</p><p>如果 DBMS 有 B 个缓冲区可用于计算连接，则它可以使用 B − 2 个缓冲区来扫描外表。它将使用一个缓冲区来扫描内表，另一个缓冲区来存储连接的输出。</p><p><strong>复杂度</strong>：M + (<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>M</mi><mi mathvariant="normal">/</mi><mo stretchy="false">(</mo><mi>B</mi><mo>−</mo><mn>2</mn><mo stretchy="false">)</mo><mo stretchy="false">⌉</mo><mo>∗</mo><mi>N</mi></mrow><annotation encoding="application/x-tex">\lceil M / (B - 2) \rceil * N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">2</span><span class="mclose">)</span><span class="mclose">⌉</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span></span>)</p><h3 id="索引嵌套循环连接"><a class="markdownIt-Anchor" href="#索引嵌套循环连接"></a> 索引嵌套循环连接</h3><p>以前的嵌套循环连接算法性能较差，因为 DBMS 必须执行顺序扫描来检查内表中是否存在匹配项。但是，如果数据库已经为连接键上的其中一个表建立了索引，则可以使用该索引来加快比较速度。DBMS 可以使用现有索引，也可以为连接操作建立临时索引。</p><p>外表是没有索引的表，内表是有索引的表。</p><p>假设每个索引探测的成本是每个元组的某个常数值 C。</p><p><strong>复杂度</strong>：M + (m * C)</p><h2 id="3-排序合并连接"><a class="markdownIt-Anchor" href="#3-排序合并连接"></a> 3 排序合并连接</h2><p>从高层次上讲，排序合并连接根据连接键对两个表进行排序。DBMS 可以使用外部合并排序算法来实现这一点。然后，它使用游标逐一遍历每个表并发出匹配项（就像合并排序一样）。</p><p>如果一个或两个表已经根据连接属性（例如使用聚集索引）排序，或者输出需要根据连接键排序，则此算法很有用。</p><p>该算法的最坏情况是两个表中所有元组的连接属性都包含相同的值，这在实际数据库中不太可能发生。在这种情况下，合并的成本将是 M · N。不过，大多数情况下，密钥大多是唯一的，因此合并成本大约为 M + N。</p><p>假设 DBMS 有 B 个缓冲区可用于该算法：</p><ul><li>表R的排序成本：2M * (1 + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">⌈</mo><mi>M</mi><mi mathvariant="normal">/</mi><mi>B</mi><mo stretchy="false">⌉</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil log_{B-1}\lceil M/B \rceil \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">⌉</span><span class="mclose">⌉</span></span></span></span>)</li><li>表S的排序成本：2N * (1 + <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">⌈</mo><mi>l</mi><mi>o</mi><msub><mi>g</mi><mrow><mi>B</mi><mo>−</mo><mn>1</mn></mrow></msub><mo stretchy="false">⌈</mo><mi>N</mi><mi mathvariant="normal">/</mi><mi>B</mi><mo stretchy="false">⌉</mo><mo stretchy="false">⌉</mo></mrow><annotation encoding="application/x-tex">\lceil log_{B-1}\lceil N/B \rceil \rceil</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05017em;">B</span><span class="mbin mtight">−</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mopen">⌈</span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span><span class="mord">/</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mclose">⌉</span><span class="mclose">⌉</span></span></span></span>)</li><li>合并成本：（M + N）</li></ul><p>总成本：排序 + 合并</p><h2 id="4-哈希连接"><a class="markdownIt-Anchor" href="#4-哈希连接"></a> 4 哈希连接</h2><p>哈希连接算法的高级思想是使用哈希表根据元组的连接属性将其分成更小的块。这减少了 DBMS 计算连接时需要对每个元组执行的比较次数。哈希连接只能用于完整连接键上的等值连接。</p><p>如果元组 r <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> R 和元组 s <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> S 满足连接条件，则它们对于连接属性具有相同的值。如果该值被哈希化为某个值 i，则 R 元组必须在存储桶 r<sub>i</sub> 中，而 S 元组必须在存储桶 s<sub>i</sub> 中。因此，存储桶 r<sub>i</sub> 中的 R 元组只需与存储桶 s<sub>i</sub> 中的 S 元组进行比较。</p><h3 id="基本哈希连接"><a class="markdownIt-Anchor" href="#基本哈希连接"></a> 基本哈希连接</h3><ul><li>阶段1 – 构建：首先，扫描外部关系并使用连接属性上的哈希函数 h1 填充哈希表。哈希表中的键是连接属性。值取决于实现（可以是完整元组值或元组 ID）</li><li>阶段2 - 探测：扫描内部关系并在每个元组的连接属性上使用哈希函数 h1 跳转到哈希表中的相应位置并找到匹配的元组。由于哈希表中可能存在冲突，DBMS 将需要检查连接属性的原始值以确定元组是否真正匹配。</li></ul><p>如果 DBMS 知道外表的大小，则连接可以使用静态哈希表。如果不知道大小，则连接必须使用动态哈希表或允许溢出页面。</p><p>一个有 N 页的表需要大约 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msqrt><mi>N</mi></msqrt></mrow><annotation encoding="application/x-tex">\sqrt N</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.11333499999999996em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9266650000000001em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;padding-left:0.833em;">N</span></span><span style="top:-2.886665em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.11333499999999996em;"><span></span></span></span></span></span></span></span></span> 个缓冲区。上述方法在第 1 阶段创建了最多有 B 个块大小的 B − 1 个溢出分区，因此假设哈希函数均匀分布记录，则可以使用此方法进行哈希处理的最大表是 B · (B − 1) 个缓冲区。如果哈希函数不是均匀的，则可以引入一个模糊因子f&gt;1，因此最大的此类表为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>B</mi><mo>∗</mo><msqrt><mrow><mi>f</mi><mo>∗</mo><mi>N</mi></mrow></msqrt></mrow><annotation encoding="application/x-tex">B * \sqrt{f * N}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.04em;vertical-align:-0.20500000000000007em;"></span><span class="mord sqrt"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.835em;"><span class="svg-align" style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord" style="padding-left:0.833em;"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord mathnormal" style="margin-right:0.10903em;">N</span></span></span><span style="top:-2.795em;"><span class="pstrut" style="height:3em;"></span><span class="hide-tail" style="min-width:0.853em;height:1.08em;"><svg width='400em' height='1.08em' viewBox='0 0 400000 1080' preserveAspectRatio='xMinYMin slice'><path d='M95,702c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-2c4.7,0,8.7,3.3,12,10s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429c69,-144,104.5,-217.7,106.5,-221l0 -0c5.3,-9.3,12,-14,20,-14H400000v40H845.2724s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47zM834 80h400000v40h-400000z'/></svg></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.20500000000000007em;"><span></span></span></span></span></span></span></span></span>。</p><p>探测阶段的一个优化是使用布隆过滤器。这是一个概率数据结构，可以放入 CPU 缓存中，并回答问题“密钥 x 是否在哈希表中？”要么肯定否，要么很可能是。这可以通过阻止不会导致发出元组的磁盘读取来减少磁盘 I/O 量。</p><h3 id="grace-hash-连接分区哈希连接"><a class="markdownIt-Anchor" href="#grace-hash-连接分区哈希连接"></a> Grace Hash 连接/分区哈希连接</h3><p>当表无法放入主内存时，DBMS 必须随机地交换表，这会导致性能不佳。Grace Hash Join 是基本哈希连接的扩展，它还将内表哈希化为写入磁盘的分区。</p><ul><li>阶段1 – 构建：首先，扫描外表和内表，并使用连接属性上的哈希函数 h1 填充哈希表。哈希表的存储桶根据需要写入磁盘。如果内存中无法容纳单个存储桶，则 DBMS 可以使用不同的哈希函数 h2（其中 h1 ̸= h2）进行递归分区，以进一步划分存储桶。此过程可以递归继续，直到内存中容纳所有存储桶为止。</li><li>阶段2 - 探测：对于每个存储桶级别，检索外部表和内表的相应页面。然后，对这两个页面中的元组执行嵌套循环连接。页面可以装入内存，因此此连接操作会很快。</li></ul><p>分割阶段成本:2 * (M + N)</p><p>探测阶段成本：（M + N)</p><p>总成本：3 * （M + N）</p><p>混合哈希连接优化：在基本哈希连接和 Grace 哈希连接之间进行调整；如果键有偏差，则将热分区保留在内存中并立即进行比较，而不是将其溢出到磁盘。很难正确实施。</p><h2 id="5-总结"><a class="markdownIt-Anchor" href="#5-总结"></a> 5 总结</h2><p>连接是与关系数据库交互的重要部分，因此确保 DBMS 具有有效的算法来执行连接至关重要。</p><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E8%BF%9E%E6%8E%A5%E7%AE%97%E6%B3%95/image-20241128211147350.png" alt="图一：上表假设以下情况：M = 1000，m = 100000，N = 500，n= 40000，B = 100 和每个 I/O 0.1 毫秒。" /></p><p>哈希连接几乎总是比基于排序的连接算法更好，但在某些情况下基于排序的连接会更受欢迎。这包括查询非均匀数据、数据已按连接键排序以及结果需要排序的情况。好的 DBMS 会使用其中一种或两种方法。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查询优化</tag>
      
      <tag>连接算法</tag>
      
      <tag>嵌套循环连接</tag>
      
      <tag>哈希连接</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture12</title>
    <link href="/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/"/>
    <url>/2024/11/21/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十二课查询处理i"><a class="markdownIt-Anchor" href="#第十二课查询处理i"></a> 第十二课：查询处理I</h1><h2 id="1-查询计划"><a class="markdownIt-Anchor" href="#1-查询计划"></a> 1 查询计划</h2><p>DBMS将一个SQL语句转换成一个查询计划。查询计划中的操作被整理成一个树。数据从这颗树的叶子流向树根。树的根节点的输出是查询的结果。通常情况下，运算符都是二进制的（1-2 个子运算符）。同一个查询计划可以用多种方式执行。</p><h2 id="2-处理模型"><a class="markdownIt-Anchor" href="#2-处理模型"></a> 2 处理模型</h2><p>DBMS 处理模型定义了系统如何执行查询计划。它指定了诸如查询计划的评估方向以及沿途运算符之间传递的数据类型等内容。存在不同的处理模型，它们针对不同的工作负载有各种权衡。</p><p>这些模型也可以从上到下或从下到上调用操作符来实现。尽管自上而下的方法更为常见，但自下而上的方法可以更严格地控制管道中的缓存/寄存器。</p><p>我们考虑的三种执行模型是：</p><ul><li>迭代器模型</li><li>实例化模型</li><li>矢量化/批处理模型</li></ul><h3 id="迭代器模型"><a class="markdownIt-Anchor" href="#迭代器模型"></a> 迭代器模型</h3><p>迭代器模型，也称为 Volcano 或 Pipeline 模型，是最常见的处理模型，几乎每个（基于行）DBMS 都使用这种模型。</p><p>迭代器模型通过为数据库中的每个运算符实现一个 Next 函数来工作。查询计划中的每个节点都会对其子节点调用 Next，直到到达叶节点，叶节点开始向其父节点发出元组进行处理。然后，在检索下一个元组之前，尽可能按照计划处理每个元组。这在基于磁盘的系统中非常有用，因为它允许我们在访问下一个元组或页面之前充分利用内存中的每个元组。图 1 显示了迭代器模型的示例图。</p><p>迭代器模型中的查询计划运算符具有高度可组合性，并且易于推理。因为每个运算符都可以独立于查询计划树中的父运算符或子运算符实现，只要它实现如下的 Next 函数：</p><ul><li>每次调用 Next 时，如果没有更多元组可发出，则运算符将返回单个元组或空标记。</li><li>该运算符实现一个循环，调用其子运算符上的 Next 来检索它们的元组，然后处理它们。这样，对父节点调用 Next 就会对其子节点调用 Next。作为响应，子节点将返回父节点必须处理的下一个元组。</li></ul><p>迭代器模型允许流水线操作，其中 DBMS 可以通过尽可能多的运算符处理一个元组，然后再检索下一个元组。查询计划中针对给定元组执行的一系列任务称为管道。</p><p>某些运算符会阻塞，直到子运算符发出所有元组。此类运算符的示例包括连接、子查询和排序 (ORDER BY)。此类运算符称为管道断路器。</p><p>输出控制可以通过这种方法（LIMIT）轻松地工作，因为一旦操作员拥有了所需的所有元组，它就可以停止在其子操作员上调用 Next。</p><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241121204121679.png" alt="图一：迭代器模型示例 – 每个运算符的不同 Next 函数的伪代码。Next 函数本质上是 for 循环，迭代其子运算符的输出。例如，根节点在其子节点上调用 Next，即连接运算符，这是一种循环遍历关系 R 并向上发出元组然后进行操作的访问方法。处理完所有元组后，将发送一个空指针（或另一个指示符），让父节点知道继续前进。" /></p><h3 id="实例化模型"><a class="markdownIt-Anchor" href="#实例化模型"></a> 实例化模型</h3><p>实例化模型是迭代器模型的一种特殊化，其中每个运算符一次处理其输入，然后一次发出其输出。每个运算符每次到达时都会返回其所有元组，而不是使用返回单个元组的下一个函数。为了避免扫描太多元组，DBMS 可以将需要多少元组的信息传播给后续操作符（例如 LIMIT）。运算符将其输出“实例化”为单个结果。输出可以是整个元组 (NSM) 或列的子集 (DSM)。图 2 显示了实例化模型的示意图。</p><p>每个查询计划运算符都实现一个Output函数：</p><ul><li>操作立即处理子节点传来的所有元组</li><li>此函数的返回结果是该运算符将发出的所有元组。当该运算符完成执行时，DBMS 无需返回该函数来检索更多数据。</li></ul><p>这种方法更适合OLTP工作负载，因为查询通常一次只访问少量元组。因此，检索元组的函数调用较少。实例化模型不适合具有大量中间结果的 OLAP 查询，因为 DBMS 可能必须在操作员之间将这些结果溢出到磁盘。</p><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%B8%80%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241121210346219.png" alt="图二：实例化模型示例 - 从根开始，调用 child.Output() 函数，该函数调用下面的运算符，返回所有元组。" /></p><h3 id="矢量化模型"><a class="markdownIt-Anchor" href="#矢量化模型"></a> 矢量化模型</h3><p>与迭代器模型一样，矢量化模型中的每个运算符都实现一个 Next 函数。但是，每个运算符都会发出一批数据（即向量），而不是单个元组。运算符的内循环实现针对处理批量数据（而不是一次处理单个数据）进行了优化。批次的大小可能因硬件或查询属性而异。请参阅图 3 中的矢量化模型示例。</p><p>矢量化模型方法非常适合需要扫描大量元组的 OLAP 查询，因为 Next 函数的调用次数较少。</p><p>矢量化模型使得操作能够更轻松地使用矢量化（SIMD）指令来处理批量元组。</p><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241123234749040.png" alt="图三：矢量化模型样例-矢量化模型与迭代器模型非常相似，不同之处在于，每个操作符都会将输出缓冲区与所需的发射大小进行比较。如果缓冲区较大，则发送元组批次。" /></p><h3 id="操作方向"><a class="markdownIt-Anchor" href="#操作方向"></a> 操作方向</h3><ul><li>方式一：自顶向下<ul><li>从根开始，将数据从子节点“拉”到父节点</li><li>元组总是通过函数调用传输</li></ul></li><li>方式二：自底向上<ul><li>从叶节点开始，将数据从子节点“推送”到父节点</li><li>允许更严格地控制操作管道中的缓存/寄存器</li></ul></li></ul><h2 id="3-访问方法"><a class="markdownIt-Anchor" href="#3-访问方法"></a> 3 访问方法</h2><p>访问方法是 DBMS 访问表中存储的数据的方式。一般来说，访问模型有两种方法：要么从表中读取数据，要么通过顺序扫描从索引中读取数据。</p><h3 id="顺序扫描"><a class="markdownIt-Anchor" href="#顺序扫描"></a> 顺序扫描</h3><p>顺序扫描运算符遍历表中的每个页面并从缓冲池中检索它。当扫描遍历每个页面上的所有元组时，它会评估谓词以决定是否将元组发送给下一个运算符。</p><p>DBMS 维护一个内部游标，用于跟踪其检查的最后一页/槽。</p><p>顺序表扫描几乎始终是 DBMS 执行查询时效率最低的方法。有许多优化方法可帮助加快顺序扫描速度：</p><ul><li><strong>预读取</strong>：提前获取接下来的几页，以便 DBMS 在访问每个页面时不必阻塞存储 I/O。</li><li><strong>缓存池绕过</strong>：扫描操作符将从磁盘获取的页面存储在其本地内存中而不是缓冲池中，以避免顺序洪泛。</li><li><strong>并行化</strong>：使用多个线程/进程并行执行扫描。</li><li><strong>慢实例化</strong>：DBMS 可以将元组的拼接延迟到查询计划的上部。这样每个操作符都可以将所需的最少信息传递给下一个操作符（例如记录 ID、列中记录的偏移量）。这仅在列存储系统中有用。</li><li><strong>堆聚类</strong>：元组按照聚类索引指定的顺序存储在堆页中。</li><li><strong>近似查询（跳过有损数据）</strong>：对整个表的抽样子集执行查询以产生近似结果。这通常用于在允许低误差产生近乎准确的答案的场景中计算聚合。</li><li><strong>区域图（无损数据跳过）</strong>：预先计算页面中每个元组属性的聚合。然后，DBMS 可以通过首先检查区域图来决定是否需要访问页面。每个页面的区域图存储在单独的页面中，并且每个区域图页面中通常有多个条目。因此，可以减少连续扫描中检查的总页面数。区域图在云数据库系统中尤其有价值，因为通过网络传输数据会产生更大的成本。参见图 4 的区域地图示例。</li></ul><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241127205536313.png" alt="图四：区域图样例 – 区域图存储页面中值的预先计算的聚合。在上面的示例中，选择查询从区域图中得知，原始数据中的最大值只有 400.然后，查询就不必遍历页面中的每个元组，而是可以完全避免访问该页面，因为没有任何值大于 600。" /></p><h3 id="索引扫描"><a class="markdownIt-Anchor" href="#索引扫描"></a> 索引扫描</h3><p>在索引扫描中，DBMS 选择一个索引来查找查询所需的元组。</p><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241127210523298.png" alt="图五：索引扫描样例 – 考虑一个包含 100 个元组和两个索引（年龄和部门）的单表。在第一种情况下，最好在扫描中使用部门索引，因为它只有两个元组需要匹配。选择 age 索引并不会比简单的顺序扫描好多少。在第二种情况下，age 索引会消除更多不必要的扫描，是最佳选择。" /></p><p>DBMS 的索引选择过程涉及许多因素，包括：</p><ul><li>索引包含哪些属性</li><li>查询引用了哪些属性</li><li>属性的值域</li><li>谓词组合</li><li>索引是否具有唯一键或非唯一键</li></ul><p>图 5 显示了索引扫描的一个简单示例。</p><p>更高级的 DBMS 支持多索引扫描。当对查询使用多个索引时，DBMS 会使用每个匹配的索引计算记录 ID 集，根据查询的谓词组合这些集合，然后检索记录并应用可能保留的任何谓词。DBMS 可以使用位图、哈希表或布隆过滤器通过集合交集计算记录 ID。请参阅图 6 中利用多索引扫描的示例。</p><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241128155039980.png" alt="图六：多索引扫描示例 – 考虑图 5 中的同一张表。借助多索引扫描支持，我们首先使用相应的索引分别计算满足年龄和部门谓词的记录 ID 集。然后，我们计算两个集合的交集，获取相应的记录，并应用剩余的谓词 country=’US’。" /></p><h2 id="4-修改查询"><a class="markdownIt-Anchor" href="#4-修改查询"></a> 4 修改查询</h2><p>修改数据库（INSERT、UPDATE、DELETE）的操作员负责检查约束和更新索引。对于UPDATE/DELETE，子操作符传递目标元组的记录ID，并且必须跟踪先前看到的元组。</p><p>关于如何处理 INSERT 运算符有两种实现选择：</p><ul><li>选择1：在运算符内部实现元组。</li><li>选择2：运算符插入从子运算符传入的任何元组。</li></ul><h3 id="万圣节问题"><a class="markdownIt-Anchor" href="#万圣节问题"></a> 万圣节问题</h3><p>万圣节问题是一种异常现象，其中更新操作会更改元组的物理位置，从而导致扫描运算符多次访问该元组。这可能发生在聚簇表或索引扫描上。</p><p>这一现象最初是由 IBM 研究人员在 1976 年万圣节当天构建 System R 时发现的。解决此问题的方法是跟踪每个查询的修改记录 ID。</p><h2 id="5-表达式求值"><a class="markdownIt-Anchor" href="#5-表达式求值"></a> 5 表达式求值</h2><p>DBMS 将 WHERE 子句表示为表达式树（参见图 7 中的示例）。树中的节点表示不同的表达式类型。</p><p><img src="../imgs/%E7%AC%AC%E5%8D%81%E4%BA%8C%E8%AF%BE%EF%BC%9A%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86I/image-20241128160655862.png" alt="图 7：表达式求值示例 – WHERE 子句及其对应表达式的图表。" /></p><p>可以存储在树节点中的表达式类型的一些示例：</p><ul><li>比较（=、&lt;、&gt;、!=）</li><li>连接 (AND)、分离 (OR)</li><li>算术运算符（+、-、*、/、%）</li><li>常量和参数值</li><li>元组属性引用</li></ul><p>为了在运行时评估表达式树，DBMS 维护一个上下文句柄，其中包含执行的元数据，例如当前元组、参数和表架构。然后，DBMS 遍历树来评估其运算符并产生结果。</p><p>以这种方式评估谓词很慢，因为 DBMS 必须遍历整个树并确定每个运算符要采取的正确操作。更好的方法是直接评估表达式（想想 JIT 编译）。基于内部成本模型，DBMS 将确定是否采用代码生成来加速查询。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>查询优化</tag>
      
      <tag>查询处理</tag>
      
      <tag>执行模型</tag>
      
      <tag>迭代器模型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture10</title>
    <link href="/2024/11/19/%E7%AC%AC%E5%8D%81%E8%AF%BE%EF%BC%9A%E6%8E%92%E5%BA%8F%E5%92%8C%E8%81%9A%E5%90%88%E7%AE%97%E6%B3%95/"/>
    <url>/2024/11/19/%E7%AC%AC%E5%8D%81%E8%AF%BE%EF%BC%9A%E6%8E%92%E5%BA%8F%E5%92%8C%E8%81%9A%E5%90%88%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第十课排序和聚合算法"><a class="markdownIt-Anchor" href="#第十课排序和聚合算法"></a> 第十课：排序和聚合算法</h1><h2 id="1-排序"><a class="markdownIt-Anchor" href="#1-排序"></a> 1 排序</h2><p>DBMS 需要对数据进行排序，因为表中的元组在关系模型下没有特定的顺序。排序（可能）用于 ORDER BY、GROUP BY、JOIN 和 DISTINCT 运算符。如果需要排序的数据适合内存，那么 DBMS 可以使用标准排序算法（例如，快速排序）。如果数据不适合，那么 DBMS 需要使用外部排序，该排序可以根据需要溢出到磁盘，并且优先选择顺序 I/O 而不是随机 I/O。</p><p>如果查询包含带有 LIMIT 的 ORDER BY，则 DBMS 只需扫描数据一次即可找到前 N 个元素。这称为 Top-N 堆排序。堆排序的理想情况是前 N 个元素适合内存，这样 DBMS 在扫描数据时只需维护内存中的排序优先级队列。对于内存中容纳不了的庞大数据进行排序的标准算法是外部合并排序。它是一种分而治之的排序算法，将数据集拆分为单独的运行，然后单独对它们进行排序。它可以根据需要将运行溢出到磁盘，然后一次读回一个。该算法由两个阶段组成：</p><ol><li>排序：首先，该算法对适合主内存的小块数据进行排序，然后将排序后的页面写回磁盘。</li><li>合并：然后，该算法将排序后的子文件组合成一个更大的文件。</li></ol><h3 id="双向归并排序"><a class="markdownIt-Anchor" href="#双向归并排序"></a> 双向归并排序</h3><p>该算法最基本的版本是双向合并排序。该算法在排序阶段读取每个页面，对其进行排序，然后将排序后的版本写回磁盘。然后，在合并阶段，它使用三个缓冲页。它从磁盘读取两个已排序的页面，并将它们合并到第三个缓冲页中。它从磁盘读取两个已排序的页面，并将它们合并到第三个缓冲页面中。每当第三个页面填满时，它就会被写回磁盘并替换为空白页。每组排序好的页面称为一个运行。然后，算法会以递归方式将这些运行合并在一起。</p><p>如果 N 是数据页的总数，则该算法将总共遍历数据 1 +⌈logN⌉ 次（第一步排序为 1，然后递归合并为 ⌈logN⌉ 次）。总 I/O 成本为 2N ×（传递次数），因为每次传递对每个页面执行一次 I/O 读取和一次 I/O 写入。</p><h3 id="通用k路归并排序"><a class="markdownIt-Anchor" href="#通用k路归并排序"></a> 通用（K路）归并排序</h3><p>该算法的通用版本允许 DBMS 使用三个以上的缓冲页。设 B 为可用的缓冲页总数。然后，在排序阶段，算法可以一次读取 B 页，并将 ⌈N/B⌉ 个已排序的运行写回到磁盘。合并阶段还可以在每次传递中组合最多 B - 1 次运行，再次使用一个缓冲页面来存储组合数据并根据需要写回磁盘。在广义版本中，该算法执行 ⌈1 + log<sub>B-1</sub> ⌈N/B⌉⌉ 次传递（一次用于排序阶段，log<sub>B-1</sub> ⌈N/B⌉次用于合并阶段）。然后，总 I/O 成本为 2N ×（传递次数），因为它必须在每次传递中对每个页面进行读取和写入。</p><h3 id="双缓冲优化"><a class="markdownIt-Anchor" href="#双缓冲优化"></a> 双缓冲优化</h3><p>外部合并排序的一个优化是在系统处理当前运行的同时，在后台预取下一次运行并将其存储在第二个缓冲区中。通过持续利用磁盘，这可以减少每一步 I/O 请求的等待时间。此优化需要使用多个线程，因为预取应该在当前运行的计算过程中进行。</p><h3 id="使用b树"><a class="markdownIt-Anchor" href="#使用b树"></a> 使用B+树</h3><p>对于 DBMS 来说，使用现有的 B+ 树索引来辅助排序有时比使用外部合并排序算法更有优势。具体来说，如果索引是聚集索引，则 DBMS 只需遍历 B+ 树即可。由于索引是聚集的，因此数据将以正确的顺序存储，因此 I/O 访问将是连续的。这意味着它总是比外部合并排序更好，因为不需要计算。另一方面，如果索引是非聚集的，则遍历树几乎总是更糟糕，因为每个记录可以存储在任何页面中，因此几乎所有记录访问都需要读取磁盘。</p><h2 id="2-聚合"><a class="markdownIt-Anchor" href="#2-聚合"></a> 2 聚合</h2><p>查询计划中的聚合运算符将一个或多个元组的值折叠为单个标量值。有两种方法可以实现聚合：(1) 排序和 (2) 哈希。</p><h3 id="排序"><a class="markdownIt-Anchor" href="#排序"></a> 排序</h3><p>DBMS 首先根据 GROUP BY 键对元组进行排序。如果缓冲池中所有内容都适合，则可以使用内存排序算法（例如快速排序），如果数据大小超出内存，则使用外部合并排序算法。然后，DBMS 对排序后的数据执行顺序扫描以计算聚合。运算符的输出将按键排序。</p><p>执行排序聚合时，对查询操作进行排序以最大限度提高效率非常重要。例如，如果查询需要过滤，则最好先执行过滤，然后对过滤后的数据进行排序，以减少需要排序的数据量。</p><h3 id="哈希"><a class="markdownIt-Anchor" href="#哈希"></a> 哈希</h3><p>对于计算聚合而言，散列比排序更节省计算成本。DBMS 在扫描表时会填充临时哈希表。对于每条记录，检查哈希表中是否已经存在条目，并执行适当的修改。如果哈希表的大小太大而无法放入内存中，则 DBMS 必须将其溢出到磁盘。实现此操作分为两个阶段：</p><ul><li>分区：使用哈希函数 h1 根据目标哈希键将元组拆分为磁盘上的分区。这会将所有匹配的元组放入同一个分区。DBMS 通过输出缓冲区将分区溢出到磁盘。</li><li>再哈希：对于磁盘上的每个分区，将其页面读入内存，并基于第二个哈希函数 h2（其中 h1 ！= h2）构建内存哈希表。然后遍历该哈希表的每个存储桶，将匹配的元组汇集在一起以计算聚合。这假设每个分区都适合内存。</li></ul><p>在 ReHash 阶段，DBMS 可以存储形式 (GroupByKey→RunningValue) 的对来计算聚合。RunningValue 的内容取决于聚合函数。要将新元组插入哈希表：</p><ul><li>如果找到匹配的 GroupByKey，则适当更新 RunningValue。</li><li>否则插入一个新的 (GroupByKey→RunningValue) 对。</li></ul>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>DBMS</tag>
      
      <tag>元组聚合</tag>
      
      <tag>元组排序算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LSM-Tree</title>
    <link href="/2024/11/19/The%20Log-Structured%20Merge-Tree(LSM-Tree)/"/>
    <url>/2024/11/19/The%20Log-Structured%20Merge-Tree(LSM-Tree)/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id=""><a class="markdownIt-Anchor" href="#"></a> </h1><h1 id="the-log-structured-merge-treelsm-tree"><a class="markdownIt-Anchor" href="#the-log-structured-merge-treelsm-tree"></a> The Log-Structured Merge-Tree(LSM-Tree)</h1><h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>高性能事务系统应用程序通常会在历史记录表中插入行，以提供活动跟踪，同时这个事务系统会产生日志记录用作系统恢复。两种类型的生成信息都可以从高效索引中受益。一个众所周知的例子是 TPC-A 基准应用程序，它经过修改以支持对特定帐户的帐户活动历史记录进行有效查询。这需要在快速增长的历史记录表上按帐户 ID 建立索引。遗憾的是，标准的基于磁盘的索引结构（例如 B 树）将有效地使实时维护此类索引的事务 I/O 成本加倍，从而使总系统成本增加高达百分之五十。显然，需要一种以低成本维护实时索引的方法。日志结构合并树 (LSM 树) 是一种基于磁盘的数据结构，旨在为长期经历高记录插入（和删除）率的文件提供低成本索引。LSM 树使用一种延迟和批量处理索引更改的算法，以一种类似于合并排序的有效方式将更改从基于内存的组件级联到一个或多个磁盘组件。在此过程中，所有索引值都可以通过内存组件或磁盘组件之一持续检索（除了非常短暂的锁定期）。该算法与传统的访问方法（如B树）相比，极大地减少了磁盘臂的运动次数，并将提高在那些传统访问方法中磁盘臂成本对于插入操作超过存储介质成本的领域中的性价比。LSM 树方法还可以推广到插入和删除以外的操作。但是，需要立即响应的索引查找在某些情况下会损失 I/O 效率，因此 LSM 树在索引插入比检索条目的查找更常见的应用程序中最为有用。例如，这似乎是历史表和日志文件的共同属性。第 6 节的结论将 LSM 树访问方法中内存和磁盘组件的混合使用与人们通常理解的在内存中缓冲磁盘页面的混合方法的优势进行了比较。</p>]]></content>
    
    
    <categories>
      
      <category>misc</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储结构</tag>
      
      <tag>数据库</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Paxos Made Simple</title>
    <link href="/2024/10/09/Paxos%20Made%20Simple/"/>
    <url>/2024/10/09/Paxos%20Made%20Simple/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="paxos-made-simple"><a class="markdownIt-Anchor" href="#paxos-made-simple"></a> Paxos Made Simple</h1><center><h2>摘要</h2></center><center><font color='IndianRed'>Paxos 算法用简单的英语表达时非常简单。</font></center><h2 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h2><p>用于实现容错分布式系统的 Paxos 算法一直被认为难以理解，可能是因为许多读者最初看的是希腊语。事实上，它是最简单、最明显的分布式算法之一。其核心是共识算法——“synod”算法。下一节将展示这种共识算法几乎不可避免地遵循我们希望它满足的属性。最后一部分将解释完整的Paxos算法。这个算法是通过将共识算法直接应用到构建分布式系统的有限状态机方法中得到的。这种方法应该是众所周知的，因为它是分布式系统理论中被引用次数最多的文章的主题。</p><h2 id="2-共识算法"><a class="markdownIt-Anchor" href="#2-共识算法"></a> 2 共识算法</h2><h3 id="21-问题"><a class="markdownIt-Anchor" href="#21-问题"></a> 2.1 问题</h3><p>假设可以提出价值的进程集合。共识算法确保选择提出值中的一个。如果没有提出任何值，则不应选择任何值。如果已经选择了一个值，那么进程应该能够学习所选的值。共识的安全要求是：</p><ul><li>只能选出已提议的值</li><li>只有一个值能被选出</li><li>进程永远不会知道某个值已被选出，除非它确实已被选出。</li></ul><p>我们不会尝试指定精确的存活要求。但是，目标是确保最终选择某个建议值，并且如果选择了某个值，则进程最终可以学习该值。</p><p>我们让共识算法中的三个角色由三类代理来执行：proposer、acceptor和learner。在一种实现中，单个进程可以充当多个代理，但这里我们不关心从代理到进程的映射。</p><p>假设代理能通过发送消息来相互通信。我们使用惯用的异步、非拜占庭模型，其中</p><ul><li>代理以任意速度运行，可能因停止而失败，也可能重新启动。由于在选择一个值然后重新启动后所有代理都可能会失败，因此除非已失败并重新启动的代理可以记住某些信息，否则解决方案是不可能的。</li><li>消息的传送时间可以任意长，可以重复，也可以丢失，但它们不会被破坏。</li></ul><h3 id="22-选择值"><a class="markdownIt-Anchor" href="#22-选择值"></a> 2.2 选择值</h3><p>选择值的最简单方法是使用单个接受代理。提议者向接受者发送提议，接受者选择收到的第一个提议值。虽然简单，但这个解决方案并不令人满意，因为接受者的失败使得任何进一步的进展都不可能。</p><p>因此，让我们尝试另一种选择值的方法。让我们使用多个接受者代理，而不是单个接受者。提议者将提议值发送给一组接受者。接受者可以接受提议的值。当足够多的接受者接受该值时，就会选择该值。多大才算足够够？为了确保只选择一个值，我们可以让一个足够大的集合由任意大多数代理组成。因为任何两个多数都至少有一个共同的接受者，所以如果接受者最多可以接受一个值，那么这种方法就有效。（在许多论文中都观察到了大多数的明显概括，显然是从Leslie Lampor开始的）</p><p>在没有失败或消息丢失的情况下，即使单个提议者只提出一个值，我们也希望选择一个值。这表明了要求：</p><blockquote><p><font color='purple'>P1 接受者必须接受它收到的第一个提案</font></p></blockquote><p>但这个要求带来了一个问题。不同的提议者可能会在同一时间提出多个值，从而导致每个接受者都接受了一个值，但没有一个值被大多数接受者接受的情况。即使只有两个提议的值，如果每个值都被大约一半的接受者接受，那么单个接受者的失败可能会导致无法了解选择了哪个值。</p><p>P1 以及仅当大多数接受者接受时才选择某个值的要求意味着必须允许接受者接受多个提案。我们通过为每个提案分配一个（自然）编号来跟踪接受者可能接受的不同提案，因此提案由提案编号和值组成。为了防止混淆，我们要求不同的提案有不同的编号。如何实现取决于其实现，至今为止我们只是假设。当具有该值的单个提案被大多数接受者接受时，就会选择一个值。在这种情况下，我们说该提案（及其价值）已被选择。</p><p>我们可以允许选择多个提案，但我们必须保证所有选择的提案具有相同的值。通过对提案编号进行归纳，足以保证：</p><blockquote><p><font color='purple'>P2<sup>a</sup> 如果选择了值为 v 的提案，则选择的每个编号较高的提案都具有值 v。</font></p></blockquote><p>我们仍然维护 P1 以确保选择某些提案。由于通信是异步的，因此可以选择某个从未收到过任何提案的特定接受者的提案。假设一个新的提议者“启动”并发布了一个具有不同值的更高编号的提议。P1 要求 c 接受该提案，违反了 P2<sup>a</sup> 。维持 P1 和 P2<sup>a</sup> 需要加强 P2<sup>a</sup> 以：</p><blockquote><p><font color='purple'>P2<sup>b</sup> 如果选择了值为 v 的提案，则任何提案者发布的每个编号较高的提案都具有值 v。</font></p></blockquote><p>由于提案必须由提案者发出才能被接受者接受，因此 P2<sup>b</sup> 意味着 P2<sup>a</sup> ，而 P2<sup>a</sup> 又意味着 P2 。</p><p>为了发现如何满足 P2<sup>b</sup>，让我们考虑如何证明它成立。我们假设选择了一些编号为 m 且值为 v 的提案，并表明任何编号为 n &gt; m 的提案也具有值 v。为了使证明过程更简单，我们通过在 n 上使用归纳法来进行，这样我们就可以证明在额外假设下，编号为 n 的提案具有值 v，即假设在 m 到 n-1 之间的每个编号的提案都具有值 v，其中 i : :j 表示从 i 到 j 的一系列数字集合。对于要选择的编号为 m 的提案，必须存在某个由大多数接受者组成的集合 C，使得 C 中的每个接受者都接受它。将此与归纳假设相结合，选择 m 的假设意味着：</p><blockquote><p><font color = 'purple'>C 中的每个接受者都接受了编号为 m ~ (n - 1) 的提案，并且任何接受者接受的编号为 m ~ (n - 1) 的提案的值含有 v。</font></p></blockquote><p>由于任何由大多数接受者组成的集合 S 至少包含 C 的一个成员，因此我们可以通过确保维持以下不变量来得出结论，编号为 n 的提案具有值 v：</p><blockquote><p><span style="color: purple;"> P2<sup>c</sup> 对于任意的值v和编号n，如果发出了一个带有值v和编号n的提案，那么存在一个由大多数接受者组成的集合S，满足以下条件之一：<br> a. 集合S中的任何接受者都没有接受过编号小于n的任何提案。<br> b. 值v是集合S中的接受者所接受的所有编号小于n的提案中编号最高的那个提案的值。 </span></p></blockquote><p>因此，我们可以通过保持 P2<sup>c</sup> 的不变性来满足 P2<sup>b</sup> 。</p><p>为了保持 P2<sup>c</sup> 的不变性，想要发布编号为 n 的提案的提案者必须学习编号小于 n 的最高编号提案（如果有的话），该提案已经或将被每个接受者以某种多数接受。了解已经被接受的提案很容易；预测未来的接受情况却很难。提议者并不试图预测未来，而是通过做出不会发生此类接受的承诺来控制未来。换句话说，提议者要求接受者不再接受任何编号小于 n 的提案。这导致了以下发布提案的算法：</p><ol><li><p>提议者选择一个新的提议编号 n，并向某个接受者集合中的每个成员发送请求，要求其做出以下回应：</p><ol><li>承诺不再接受编号小于 n 的提案，并且</li><li>已接受的小于 n 的最大数字的提案（如果有）。</li></ol><p>我将这样的请求称为编号为 n 的准备请求。</p></li><li><p>如果提议者从大多数接受者那里收到了请求的响应，那么它可以发出一个编号为n、值为v的提案，其中v是响应中编号最高的提案的值，或者如果响应者没有报告任何提案，v可以是提议者选择的任何值。</p></li></ol><p>提议者通过向一组接受者发送接受提议的请求来发布提议。（这不需要是响应初始请求的同一组接受器）我们将其称为接受请求。</p><p>这描述了提议者的算法。那么接受者呢？它可以接收来自提议者的两种请求：准备请求和接受请求。接受器可以忽略任何请求而不会影响安全性。因此，我们只需要说明何时允许它响应请求。它总是可以响应准备请求。它可以响应接受请求，接受提议，前提是它没有承诺不这样做。换句话说：</p><blockquote><p><font color = 'purple'>P1<sup>a</sup> 如果接受者没有响应过编号大于n的准备请求，那么它可以接受一个编号为n的提案。</font></p></blockquote><p>观察到 P1<sup>a</sup> 包含 P1。</p><p>我们现在有一个完整的算法来选择一个满足所需安全属性的值——假设唯一的提案编号。通过一次小优化得到了最终的算法。</p><p>假设一个接受者收到一个编号为 n 的准备请求，但是它已经响应了一个编号大于 n 的准备请求，从而承诺不接受任何新的编号为 n 的提议。那么接受者就没有理由响应新的准备请求，因为它不会接受提议者想要发布的编号为 n 的提案。因此，我们让接受者忽略此类准备请求。我们还让接受者忽略已接受提案的准备请求。</p><p>通过这种优化，接受者只需要记住它曾经接受过的编号最高的提案，以及它响应过的编号最高的准备请求的编号。因为 P2<sup>c</sup>无论发生什么故障都必须保持不变，所以即使接受器发生故障然后重新启动，它也必须记住此信息。请注意，提议者可以随时放弃一项提议并忘记它——只要它永远不会尝试发布具有相同编号的另一个提议。</p><p>将提议者和接受者的行为放在一起，我们看到该算法分为以下两个阶段运行。</p><p><strong>阶段一：</strong></p><p>（a）提议者选择一个提案编号 n，并向大多数接受者发送编号为 n 的准备请求</p><p>（b）如果接受者收到一个准备请求，其编号 n 大于它已经响应的任何准备请求的编号，然后它承诺不再接受任何编号小于 n 的提案，并接受已接受的编号最高的提案（如果有）。</p><p><strong>阶段二：</strong></p><p>（a）如果提议者收到大多数接受者对其准备请求（编号为 n）的回应，然后它向每个接受者发送接受请求，以获得编号为 n 且值为 v 的提案，其中 v 是响应中编号最高的提案的值，如果响应未报告任何提案，则为任何值。</p><p>（b）如果接受者收到针对编号为 n 的提案的接受请求，则会接受该提案，除非它已经响应了编号大于 n 的准备请求。</p><p>提议者可以提出多个提议，只要它遵循每个提议的算法即可。它可以在协议执行过程中随时放弃提议。（即使该提案的请求和/或响应可能在该提案被放弃很久之后才到达目的地，正确性仍然得到保持）。如果某个提议者开始尝试发布编号更高的提议，那么放弃该提议可能是个好主意。因此，如果接受者因为已经收到具有更高编号的准备请求而忽略了准备或接受请求，那么它可能应该通知提议者，然后提议者应该放弃其提议。这是一个性能优化，不会影响正确性。</p><h3 id="23-学习所选值"><a class="markdownIt-Anchor" href="#23-学习所选值"></a> 2.3 学习所选值</h3><p>要了解某个值已被选定，学习者必须发现该提议已被大多数接受者接受。显而易见的算法是让每个接受者在接受提案时响应所有学习者并向他们发送提案。这使得学习者能够尽快找到所选的值，但要求每个接受者对每个学习者做出响应——响应数量等于接受者数量与学习者数量的乘积。</p><p>非拜占庭故障的假设使得一个学习者很容易从另一个学习者那里发现一个值已被接受。我们可以让接受者向杰出的学习者做出接受的回应，当某个值被选中时，该学习者又会通知其他学习者。这种方法需要所有学习者额外进行一轮来发现所选的值。它的可靠性也较低，因为杰出的学习者可能会失败。但它要求的响应数量仅等于接受者数量和学习者数量的总和。</p><p>更一般地，接受者可以对一些杰出的学习者做出接受的回应，每个学习者都可以在选择值时通知所有学习者。使用更大的区分集的学习者以更大的沟通复杂性为代价提供更高的可靠性。</p><p>由于消息丢失，可能存在一个值被选定了，但没有任何一个学习者能够得知。学习者可以询问接受者他们接受了哪些提议，但是接受者的失败可能导致无法知道大多数人是否接受了杰出的提议。在这种情况下，只有当一个新的提案被选中时，学习者才会发现选择了什么值。如果学习者需要知道某个值是否已被选中，它可以让提议者使用上面描述的算法提出一个提议。</p><h3 id="24-过程"><a class="markdownIt-Anchor" href="#24-过程"></a> 2.4 过程</h3><p>很容易构建这样一种场景，其中两个提议者各自不断发布一系列编号不断增加的提议，但没有一个被选中。提议者 p 完成提案编号为 n1 的第 1 阶段。然后，另一个提议者 q 完成提案编号为 n2 &gt; n1 的第 1 阶段。提议者 p 对编号为 n1 的提案的第 2 阶段接受请求被忽略，因为接受者都承诺不接受任何编号小于 n2 的新提案。因此，提议者 p 开始并完成阶段 1，新提议编号为 n3 &gt; n2，导致提议者 q 的第二个阶段 2 接受请求被忽略。依此类推。</p><p>为了保证进展，必须选择一位杰出的提议者作为唯一尝试发布提案的人。如果杰出的提议者能够与大多数接受者成功沟通，并且它使用的提议的数量大于任何已经使用的提议，那么它将成功发布被接受的提议。如果发现某个请求的提案编号更高，则通过放弃提案并重试，杰出的提案者最终将选择一个足够高的提案编号。</p><p>如果系统（提议者、接受者和通信网络）的大部分正常运行，那么就可以通过选举一位杰出的提议者来实现活跃性。菲舍尔（Fischer）、林奇（Lynch）和帕特森（Paterson）的著名成果意味着，选举提议者的可靠算法必须使用随机性或实时性——例如，使用超时。但无论选举成功或失败，安全都是有保障的。</p><h3 id="25-实现"><a class="markdownIt-Anchor" href="#25-实现"></a> 2.5 实现</h3><p>Paxos 算法假设一个进程网络。在其共识算法中，每个进程都扮演提议者、接受者和学习者的角色。算法选择一个领导者，该领导者扮演着杰出提议者和杰出学习者的角色。Paxos 共识算法正是上面描述的算法，其中请求和响应都作为普通消息发送。（响应消息标有相应的提案编号以避免混淆。）稳定存储用于在故障期间保存，用于维护接受器必须记住的信息。接受器在实际发送响应之前将其预期响应记录在稳定存储中。</p><p>剩下的就是描述保证不会发布两个具有相同编号的提案的机制。不同的提议者从不相交的数字集中选择他们的数字，因此两个不同的提议者永远不会提出具有相同数字的提案。每个提议者都会记住（在稳定存储中）它尝试发布的最高编号的提议，并以比它已经使用过的任何提议编号更高的提议编号开始第 1 阶段。</p><h2 id="3-实现状态机"><a class="markdownIt-Anchor" href="#3-实现状态机"></a> 3 实现状态机</h2><p>实现分布式系统的一个简单方法是作为向中央服务器发出命令的客户端集合。服务器可以被描述为一个按照某种顺序执行客户端命令的确定性状态机。状态机具有当前状态；它通过将命令作为输入并产生输出和新状态来执行步骤。例如，分布式银行系统的客户可能是出纳员，状态机状态可能由所有用户的账户余额组成。提款是通过执行状态机命令来执行的，当且仅当账户余额大于提款金额时，该命令才会减少账户余额，并输出新旧余额。</p><p>如果使用单个中央服务器的实现在该服务器发生故障时也会失败。因此，我们使用一组服务器，每个服务器都独立实现状态机。因为状态机是确定性的，所以如果所有服务器都执行相同的命令序列，那么所有服务器将产生相同的状态和输出序列。发出命令的客户端可以使用任何服务器为其生成的输出。</p><p>为了保证所有服务器执行相同的状态机命令序列，我们实现了 Paxos 共识算法的独立实例序列，第 i 个实例选择的值是序列中的第 i 个状态机命令。每个服务器在算法的每个实例中扮演所有角色（提议者、接受者和学习者）。目前，我假设服务器集是固定的，因此共识算法的所有实例都使用相同的代理集合。</p><p>在正常操作中，会选举出一个单独的服务器作为领导者，这个领导者在共识算法的所有实例中充当杰出的提议者（唯一尝试发出提议的一方）。客户端将命令发送给领导者，领导者决定每个命令在序列中的出现位置。如果领导者决定某个客户端命令应该是第 135 个命令，它会尝试选择该命令作为共识算法的第 135 个实例的值。这通常会成功，它可能因为宕机而失败，或者因为另一个服务器也认为自己是领导者，并且对第 135 个命令应该是什么有不同的看法。但是共识算法确保最多可以选择一个命令作为第 135 个命令。</p><p>这种方法效率的关键在于，在 Paxos 共识算法中，要提议的值直到第 2 阶段才会被选择。回想一下，在完成提议者算法的第 1 阶段后，要么确定要提议的值，要么提议者可以自由提议任何值。</p><p>现在，我将介绍 Paxos 状态机实现在正常操作期间的工作原理。稍后，我将讨论可能出错的内容。我会考虑当前任领导者刚刚失败并且选择了新的领导者时会发生什么。（系统启动是一种特殊情况，尚未提出任何命令）。</p><p>新领导者是共识算法的所有实例的学习者，应该知道已经选择的大多数命令。假设它知道命令 1-134、138 和 139，即共识算法的实例 1-134、138 和 139 中选择的值。（我们稍后将看到命令序列中的这种差距是如何出现的。然后，它执行实例 135-137 的阶段 1 以及所有大于 139 的实例。（我将在下面描述如何做到这一点。假设这些执行的结果确定了要在实例 135 和 140 中建议的值，但在所有其他实例中使建议的值不受约束。然后，领导者对实例 135 和 140 执行阶段 2，从而选择命令 135 和 140。</p><p>领导服务器以及学习领导服务器知道的所有命令的任何其他服务器现在可以执行命令 1-135。但是，它无法执行命令 138–140，它也知道这一点，因为尚未选择命令 136 和 137。领导者可以将客户端请求的接下来的两个命令视为命令 136 和 137。相反，我们让它立即填补空白，如命令 136 和 137，一个特殊的 “no-op” 命令，保持状态不变。（它通过执行共识算法的实例 136 和 137 的第 2 阶段来实现此目的。选择这些 no-op 命令后，可以执行命令 138-140。</p><p>命令 1-140 现已选定。领导者还完成了所有大于 140 个共识算法的实例的第 1 阶段，并且可以在这些实例的第 2 阶段中自由提出任何值。它将命令编号 141 分配给客户端请求的下一个命令，并将其建议作为共识算法实例 141 的第 2 阶段中的值。它建议将接收的下一个客户端命令作为命令 142，依此类推。</p><p>领导者可以在得知其建议的命令 141 已被选中之前提出命令 142。它在提议命令 141 时发送的所有消息都有可能丢失，并且命令 142 可能在任何其他服务器了解领导者提议的命令 141 之前被选择。当 leader 在实例 141 中未能收到对其第 2 阶段消息的预期响应时，它将重新传输这些消息。如果一切顺利，将选择其提议的命令。但是，它可能会首先失败，从而在所选命令的序列中留下空白。通常，假设领导者可以提前获取 α 命令，也就是说，它可以在选择命令 1 到 i 之后提出命令 i + 1 到 i+α。然后可能会出现高达 α-1 个命令的差距。</p><p>新选择的领导对共识算法的无限多个实例执行阶段 1 — 在上面的场景中，实例 135-137 和所有大于 139 的实例。对所有实例使用相同的提议编号，它可以通过向其他服务器发送一条合理的短消息来实现此目的。在阶段 1 中，仅当接受者已经收到来自某个提议者的阶段 2 消息时，接受者才会以不简单的 OK 进行响应。（在此方案中，仅实例 135 和 140 出现这种情况。因此，服务器（充当接受者）可以使用一条合理短的消息响应所有实例。因此，执行阶段 1 的这些无限多个实例不会造成问题。</p><p>由于领导者失败和新领导者的选举应该是罕见的事件，因此执行状态机命令（即就命令/值达成共识）的有效成本是仅执行共识算法的第 2 阶段的成本。可以证明，Paxos 共识算法的第 2 阶段在存在故障的情况下达成协议的成本是任何算法中最低的。因此，Paxos 算法本质上是最优的。</p><p>对系统正常运行的讨论假设始终只有一个领导者，除了当前领导者失败和新领导者选举之间的短暂时期。在异常情况下，leader 选举可能会失败。如果没有服务器充当 leader，则不会提出新命令。如果多个服务器认为他们是领导者，那么他们都可以在共识算法的同一实例中提出值，这可能会阻止选择任何值。但是，安全性得到了保留 — 两个不同的服务器永远不会在选择作为第 i 个状态机命令的值上产生分歧。选举一名领导人只是为了确保进展。</p><p>如果服务器集可以更改，那么必须有某种方法可以确定哪些服务器实现了共识算法的哪些实例。最简单的方法是通过状态机本身。当前的服务器集可以成为状态的一部分，并且可以使用常规状态机命令进行更改。我们可以允许领导者提前获得α命令，方法是让执行共识算法的实例 i + α 的服务器集在执行第 i 个状态机命令后由状态指定。这允许对任意复杂的 reconfiguration 算法进行简单实现。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>mit6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture9</title>
    <link href="/2024/07/18/%E7%AC%AC%E4%B9%9D%E8%AF%BE%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/"/>
    <url>/2024/07/18/%E7%AC%AC%E4%B9%9D%E8%AF%BE%EF%BC%9A%E7%B4%A2%E5%BC%95%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第九课索引并发控制"><a class="markdownIt-Anchor" href="#第九课索引并发控制"></a> 第九课：索引并发控制</h1><h2 id="1-索引并发控制"><a class="markdownIt-Anchor" href="#1-索引并发控制"></a> 1 索引并发控制</h2><p>到目前为止，我们假设我们讨论的数据结构是单线程的。然而，大多数 DBMS 需要允许多个线程安全地访问数据结构，以利用额外的 CPU 核心并隐藏磁盘 I/O 停顿。</p><p>有些系统使用单线程模型。将单线程数据结构转换为多线程数据结构的一种简单方法是使用读写锁，但效率不高。</p><p>并发控制协议是 DBMS 用于确保共享对象上的并发操作得到“正确”结果的方法。</p><p>协议的正确性标准可能会有所不同：</p><ul><li>**逻辑正确：**这意味着线程能够读取它应该读取的值，例如线程应该读回它之前写入的值。</li><li>**物理正确：**这意味着对象的内部表示是健全的，例如数据结构中不存在会导致线程读取无效内存位置的指针</li></ul><p>出于本讲座的目的，我们只关心强制执行物理正确性。我们将在后面的课中重新审视逻辑正确性。</p><h2 id="2-locks-vs-latches"><a class="markdownIt-Anchor" href="#2-locks-vs-latches"></a> 2 Locks vs. Latches</h2><p>在讨论 DBMS 如何保护其内部元素时，锁和闩锁之间存在重要区别。</p><h3 id="locks"><a class="markdownIt-Anchor" href="#locks"></a> Locks</h3><p>锁时一种更高层次的逻辑原语，用于保护数据库中的内容（例如元组，表或者整个数据库），防止其他事务的干扰。一个事务在其整个执行期间都会持有锁。数据库系统可以向用户公开运行查询时持有的锁。应该有一些更高级别的机制来检测死锁和回滚更改。</p><h3 id="latches"><a class="markdownIt-Anchor" href="#latches"></a> Latches</h3><p>锁存器是低级保护原语，用于来自其他线程的 DBMS 内部数据结构（例如数据结构、内存区域）的关键部分。锁存器会在数据库系统中短暂保留一个简单的操作（即页锁存器）。锁存器有两种模式：</p><ul><li>**读：**允许多个线程同时读取同一个项目。即使另一个线程已经在读模式下获取了锁存器，线程也可以在读模式下获取该锁存器。</li><li>**写：**只允许一个线程访问该项目。如果另一个线程在任何模式下持有锁存器，则线程无法获取写锁存器。持有写锁存器的线程还会阻止其他线程获取读锁存器。</li></ul><h2 id="3-latch实现"><a class="markdownIt-Anchor" href="#3-latch实现"></a> 3 Latch实现</h2><p>Latch实现应该具有较小的内存占用，并且在没有争用时可以有一条快速路径来获取锁存器。</p><p>用于实现锁存器的底层原语是通过现代 CPU 提供的原子指令。这样，线程可以检查内存位置的内容以查看它是否具有特定值。</p><p>有多种方法可以在 DBMS 中实现锁存器。每种方法在工程复杂性和运行时性能方面都有不同的权衡。这些测试和设置步骤以原子方式执行（即，没有其他线程可以更新测试和设置步骤之间的值。</p><h3 id="test-and-set-spin-latch-tas-自旋锁"><a class="markdownIt-Anchor" href="#test-and-set-spin-latch-tas-自旋锁"></a> Test-and-Set Spin Latch (TAS) （自旋锁）</h3><p>自旋锁存器是操作系统互斥体的更有效替代方案，因为它由 DBMS 控制。自旋锁存器本质上是线程尝试更新的内存位置（例如，将布尔值设置为 true）。线程执行 CAS 来尝试更新内存位置。DBMS 可以控制如果无法获得锁存器会发生什么情况。它可以选择重试（例如，使用 while 循环）或允许操作系统取消调度它。因此，此方法为 DBMS 提供了比操作系统互斥体更多的控制权，在操作系统互斥体中，如果无法获取锁存器，则将控制权交给操作系统。</p><ul><li>举例：std::atomic<T></li><li>优点:锁存/解锁操作非常高效（在 x86 上使用单指令锁定/解锁）。</li><li>缺点:不可扩展，也不适合缓存，因为使用多个线程，CAS 指令将在不同的线程中执行多次。这些浪费的指令会在高竞争环境中堆积起来；尽管线程没有做有用的工作，但对操作系统来说它们看起来很忙。这会导致缓存一致性问题，因为线程正在轮询其他 CPU 上的缓存线。</li></ul><h3 id="阻塞操作系统mutex"><a class="markdownIt-Anchor" href="#阻塞操作系统mutex"></a> 阻塞操作系统Mutex</h3><p>锁存器的一种可能实现是操作系统内置的互斥基础设施。 Linux 提供了 futex（快速用户空间互斥体），它由 (1) 用户空间中的自旋锁存器和 (2) 操作系统级互斥体组成。如果 DBMS 可以获取用户空间锁存器，则锁存器被设置。尽管它包含两个内部锁存器，但它对于 DBMS 来说却显示为单个锁存器。如果 DBMS 无法获取用户空间锁存器，那么它会进入内核并尝试获取更昂贵的互斥锁。DBMS 无法获取第二个互斥体，然后线程通知操作系统它在互斥体上被阻塞，然后它被取消调度。</p><p>操作系统互斥在 DBMS 内部通常是一个坏主意，因为它由操作系统管理并且开销很大</p><ul><li>举例：std::mutex</li><li>优点：使用简单并且在DBMS中不需要额外coding</li><li>缺点：由于操作系统调度，成本昂贵且不可扩展（每次锁定/解锁调用大约 25 ns）。</li></ul><h3 id="读写latches"><a class="markdownIt-Anchor" href="#读写latches"></a> 读写Latches</h3><p>互斥锁和自旋锁存器不区分读/写（即，它们不支持不同的模式）。DBMS 需要一种允许并发读取的方法，因此如果应用程序有大量读取，它将具有更好的性能，因为读取者可以共享资源而不是等待。</p><p>读写器锁存器允许锁存器保持在读或写模式。它追踪有多少个线程持有锁存器并等待在每种模式下获取锁存器。读写器锁存器使用前两个锁存器实现之一作为原语，并具有额外的逻辑来处理读写器队列，这些队列是每种模式下对锁存器的请求的队列。不同的 DBMS 对于如何处理队列可以有不同的策略。</p><p>需要注意的一件事是，不同的读写锁实现具有不同的等待策略。有读者优先锁、作者优先锁和公平读写锁。不同操作系统和 pthread 实现中的行为有所不同。</p><ul><li>举例：std::shared_mutex</li><li>优点：允许并发读</li><li>缺点：DBMS 必须管理读/写队列以避免饥饿。由于额外的元数据，存储开销比自旋锁存器更大。</li></ul><h2 id="4-哈希表latch"><a class="markdownIt-Anchor" href="#4-哈希表latch"></a> 4 哈希表Latch</h2><p>由于线程访问数据结构的方式有限，因此很容易支持静态哈希表中的并发访问。例如，当从槽移动到下一个槽时（即自上而下），所有线程都沿相同方向移动。线程一次也只能访问一个页面/槽。因此，在这种情况下不可能出现死锁，因为没有两个线程可以竞争对方持有的锁存器。当我们需要调整表的大小时，我们只需对整个表进行全局锁存即可执行操作。</p><p>动态哈希方案（例如，可扩展）中的锁存是一种更复杂的方案，因为有更多的共享状态需要更新，但一般方法是相同的。</p><p>有两种方法支持哈希表中的锁存，它们的锁存粒度不同:</p><ul><li>**页级锁存器：**每个页面都有自己的读写器锁存器来保护其全部内容。线程在访问页面之前获取读或写锁存器。这会降低并行性，因为一次可能只有一个线程可以访问一页，但是对于单个线程来说，访问一页中的多个槽会很快，因为它只需要获取一个锁存器。</li><li>**槽级锁存器：**每个插槽都有自己的闩锁。这增加了并行性，因为两个线程可以访问同一页面上的不同插槽。但它增加了访问表的存储和计算开销，因为线程必须为其访问的每个槽获取锁存器，并且每个槽必须为锁存器存储数据。DBMS 可以使用单模式锁存器（即自旋锁存器）来减少元数据和计算开销，但代价是一些并行性。</li></ul><p>还可以直接使用比较和交换 (CAS) 指令创建无锁存线性探测哈希表。通过尝试将特殊的“空”值与我们希望插入的元组进行比较和交换，可以实现在槽处的插入。如果失败，我们可以探测下一个槽，继续直到成功。</p><h2 id="5-b树latch"><a class="markdownIt-Anchor" href="#5-b树latch"></a> 5 B+树Latch</h2><p>B+Tree 锁存的挑战是防止以下两个问题：</p><ul><li>多个线程同时尝试修改节点的内容。</li><li>一个线程遍历树，而另一个线程拆分/合并节点。</li></ul><p>“Latch crabbing/coupling” 是一种协议，它允许多个线程同时访问或修改B+树。基本思路如下：</p><ol><li>获得父节点的锁</li><li>获得子节点的锁</li><li>如果子节点被认为“安全”，则释放父节点的锁。 “安全”节点是指更新时不会分裂、合并或重新分配的节点。换句话说，一个节点是“安全的”如果<ul><li>插入：它不是满的</li><li>删除：它至少半满</li></ul></li></ol><p>请注意，读锁存器不需要担心“安全”条件。</p><p><strong>基本锁抓取协议：</strong></p><ul><li>搜索：从根开始向下，重复获取子级的闩锁，然后解锁父级。</li><li>插入/删除：从根开始向下，根据需要获取 X 个锁存器。一旦孩子被锁住，检查是否安全。如果孩子安全，则释放其所有祖先的锁</li></ul><p>从正确性的角度来看，锁存器释放的顺序并不重要。然而，从性能的角度来看，最好释放树中较高位置的锁存器，因为它们会阻止对大部分叶节点的访问。</p><p>**改进的锁抓取协议：**基本锁抓取算法的问题在于，事务总是在每次插入/删除操作的根上获取独占锁.这限制了并行性。相反，我们可以假设必须调整大小（即拆分/合并节点）的情况很少见，因此事务可以获取直至叶节点的共享锁存器。每个事务都会假设到目标叶节点的路径是安全的，并使用 READ 锁存器和螃蟹来到达它并进行验证。如果叶节点不安全，那么我们将中止并执行之前的算法，获取 WRITE 锁存器。</p><ul><li>搜索：与以前相同的算法。</li><li>插入/删除：设置读锁就像搜索一样，转到叶子，然后在叶子上设置写锁。如果叶子不安全，则释放所有先前的锁存器，并使用先前的插入/删除协议重新启动事务。</li></ul><p><strong>叶子结点扫描</strong></p><p>这些协议中的线程以“自上而下”的方式获取锁存器。这意味着线程只能从低于其当前节点的节点获取锁存器。如果所需的锁不可用，则线程必须等待直到它变得可用。鉴于此，永远不会出现僵局。</p><p>然而，叶节点扫描很容易出现死锁，因为现在我们有线程尝试同时在两个不同方向获取排它锁（例如，线程 1 尝试删除，线程 2 执行叶节点扫描）。索引锁存器不支持死锁检测或避免。</p><p>因此，程序员处理这个问题的唯一方法是通过编码规则。叶节点同级锁存器获取协议必须支持“无等待”模式。也就是说，B+树代码必须处理失败的锁存获取。由于锁旨在（相对）短暂地保持，因此如果线程尝试获取叶节点上的锁但该锁不可用，则它应该快速中止其操作（释放其持有的任何闩锁）并重新启动操作。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>并发控制</tag>
      
      <tag>索引结构</tag>
      
      <tag>锁 (Locks)</tag>
      
      <tag>闩锁 (Latches)</tag>
      
      <tag>自旋锁 (Spin Locks)</tag>
      
      <tag>B+树</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>why kafka so fast?</title>
    <link href="/2024/07/16/Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F/"/>
    <url>/2024/07/16/Kafka%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%99%E4%B9%88%E5%BF%AB%EF%BC%9F/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="kafka为什么这么快"><a class="markdownIt-Anchor" href="#kafka为什么这么快"></a> Kafka为什么这么快？</h1><p>kafka是一个成熟的消息队列，一直以性能高著称，它之所以能够实现高吞吐量和低延迟，主要是由于以下几个方面的优化。</p><h2 id="消息发送"><a class="markdownIt-Anchor" href="#消息发送"></a> 消息发送</h2><ol><li>**批量发送：**Kafka通过将多个消息打包成一个批次，减少了网络传输和磁盘写入的次数，从而提高了消息的吞吐量和传输效率。</li><li>**异步发送：**生产者可以异步发送消息，不必等待每个消息的确认，这大大提高了消息发送的效率。</li><li>**消息压缩：**支持对消息进行压缩，减少网络传输的数据量。</li><li>**并行发送：**通过将数据分布在不同的分区（Partitions）中，生产者可以并行发送消息，从而提高了吞吐量。</li></ol><h2 id="消息存储"><a class="markdownIt-Anchor" href="#消息存储"></a> 消息存储</h2><ol><li>**零拷贝技术：**Kfaka使用零拷贝技术来避免了数据的拷贝操作，降低了内存和CPU的使用率，提高了系统的性能。</li><li>**磁盘顺序写入：**Kafka把消息存储在磁盘上，且以顺序的方式写入数据。顺序写入比随机写入速度快很多，因为它减少了磁头寻道时间。避免了随机读写带来的性能损耗，提高了磁盘的使用效率。</li><li>**页缓存：**Kafka将起数据存储在磁盘中，但在访问数据时，它会先将数据加载到操作系统的页缓存中，并在页缓存中保留一份副本，从而实现快速的数据访问。</li><li>**稀疏索引：**Kafka存储消息是通过分段的日志文件，每个分段都有自己的索引文件。这些索引文件中的条目不是对分段中的每条消息都建立索引，而是每隔一定数量的消息建立一个索引点，这就构成了稀疏索引。稀疏索引减少了索引大小，使得加载到内存中的索引更小，提高了查找特定消息的效率。</li><li>**分区和副本：**Kafka采用分区和副本的机制，可以将数据分散到多个节点上进行处理，从而实现了分布式的高可用性和负载均衡。</li></ol><h2 id="消息消费"><a class="markdownIt-Anchor" href="#消息消费"></a> 消息消费</h2><ol><li>**消费者群组：**通过消费者群组可以实现消息的负载均衡和容错处理。</li><li>**并行消费：**不同的消费者可以独立地消费不同的分区，实现消费的并行处理。</li><li>**批量拉取：**Kafka支持批量拉取消息，可以一次性拉取多个消息进行消费。减少网络消耗，提升性能。</li></ol><table><thead><tr><th><strong>生产消息</strong></th><th><strong>存储消息</strong></th><th><strong>消费消息</strong></th></tr></thead><tbody><tr><td>批量发送</td><td>零拷贝技术</td><td>消费者群组</td></tr><tr><td>异步发送</td><td>磁盘顺序写入</td><td>并行消费</td></tr><tr><td>消息压缩</td><td>页缓存</td><td>批量拉取</td></tr><tr><td>并行发送</td><td>稀疏索引</td><td></td></tr><tr><td></td><td>分区和副本</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>mq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>高性能</tag>
      
      <tag>批量发送</tag>
      
      <tag>异步发送</tag>
      
      <tag>消息压缩</tag>
      
      <tag>并行发送</tag>
      
      <tag>零拷贝技术</tag>
      
      <tag>磁盘顺序写入</tag>
      
      <tag>页缓存</tag>
      
      <tag>稀疏索引</tag>
      
      <tag>分区和副本</tag>
      
      <tag>消费者群组</tag>
      
      <tag>并行消费</tag>
      
      <tag>批量拉取</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>茶7.15-7.19</title>
    <link href="/2024/07/15/%E8%8C%B67.15-7.19/"/>
    <url>/2024/07/15/%E8%8C%B67.15-7.19/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="tea715-719"><a class="markdownIt-Anchor" href="#tea715-719"></a> Tea7.15-7.19</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/problemset/problem/1922/C">Closest Cities_161C</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e5，m 之和 ≤1e5。<br />每组数据输入 n(2≤n≤1e5) 和长为 n 的严格递增数组 a(0≤a[i]≤1e9)。<br />然后输入 m(1≤m≤1e5) 和 m 个询问，每个询问输入两个数 x 和 y，范围 [1,n] 且 x≠y。</p><p>数轴上有 n 个点，点 i 的坐标为 a[i]。<br />有两种移动方式：</p><ol><li>从点 i 移动到离它最近的点，花费是 1。保证每个点只有唯一的离它最近的点。</li><li>从点 i 移动到点 j，花费是 |a[i]-a[j]|。</li></ol><p>对于每个询问，输出从点 x 移动到点 y 的最小花费。</p><p>输入<br />1<br />5<br />0 8 12 15 20<br />5<br />1 4<br />1 5<br />3 4<br />3 2<br />5 1<br />输出<br />3<br />8<br />1<br />4<br />14</p><p><strong>Sol:</strong></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-function">vi <span class="hljs-title">near</span><span class="hljs-params">(n)</span></span>;<br>    near[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    near[n<span class="hljs-number">-1</span>] = n<span class="hljs-number">-2</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span> ; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        near[i] = <span class="hljs-built_in">abs</span>(a[i] - a[i<span class="hljs-number">-1</span>])&gt;<span class="hljs-built_in">abs</span>(a[i]-a[i+<span class="hljs-number">1</span>])? i+<span class="hljs-number">1</span>:i<span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-comment">// print(near);</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    <span class="hljs-function">vll <span class="hljs-title">suml</span><span class="hljs-params">(n)</span>,<span class="hljs-title">sumr</span><span class="hljs-params">(n)</span></span>;<br>    suml[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-comment">// BUG(near[i-1]);</span><br>        <span class="hljs-comment">// BUG(i);</span><br>        suml[i] = suml[i<span class="hljs-number">-1</span>];<br>        suml[i] += near[i<span class="hljs-number">-1</span>]==i?<span class="hljs-number">1</span>:<span class="hljs-built_in">abs</span>(a[i]-a[i<span class="hljs-number">-1</span>]);<br>        <span class="hljs-comment">// BUG(suml[i]);</span><br>    &#125;<br>    <span class="hljs-comment">// print(suml);</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    sumr[n<span class="hljs-number">-1</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n<span class="hljs-number">-2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        sumr[i] = sumr[i+<span class="hljs-number">1</span>];<br>        sumr[i] += near[i+<span class="hljs-number">1</span>]==i?<span class="hljs-number">1</span>:<span class="hljs-built_in">abs</span>(a[i]-a[i+<span class="hljs-number">1</span>]);<br>    &#125;<br>    <span class="hljs-comment">// print(sumr);</span><br>    <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">while</span>(q--) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        cin &gt;&gt; l &gt;&gt; r;<br>        l--;r--;<br>        <span class="hljs-keyword">if</span>(l &lt; r) &#123;<br>            cout &lt;&lt; suml[r] - suml[l] &lt;&lt; endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            cout &lt;&lt; sumr[r] - sumr[l] &lt;&lt; endl;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="feb"><a class="markdownIt-Anchor" href="#feb"></a> Feb</h2><p><a href="https://codeforces.com/problemset/problem/1891/C">Smilo and Monsters_907C</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>一开始 cnt = 0。<br />有两种操作，每种都可以执行任意次。<br />第一种：把一个大于 0 的 a[i] 减少 1，然后 cnt += 1。<br />第二种：把一个大于等于 cnt 的 a[i] 减少 cnt，然后 cnt = 0。</p><p>把所有 a[i] 都变成 0，最少要操作多少次？</p><p>输入<br />4<br />4<br />1 3 1 1<br />4<br />1 2 1 1<br />6<br />3 2 1 5 2 4<br />2<br />1 6<br />输出<br />4<br />4<br />11<br />5</p><p><strong>Sol:</strong></p><p>提示 1：从特殊情况入手。如果有一个数非常大，最优操作是什么样的？</p><p>如果有一个数非常大，可以把其他数都通过操作一搞定，最后把操作二用到这个数上。</p><p>这启发我们，用操作一操作小的数，用操作二操作大的数，可以让总操作次数尽量小。</p><p>也可以反过来思考：如果用操作一操作大的数，操作二操作小的数，就会因为操作二的限制，导致操作二必须执行很多次。</p><p>提示 2：把 cnt 理解为能量，操作一积累能量，操作二释放能量，但释放多少，其实可以自己决定。</p><p>设 s = sum(a)，left = ceil(s/2)。</p><p>把 a 从小到大排序。不断地把 left 减少 a[i]，直到 left &lt; a[i] 为止。 此时我们积累了足够的能量，剩余的 n-i 个数（i 从 0 开始）全部用操作二搞定。</p><p>答案为 ceil(s/2) + n-i。  <a href="https://codeforces.com/problemset/submission/1891/270160606">代码</a></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123;<br>        cout &lt;&lt; a[<span class="hljs-number">0</span>] / <span class="hljs-number">2</span> + a[<span class="hljs-number">0</span>] % <span class="hljs-number">2</span> + (a[<span class="hljs-number">0</span>] &gt; <span class="hljs-number">1</span>?<span class="hljs-number">1</span> : <span class="hljs-number">0</span>) &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-function">vll <span class="hljs-title">sum</span><span class="hljs-params">(n)</span></span>;<br>    sum[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        sum[i] = sum[i - <span class="hljs-number">1</span>] + a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> right = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">if</span> (sum[n<span class="hljs-number">-1</span>] - sum[i] &gt;= sum[n<span class="hljs-number">-1</span>] / <span class="hljs-number">2</span>) &#123;<br>            right = i;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">//BUG(mid);</span><br>    <span class="hljs-comment">//BUG(right);</span><br>    cout &lt;&lt; n - right - <span class="hljs-number">1</span> + sum[n<span class="hljs-number">-1</span>] / <span class="hljs-number">2</span> + sum[n<span class="hljs-number">-1</span>] % <span class="hljs-number">2</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1893/B">Neutral Tonality_908B</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5，m 之和 ≤2e5。<br />每组数据输入 n(1≤n≤2e5) m(1≤m≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，长为 m 的数组 b(1≤b[i]≤1e9)。</p><p>把 b 中所有元素以任意顺序在任意位置插入 a 中，得到数组 c。<br />例如 a=[3,1,1]，b=[9,4,5]，插入后可以是 c=[3,1,4,1,5,9]。</p><p>你需要使 LIS© 最短。（LIS 是最长严格递增子序列）<br />输出任意符合要求的 c。</p><p>输入<br />7<br />2 1<br />6 4<br />5<br />5 5<br />1 7 2 4 5<br />5 4 1 2 7<br />1 9<br />7<br />1 2 3 4 5 6 7 8 9<br />3 2<br />1 3 5<br />2 4<br />10 5<br />1 9 2 3 8 1 4 7 2 9<br />7 8 5 4 6<br />2 1<br />2 2<br />1<br />6 1<br />1 1 1 1 1 1<br />777<br />输出<br />6 5 4<br />1 1 7 7 2 2 4 4 5 5<br />9 8 7 7 6 5 4 3 2 1<br />1 3 5 2 4<br />1 9 2 3 8 8 1 4 4 7 7 2 9 6 5<br />2 2 1<br />777 1 1 1 1 1 1</p><p><strong>Sol：</strong></p><p>构造题。</p><p>从特殊到一般，思考如下情况：</p><p>a 单调递减。</p><p>a 单调递增。</p><p>min(a) = a[0]</p><p>min(a) ≠ a[0]</p><p>构造方法： 先把 b 从大到小排序。然后双指针遍历 a 和 b 合并成 c，在把 a[i] 加到 c 之前，必须把 &gt;= a[i] 的 b[j] 都加到 c。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span>,<span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, m<span class="hljs-number">-1</span>) cin &gt;&gt; b[i];<br>    <span class="hljs-built_in">rsort</span>(b);<br>    vi c;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">while</span>(b[l] &gt;= a[i] &amp;&amp; l &lt; m) &#123;<br>            c.<span class="hljs-built_in">pb</span>(b[l]);<br>            l++;<br>        &#125;<br>        c.<span class="hljs-built_in">pb</span>(a[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span>(l &lt; m) &#123;<br>        c.<span class="hljs-built_in">pb</span>(b[l]);<br>        l++;<br>    &#125;<br>    <span class="hljs-built_in">print</span>(c);cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/problemset/problem/1167/E">Range Deleting 65E</a></p><p>输入 n(1≤n≤1e6) x(1≤x≤1e6) 和长为 n 的数组 a(1≤a[i]≤x)。</p><p>定义 D(a,L,R) 为删除 a 中所有元素值在 [L,R] 中的元素后，剩余的元素组成的数组（不改变顺序）。</p><p>输出有多少对 (L,R) 满足 1&lt;=L&lt;=R&lt;=x 且 D(a,L,R) 是非降数组，即相邻元素左边 &lt;= 右边。</p><p>输入<br />3 3<br />2 3 1<br />输出 4</p><p>输入<br />7 4<br />1 3 1 2 2 4 3<br />输出 6</p><p><strong>Sol:</strong></p><p>本题是近期打卡题<a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/">【力扣 2972. 统计移除递增子数组的数目 II】</a>的变形题。</p><p>由于思路和代码都非常接近，推荐先把力扣那题做了。</p><p><strong>核心思路：删除元素后，对于剩余的每个元素，考察其出现位置的区间，这些区间必须不相交。</strong></p><p>记录每个元素首次和最后一次出现的位置。</p><p>定义 ps[v].l 表示元素 v 首次出现的位置，ps[v].r 表示元素 v 最后一次出现的位置。</p><p>用闭区间 [ps[v].l, ps[v].r] 表示元素 v。</p><p>对于剩余元素中的两个数 v 和 w，如果 v &lt; w，那么区间 [ps[v].l, ps[v].r] 必须在区间 [ps[w].l, ps[w].r] 的左侧，即 ps[v].r &lt; ps[w].l。</p><p>首先考虑一个简单情况：1 到 x 中的每个数都在数组 a 中。</p><p>和力扣 2972 题代码一样，双指针，把「元素值比大小」改成 ps[v].r &lt; ps[w].l 这样的「区间左右端点比大小」即可。</p><p>本题的一个难点是，如果有元素不在 a 中，怎么算清楚这种情况，尤其是不能重复统计。</p><p>首先把 ps 中的元素值在 a 中的区间提取出来，得到数组 b。</p><p>其中 b[i].l 和 b[i].r 是第 i 个区间的左右端点，b[i].v 是第 i 个区间对应的元素值。</p><p>看上去在 b 数组上「区间左右端点比大小」就行，怎么把不在 a 中的元素值考虑进来呢？</p><p>和 2972 题 <a href="https://leetcode.cn/problems/count-the-number-of-incremovable-subarrays-ii/solution/shuang-zhi-zhen-on-shi-jian-o1-kong-jian-2hsz/">灵神的题解</a> 一样，首先讨论删除后缀的情况，然后讨论一般情况。</p><p>删除后缀 b[k] 到 b[n-1]，其中 n 是 b 的长度，k &lt;= i+1。</p><p>那么删除的范围，最小值 &lt;= b[i+1].v，最大值 &gt;= b[n-1].v，根据乘法原理，这一共有 b[i+1].v * (x + 1 - b[n-1].v) 个。</p><p>然后讨论删除的不是后缀的情况。</p><p>删除 b[k] 到 b[j-1]，保留 b[j] 到 b[n-1]，那么删除的范围，最小值 &lt;= b[i+1].v，最大值在左闭右开区间 [b[j-1].v, b[j].v) 中，根据乘法原理，这一共有 b[i+1].v * (b[j].v - b[j-1].v) 个。</p><p><a href="https://codeforces.com/contest/1167/submission/271313557">Code</a>:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n, x, y;<br>    cin &gt;&gt; n &gt;&gt; x;<br>    node *ps = <span class="hljs-keyword">new</span> node[x + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; y;<br>        <span class="hljs-keyword">if</span> (ps[y].l == INT_MAX) &#123;<br>            ps[y].l = i;<br>            ps[y].v = y;<br>        &#125;<br>        ps[y].r = i;<br>    &#125;<br>    vector&lt;node&gt; b;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= x; i ++)&#123;<br>        <span class="hljs-keyword">if</span>(ps[i].r &gt;= <span class="hljs-number">0</span>)&#123;<br>            b.<span class="hljs-built_in">emplace_back</span>(ps[i]);<br>        &#125;<br>    &#125;<br>    n = b.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>, j = n - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span>(i &lt; n - <span class="hljs-number">1</span> &amp;&amp; b[i].r &lt; b[i + <span class="hljs-number">1</span>].l) i ++;<br>    <span class="hljs-keyword">if</span>(i == n - <span class="hljs-number">1</span>)&#123;<br>        cout &lt;&lt; x * (x + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = b[i + <span class="hljs-number">1</span>].v * (x + <span class="hljs-number">1</span> - b[n - <span class="hljs-number">1</span>].v);<br>    <span class="hljs-keyword">while</span>(j &gt;= <span class="hljs-number">0</span> &amp;&amp; (j == n - <span class="hljs-number">1</span> || b[j].r &lt; b[j + <span class="hljs-number">1</span>].l))&#123;<br>        <span class="hljs-keyword">while</span>(i &gt;= <span class="hljs-number">0</span> &amp;&amp; b[i].r &gt;= b[j].l) i --;<br>        ans += b[i + <span class="hljs-number">1</span>].v * (b[j].v - b[j - <span class="hljs-number">1</span>].v);<br>        j --;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>    <span class="hljs-keyword">delete</span>[] ps;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/1185/G2">Playlist for Polycarp_568G</a></p><p>输入 n(1≤n≤50) 和 T(1≤T≤2500)。有 n 首歌。<br />然后输入 n 行，每行两个数 t(1≤t≤50) 和 g(1≤g≤3)，表示第 i 首歌的时长和类型。</p><p>你需要从这 n 首歌中选出若干首歌，组成一个播放列表，满足：</p><ol><li>总时长为 T。</li><li>没有重复歌曲。</li><li>相邻歌曲的类型不同。注意这个列表只播放一次，所以不考虑首尾。</li></ol><p>有多少种方案？注意歌曲的顺序不同，也算不同的方案。<br />答案模 1e9+7。</p><p>输入<br />3 3<br />1 1<br />1 2<br />1 3<br />输出 6</p><p>输入<br />3 3<br />1 1<br />1 1<br />1 3<br />输出 2</p><p>输入<br />4 10<br />5 3<br />2 1<br />3 2<br />5 1<br />输出 10</p><h3 id="sol"><a class="markdownIt-Anchor" href="#sol"></a> <strong>Sol:</strong></h3><h4 id="初步分析"><a class="markdownIt-Anchor" href="#初步分析"></a> 初步分析：</h4><p>原问题可以拆分成如下两个问题：</p><ol><li>不考虑总时长（以及歌曲的排列），计算从这 n 首歌中选出 i 个类型 1，j 个类型 2，k 个类型 3，且相邻歌曲类型不同的方案数。</li><li>不考虑相邻歌曲类型不同（以及歌曲的排列），计算从这 <em>n</em> 首歌中选出 <em>i</em> 个类型 1，<em>j</em> 个类型 2，<em>k</em> 个类型 3，且总时长为 <em>t</em> 的方案数。</li></ol><p>两个方案数相乘，再乘上排列数 i*!<em>j</em>!*k!，就可以得到从这 n 首歌中选出 i 个类型 1，j 个类型 2，k 个类型 3，总时长为 t 且相邻歌曲类型不同的方案数。</p><blockquote><p>另一种理解方式：相当于有若干个格子和三种颜色，问题 1 负责涂色（保证相邻格子颜色不同），问题 2（乘上 i*!<em>j</em>!<em>k</em>!）负责给每个格子放上具体的歌曲（颜色要匹配）。</p></blockquote><p>枚举所有的i，j，k，累加方案数，即为答案。</p><h4 id="问题1"><a class="markdownIt-Anchor" href="#问题1"></a> 问题1:</h4><p>不考虑总时长（以及歌曲的排列），计算从这n首歌中选出i个类型1，j个类型2，k个类型3，且相邻歌曲类型不同的方案数。</p><p>用<strong>状态机DP</strong>解决。</p><p>定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>x</mi></mrow></msub></mrow><annotation encoding="application/x-tex">c_{i,j,k,x}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">x</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示从这n首歌中选出i个类型1，j个类型2，k个类型3，且最后一首歌的类型为x且响铃歌曲类型不同的方案书。</p><p>枚举上一首歌的类型，那么有</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>c</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>3</mn></mrow></msub><mspace linebreak="newline"></mspace><msub><mi>c</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>3</mn></mrow></msub><mspace linebreak="newline"></mspace><msub><mi>c</mi><mrow><mi>i</mi><mo>+</mo><mn>1</mn><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>3</mn></mrow></msub><mo>=</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>2</mn></mrow></msub></mrow><annotation encoding="application/x-tex">c_{i+1,j,k,1} = c_{i,j,k,2} + c_{i,j,k,3}\\c_{i+1,j,k,2} = c_{i,j,k,1} + c_{i,j,k,3}\\c_{i+1,j,k,3} = c_{i,j,k,1} + c_{i,j,k,2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span><span class="mspace newline"></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mbin mtight">+</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>这里用刷表法转移</p><p>初始值<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mrow><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>=</mo><msub><mi>c</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>2</mn></mrow></msub><mo>=</mo><msub><mi>c</mi><mrow><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo separator="true">,</mo><mn>1</mn><mo separator="true">,</mo><mn>3</mn></mrow></msub><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">c_{1,0,0,1}=c_{0,1,0,2}=c_{0,0,1,3} = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.301108em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span></p><h4 id="问题2"><a class="markdownIt-Anchor" href="#问题2"></a> 问题2</h4><p>不考虑相邻歌曲类型不同（以及歌曲的排列），计算从这n首歌中选出i个类型1，j个类型2，k个类型3，且总时长为t的方案数。</p><p>用多维0-1背包解决。</p><p><strong>优化前</strong></p><p>定义<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>p</mi><mo separator="true">,</mo><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{p,i,j,k,t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>表示从前p首歌中选出i个类型1，j个类型2，k个类型3，且总时长为t的方案数。需要O(n<sup>4</sup>T)的时间和空间。</p><p><strong>优化</strong></p><p>考虑继续拆分问题：</p><ul><li>计算从这n首歌中选出i个类型1，且总时长为t的方案数。记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">f_{i,t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.980548em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</li><li>计算从这n首歌中选出j个类型2，k个类型3，且总时长为T-t的总方案数。记为<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>g</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>T</mi><mo>−</mo><mi>t</mi></mrow></msub></mrow><annotation encoding="application/x-tex">g_{j,k,T-t}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span>。</li></ul><p>两个方案数相乘，就是问题2的方案数。</p><h4 id="汇总"><a class="markdownIt-Anchor" href="#汇总"></a> 汇总</h4><p>枚举i,j,k。</p><p>从这n首歌中选出i个类型1，j个类型2，k个类型3，总时长为t且相邻歌曲类型不同的方案数为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub><mo>=</mo><mi>i</mi><mo stretchy="false">!</mo><mi>j</mi><mo stretchy="false">!</mo><mi>k</mi><mo stretchy="false">!</mo><mo>∗</mo><mo stretchy="false">(</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>1</mn></mrow></msub><mo>+</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>2</mn></mrow></msub><mo>+</mo><msub><mi>c</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mn>3</mn></mrow></msub><mo stretchy="false">)</mo><mo>∗</mo><munderover><mo>∑</mo><mrow><mi>t</mi><mo>=</mo><mn>0</mn></mrow><mi>T</mi></munderover><mrow><msub><mi>f</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>t</mi></mrow></msub><msub><mi>g</mi><mrow><mi>j</mi><mo separator="true">,</mo><mi>k</mi><mo separator="true">,</mo><mi>T</mi><mo>−</mo><mi>t</mi></mrow></msub></mrow></mrow><annotation encoding="application/x-tex">w_{i,j,k} = i!j!k!*(c_{i,j,k,1}+c_{i,j,k,2}+c_{i,j,k,3})*\sum_{t=0}^T{f_{i,t}g_{j,k,T-t}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.716668em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">i</span><span class="mclose">!</span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mclose">!</span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mclose">!</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mtight">3</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∗</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:3.0954490000000003em;vertical-align:-1.267113em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.8283360000000002em;"><span style="top:-1.882887em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.3000050000000005em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.267113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord"><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:-0.10764em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.13889em;">T</span><span class="mbin mtight">−</span><span class="mord mathnormal mtight">t</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></span></p><p>答案为</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><munderover><mo>∑</mo><mrow><mi>i</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>1</mn></msub></mrow></munderover><munderover><mo>∑</mo><mrow><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>2</mn></msub></mrow></munderover><munderover><mo>∑</mo><mrow><mi>k</mi><mo>=</mo><mn>0</mn></mrow><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mn>3</mn></msub></mrow></munderover><msub><mi>w</mi><mrow><mi>i</mi><mo separator="true">,</mo><mi>j</mi><mo separator="true">,</mo><mi>k</mi></mrow></msub></mrow><annotation encoding="application/x-tex">\sum_{i=0}^{cnt_1}\sum_{j=0}^{cnt_2}\sum_{k=0}^{cnt_3}w_{i,j,k}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:3.205438em;vertical-align:-1.4137769999999998em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7916610000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.311105em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">n</span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.277669em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.7916610000000004em;"><span style="top:-1.872331em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.050005em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.311105em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">n</span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">2</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.4137769999999998em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.791661em;"><span style="top:-1.8478869999999998em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span><span class="mrel mtight">=</span><span class="mord mtight">0</span></span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span><span style="top:-4.311105em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">n</span><span class="mord mtight"><span class="mord mathnormal mtight">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31731428571428577em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight">3</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.302113em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.02691em;">w</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.02691em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">i</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span></span></span></span></span></p><p>其中cnt<sub>x</sub>为输入的n首歌中的类型为x的歌曲个数。</p><p>代码实现时，类型改成0，1，2。</p><p><strong><a href="https://codeforces.com/contest/1185/submission/271339996">Code</a>:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, tot, w, tp;<br>    cin &gt;&gt; n &gt;&gt; tot;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">f</span>(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tot + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>));<br>    f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">2</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;(n + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(tot + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)));<br>    g[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br><br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>)</span></span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; w &gt;&gt; tp;<br>        tp--;<br>        <span class="hljs-keyword">if</span> (tp == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = cnt[<span class="hljs-number">0</span>]; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = tot; t &gt;= w; t--) &#123;<br>                    <span class="hljs-built_in">add</span>(f[j + <span class="hljs-number">1</span>][t], f[j][t - w]);<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">is</span>(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>);<br>            is[tp] = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = cnt[<span class="hljs-number">1</span>]; j &gt;= <span class="hljs-number">0</span>; j--) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = cnt[<span class="hljs-number">2</span>]; k &gt;= <span class="hljs-number">0</span>; k--) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = tot; t &gt;= w; t--) &#123;<br>                        <span class="hljs-built_in">add</span>(g[j + is[<span class="hljs-number">1</span>]][k + is[<span class="hljs-number">2</span>]][t], g[j][k][t - w]);<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>        cnt[tp]++;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fac</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        fac[i] = fac[i - <span class="hljs-number">1</span>] * i % mod;<br>    &#125;<br><br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    vector&lt;vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &gt; &gt; <span class="hljs-built_in">c</span>(cnt[<span class="hljs-number">0</span>] + <span class="hljs-number">2</span>, vector&lt;vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; &gt;(cnt[<span class="hljs-number">1</span>] + <span class="hljs-number">2</span>, vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt;(cnt[<span class="hljs-number">2</span>] + <span class="hljs-number">2</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">3</span>, <span class="hljs-number">0</span>))));<br>    c[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    c[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>    c[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">1</span>][<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= cnt[<span class="hljs-number">0</span>]; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= cnt[<span class="hljs-number">1</span>]; j++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt;= cnt[<span class="hljs-number">2</span>]; k++) &#123;<br>                <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> t = <span class="hljs-number">0</span>; t &lt;= tot; t++) &#123;<br>                    sum = (sum + f[i][t] * g[j][k][tot - t]) % mod;<br>                &#125;<br>                <span class="hljs-built_in">add</span>(ans, fac[i] * fac[j] % mod * fac[k] % mod * (c[i][j][k][<span class="hljs-number">0</span>] + c[i][j][k][<span class="hljs-number">1</span>] + c[i][j][k][<span class="hljs-number">2</span>]) % mod * sum);<br>                <span class="hljs-built_in">add</span>(c[i + <span class="hljs-number">1</span>][j][k][<span class="hljs-number">0</span>], c[i][j][k][<span class="hljs-number">1</span>] + c[i][j][k][<span class="hljs-number">2</span>]);<br>                <span class="hljs-built_in">add</span>(c[i][j + <span class="hljs-number">1</span>][k][<span class="hljs-number">1</span>], c[i][j][k][<span class="hljs-number">0</span>] + c[i][j][k][<span class="hljs-number">2</span>]);<br>                <span class="hljs-built_in">add</span>(c[i][j][k + <span class="hljs-number">1</span>][<span class="hljs-number">2</span>], c[i][j][k][<span class="hljs-number">0</span>] + c[i][j][k][<span class="hljs-number">1</span>]);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图论</tag>
      
      <tag>贪心算法</tag>
      
      <tag>二分查找</tag>
      
      <tag>DFS（深度优先搜索）</tag>
      
      <tag>树形DP</tag>
      
      <tag>并查集</tag>
      
      <tag>最短路径</tag>
      
      <tag>动态规划</tag>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>why using mq?</title>
    <link href="/2024/07/15/MQ/"/>
    <url>/2024/07/15/MQ/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="为什么要使用消息队列"><a class="markdownIt-Anchor" href="#为什么要使用消息队列"></a> 为什么要使用消息队列？</h1><p>使用消息队列的主要目的主要记住这几个关键词：<code>解耦</code> 、<code>异步</code>、<code>削峰填谷</code></p><p>**解耦：**在一个复杂的系统中，不同的模块或服务之间可能需要相互依赖，如果直接函数调用或者API调用的方式，会造成模块之间的耦合，当其中一个模块发生改变时，需要同时修改调用方和被调用方的代码。而使用消息队列作为中间件，不同的模块可以将消息发送到消息队列中，不需要知道具体的接收方是谁，接收方可以独立地消费消息，实现了模块之间的解耦。</p><p>**异步：**有些操作比较耗时，例如发送邮件、生成报表等，如果使用同步的方式处理，会阻塞主线程或者进程，导致系统的性能下降，而使用消息队列，可以将这些操作封装成消息，放入消息队列中，异步地处理这些操作，不影响主流程的执行，提高了系统的性能和响应速度。</p><p>**削峰填谷：**削峰填谷是一种在高并发场景下平衡系统压力的技术，通常用于平衡系统在高峰期和低谷期的资源利用率，提高系统的吞吐量和响应速度。在削峰填谷的过程中，通常使用消息队列作为缓冲区，将请求放入消息队列中，然后在系统负载低的时候进行处理。这种方式可以将系统的峰值压力分散到较长的时间段内，减少瞬时压力对系统的影响，从而提高系统的稳定性和可靠性。</p><p>另外消息队列还有一下优点：</p><ol><li>**可靠性高：**消息队列通常具有高可靠性，可以实现消息的持久化存储、消息的备份和故障恢复等功能，保证消息不会丢失。</li><li>**扩展性好：**通过增加消息队列实例或者添加消费组实例，可以实现消息队列的水平扩展，提高系统的处理能力。</li><li>**灵活性高：**消息队列通常支持多种消息传递模式，如点对点模式和发布/订阅模式，可以根据不同的业务场景选择不同的模式。</li></ol><h2 id="kafka-activemq-rabbitmq和rocketmq都有哪些区别"><a class="markdownIt-Anchor" href="#kafka-activemq-rabbitmq和rocketmq都有哪些区别"></a> Kafka、ActiveMQ、RabbitMQ和RocketMQ都有哪些区别？</h2><p>Kafka、ActiveMQ、RabbitMQ和RocketMQ都是常见的消息中间件，它们都提供了高性能、高可用、可扩展的消息传递机制，但它们之间也有以下一些区别：</p><ol><li><p>**消息传递模型：**Kafka主要支持发布-订阅模型，ActiveMQ、RabbitMQ和RocketMQ则同时支持点对点和发布-订阅两种模型。</p></li><li><p>**性能和吞吐量：**Kafka在数据处理和数据分发方面表现出色，可以处理每秒数百万条消息，而ActiveMQ、RabbitMQ和RocketMQ的吞吐量相对较低。</p></li><li><p>**消息分区和负载均衡：**Kafka将消息划分为多个分区，并分布在多个服务器上，实现负载均衡和高可用性。ActiveMQ和RabbitMQ和RocketMQ也支持消息分区和负载均衡，但实现方式不同，例如RabbitMQ使用了一种叫做Sharding的机制。</p></li><li><p>**开发和部署复杂度：**Kafka相对比较简单，易于使用和部署，但在实现一些高级功能时需要进行一些复杂的配置。ActiveMQ、RabbitMQ和RocketMQ则提供了更多的功能和选项，也更加灵活，但相应地会增加开发和部署的复杂度。</p></li><li><p>**社区和生态：**Kafka、ActiveMQ、RabbitMQ和RocketMQ都拥有庞大的社区和完善的生态系统，但Kafka和RocketMQ目前的发展势头比较迅猛，社区活跃度也相对较高。</p></li><li><p><strong>功能支持：</strong></p><table><thead><tr><th></th><th>优先级队列</th><th>延迟队列</th><th>死信队列</th><th>重试队列</th><th>消费模式</th><th>事务消息</th></tr></thead><tbody><tr><td>Kafka</td><td>不支持</td><td>不支持，可以间接实现延迟队列</td><td>无</td><td>不直接支持，可以通过消费者逻辑来实现重试逻辑。</td><td>主要是拉模式</td><td>支持事务，但限于消息生产。</td></tr><tr><td>RocketMQ</td><td>支持</td><td>直接支持延迟队列，可以设定消息的延迟时间。</td><td>支持</td><td>支持重试队列，可以自动或手动将消息重新发送。</td><td>支持推和拉两种模式</td><td>支持事务消息。</td></tr><tr><td>RabbitMQ</td><td>支持</td><td>支持延迟队列，可以通过插件或者消息TTL和死信交换来实现。</td><td>支持</td><td>可以实现重试机制，但需要通过消息属性和额外配置来手动设置。</td><td>主要是推模式，但也可以实现拉模式</td><td>支持基本的消息事务。</td></tr><tr><td>ActiveMQ</td><td>支持</td><td>支持</td><td>支持</td><td>支持重试机制，可以配置消息重发策略。</td><td>支持推和拉两种模式</td><td>支持消息事务。</td></tr></tbody></table></li></ol><h2 id="如何选型"><a class="markdownIt-Anchor" href="#如何选型"></a> 如何选型？</h2><p>在选择消息队列技术时，需要根据实际业务需求和系统特点来选择，以下是一些参考因素：</p><ol><li>性能和吞吐量：如果需要处理海量数据，需要高性能和高吞吐量，那么Kafka是一个不错的选择。</li><li>可靠性：如果需要保证消息传递的可靠性，包括数据不丢失和消息不重复投递，那么RocketMQ和RabbitMQ都提供了较好的可靠性保证。</li><li>消息传递模型：如果需要支持发布-订阅和点对点模型，那么RocketMQ和RabbitMQ是一个不错的选择。如果只需要发布-订阅模型，Kafka则是一个更好的选择。</li><li>消息持久化：如果需要更快地持久化消息，并且支持高效的消息查询，那么Kafka是一个不错的选择。如果需要更加传统的消息持久化方式，那么RocketMQ和RabbitMQ可以满足需求。</li><li>开发和部署复杂度：Kafka比较简单，易于使用和部署，但在实现一些高级功能时需要进行一些复杂的配置。RocketMQ和RabbitMQ提供了更多的功能和选项，也更加灵活，但相应地会增加开发和部署的复杂度。</li><li>社区和生态：Kafka、RocketMQ和RabbitMQ都拥有庞大的社区和完善的生态系统，但Kafka和RocketMQ目前的发展势头比较迅猛，社区活跃度也相对较高。</li><li>实现语言方面，kafka是基于scala和java开发的，rocketmq、activemq等都是基于java语言的，rabbitmq是基于erlang的。</li></ol>]]></content>
    
    
    <categories>
      
      <category>mq</category>
      
    </categories>
    
    
    <tags>
      
      <tag>解耦</tag>
      
      <tag>异步</tag>
      
      <tag>削峰填谷</tag>
      
      <tag>高可用性</tag>
      
      <tag>高吞吐量</tag>
      
      <tag>负载均衡</tag>
      
      <tag>消息持久化</tag>
      
      <tag>事务消息</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>茶7.8-7.12</title>
    <link href="/2024/07/08/%E8%8C%B67.8-7.12/"/>
    <url>/2024/07/08/%E8%8C%B67.8-7.12/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶78-712"><a class="markdownIt-Anchor" href="#茶78-712"></a> 茶7.8-7.12</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/problemset/problem/1927/D">Find the Different Ones!_923D</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5，q 之和 ≤2e5。<br />每组数据输入 n(2≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e6)，下标从 1 开始。<br />然后输入 q(1≤q≤2e5) 和 q 个询问，每个询问输入两个数 L R(1≤L&lt;R≤n)。</p><p>对于每个询问，输出在 [L,R] 内的两个下标 i 和 j，满足 a[i] ≠ a[j]。<br />如果不存在，输出 “-1 -1”。</p><p>样例太长，请在原题查看。</p><p><strong>Sol:</strong></p><p>定义 left[i] 表示在 a[i] 左侧的不等于 a[i] 的最近元素下标。</p><p>递推：如果 a[i] = a[i-1] 则 left[i] = left[i-1]，否则 left[i] = i-1。</p><p>回答询问时，如果 left[R] &lt; L 则输出 -1 -1，否则输出 left[R] 和 R。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-function">vi <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span></span>;<br>    nxt[n<span class="hljs-number">-1</span>]=n;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=n<span class="hljs-number">-2</span>;i&gt;=<span class="hljs-number">0</span>;i--)&#123;<br>        nxt[i] = a[i] == a[i+<span class="hljs-number">1</span>] ? nxt[i+<span class="hljs-number">1</span>] : i+<span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> q;<br>    cin&gt;&gt;q;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> l,r;<br>        cin&gt;&gt;l&gt;&gt;r;<br>        l--;<br>        <span class="hljs-keyword">if</span>(nxt[l]&lt;r)&#123;<br>            cout&lt;&lt;l+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;nxt[l]+<span class="hljs-number">1</span>&lt;&lt;<span class="hljs-string">&quot;\n&quot;</span>;<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            cout&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&quot; &quot;</span>&lt;&lt;<span class="hljs-number">-1</span>&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>    &#125;   <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue"><a class="markdownIt-Anchor" href="#tue"></a> Tue</h2><p><a href="https://codeforces.com/problemset/problem/1670/C">https://codeforces.com/problemset/problem/1670/C</a></p><p>输入 T(≤1e5) 表示 T 组数据。所有数据的 n 之和 ≤5e5。<br />每组数据输入 n(1≤n≤1e5) 和两个 1~n 的排列 a 和 b，<br />然后输入数组 d，保证 d[i] 是 {0,a[i],b[i]} 中的一个。</p><p>构造一个 1~n 的排列 c，满足：<br />如果 d[i]&gt;0，那么 c[i] 必须是 d[i]，否则 c[i] 可以是 a[i]，也可以是 b[i]。</p><p>你能构造出多少个不同的排列 c？模 1e9+7。<br />保证至少能构造一个排列 c。</p><p>样例太长，请在原题查看。</p><p><strong>Sol:</strong></p><p>从 a[i] 向 b[i] 连边，我们会得到若干个环（没有树枝，因为 a 和 b 都是排列）。</p><p>对于长度大于 1 的环，如果不包含 d[i] &gt; 0 的点，那么有两种选法。</p><p>比如 1-2-3-1 这个环，每条边可以分别选 1,2,3 也可以分别选 2,3,1。</p><p>所以答案就是 2^m，其中 m 是长度大于 1 的不含 d[i]&gt;0 的环的个数。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      cin &gt;&gt; a[j];<br>      a[j]--;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      cin &gt;&gt; b[j];<br>      b[j]--;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">d</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      cin &gt;&gt; d[j];<br>      d[j]--;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>    <span class="hljs-type">bool</span> ok = <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>      <span class="hljs-keyword">if</span> (d[j] != <span class="hljs-number">-1</span>)&#123;<br>        <span class="hljs-keyword">if</span> (used[d[j]])&#123;<br>          ok = <span class="hljs-literal">false</span>;<br>        &#125;<br>        used[d[j]] = <span class="hljs-literal">true</span>;<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!ok)&#123;<br>      cout &lt;&lt; <span class="hljs-number">0</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">E</span>(n);<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        E[a[j]].<span class="hljs-built_in">push_back</span>(b[j]);<br>        E[b[j]].<span class="hljs-built_in">push_back</span>(a[j]);<br>      &#125;<br>      <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">1</span>;<br>      <span class="hljs-function">vector&lt;<span class="hljs-type">bool</span>&gt; <span class="hljs-title">used2</span><span class="hljs-params">(n, <span class="hljs-literal">false</span>)</span></span>;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++)&#123;<br>        <span class="hljs-keyword">if</span> (!used2[j])&#123;<br>          used2[j] = <span class="hljs-literal">true</span>;<br>          queue&lt;<span class="hljs-type">int</span>&gt; Q;<br>          Q.<span class="hljs-built_in">push</span>(j);<br>          <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>          <span class="hljs-type">bool</span> ok2 = <span class="hljs-literal">true</span>;<br>          <span class="hljs-keyword">while</span> (!Q.<span class="hljs-built_in">empty</span>())&#123;<br>            <span class="hljs-type">int</span> v = Q.<span class="hljs-built_in">front</span>();<br>            Q.<span class="hljs-built_in">pop</span>();<br>            cnt++;<br>            <span class="hljs-keyword">if</span> (used[v])&#123;<br>              ok2 = <span class="hljs-literal">false</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : E[v])&#123;<br>              <span class="hljs-keyword">if</span> (!used2[w])&#123;<br>                used2[w] = <span class="hljs-literal">true</span>;<br>                Q.<span class="hljs-built_in">push</span>(w);<br>              &#125;<br>            &#125;<br>          &#125;<br>          <span class="hljs-keyword">if</span> (ok2 &amp;&amp; cnt &gt;= <span class="hljs-number">2</span>)&#123;<br>            ans *= <span class="hljs-number">2</span>;<br>            ans %= MOD;<br>          &#125;<br>        &#125;<br>      &#125;<br>      cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1725/M">Moving Both Hands</a></p><p>输入 n(2≤n≤1e5) m(0≤m≤2e5)，表示一个 n 点 m 边的有向图。节点编号从 1 开始。保证图中无自环和重边。<br />然后输入 m 条边，每条边输入 x y w(1≤w≤1e9)，表示一条从 x 到 y 的边权为 w 的有向边。</p><p>定义 f(i) 为：有甲乙两人，分别从 1 和 i 出发，到达同一个点，两人用时之和的最小值。如果两人无法到达同一个点，则 f(i) = -1。<br />输出 f(2), f(3), …, f(n)。</p><p>输入<br />5 7<br />1 2 2<br />2 4 1<br />4 1 4<br />2 5 3<br />5 4 1<br />5 2 4<br />2 1 1<br />输出<br />1 -1 3 4</p><p><strong>Sol:</strong></p><p>分层图最短路。</p><p>建图：把每条有向边及其反向边加到图中，用一个额外变量 inv 表示这条边是否为反向边。</p><p>从 1 到 i 的路径分成两段：</p><p>从 1 到 x，走原图上的边。（记作状态 0）</p><p>从 x 到 i，走反向边。（记作状态 1）</p><p>由于到达每个节点时，都有两个状态，所以相当于在有 2n 个节点的图上跑 Dijkstra 算法。</p><p><a href="https://leetcode.cn/problems/network-delay-time/solution/liang-chong-dijkstra-xie-fa-fu-ti-dan-py-ooe8/">Dijkstra 算法介绍</a></p><p>类似状态机 DP，在 Dijkstra 的优先队列中，额外记录一个状态 inv，如果 inv=0 表示当前在走原图上的边，如果 inv=1 表示当前在走反向边。</p><p>如果当前状态是 0，那么可以转移到 0 或者 1。</p><p>如果当前状态是 1，那么只能转移到 1。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;array&lt;<span class="hljs-type">int</span>, 3&gt; &gt; &gt; <span class="hljs-built_in">adj</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, w;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        adj[u].<span class="hljs-built_in">push_back</span>(&#123;v, w, <span class="hljs-number">0</span>&#125;);<br>        adj[v].<span class="hljs-built_in">push_back</span>(&#123;u, w, <span class="hljs-number">1</span>&#125;);<br>    &#125;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int64_t</span> inf = <span class="hljs-number">1e18</span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int64_t</span>&gt;&gt; <span class="hljs-built_in">dist</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int64_t</span>&gt;(<span class="hljs-number">2</span>, inf));<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">st</span>(n + <span class="hljs-number">1</span>, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    priority_queue&lt;tuple&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;, vector&lt;tuple&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;, greater&lt;tuple&lt;<span class="hljs-type">int64_t</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt;&gt; hp;<br>    hp.<span class="hljs-built_in">emplace</span>(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    dist[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (!hp.<span class="hljs-built_in">empty</span>()) &#123;<br>        <span class="hljs-keyword">auto</span> [d, x, rev] = hp.<span class="hljs-built_in">top</span>();<br>        hp.<span class="hljs-built_in">pop</span>();<br>        <span class="hljs-keyword">if</span> (st[x][rev]) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        st[x][rev] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span>&amp; [y, w, e] : adj[x]) &#123;<br>            <span class="hljs-keyword">if</span> (!rev) &#123;<br>                <span class="hljs-keyword">if</span> (dist[y][e] &gt; dist[x][<span class="hljs-number">0</span>] + w) &#123;<br>                    dist[y][e] = dist[x][<span class="hljs-number">0</span>] + w;<br>                    hp.<span class="hljs-built_in">emplace</span>(dist[y][e], y, e);<br>                &#125;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">if</span> (dist[y][<span class="hljs-number">1</span>] &gt; dist[x][<span class="hljs-number">1</span>] + w &amp;&amp; e == <span class="hljs-number">1</span>) &#123;<br>                    dist[y][<span class="hljs-number">1</span>] = dist[x][<span class="hljs-number">1</span>] + w;<br>                    hp.<span class="hljs-built_in">emplace</span>(dist[y][<span class="hljs-number">1</span>], y, e);<br>                &#125;               <br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        cout &lt;&lt; (<span class="hljs-built_in">min</span>(dist[i][<span class="hljs-number">0</span>], dist[i][<span class="hljs-number">1</span>]) == <span class="hljs-number">1e18</span> ? <span class="hljs-number">-1</span> : <span class="hljs-built_in">min</span>(dist[i][<span class="hljs-number">0</span>], dist[i][<span class="hljs-number">1</span>])) &lt;&lt; <span class="hljs-string">&quot; \n&quot;</span>[i == n];<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/problemset/problem/582/B">https://codeforces.com/problemset/problem/582/B</a></p><p>输入 n(1≤n≤100) t(1≤t≤1e7) 和长为 n 的数组 a(1≤a[i]≤300)。</p><p>把 t 个一样的数组 a 拼接在一起，得到长为 t*n 的数组 b，满足 b[i] = b[i+n]。<br />输出 b 的 LIS 长度。注意这里的 LIS 是非降的，允许元素相等。</p><p>输入<br />4 3<br />3 1 4 2<br />输出<br />5</p><p><strong>Sol:</strong></p><p><a href="https://www.bilibili.com/video/BV1ub411Q7sB/">贪心+二分求 LIS</a></p><p>如果 t &lt;= n，那么直接求长为 tn 的数组的 LIS。也就是对数组 a 循环 t 次。</p><p>如果 t &gt; n，只需要循环 n 次。</p><p>设最后一轮循环（第 n 轮循环）二分的数组 f 的长度增加了 d，那么有如下结论：</p><p>接下来的 t-n 轮循环是不需要跑的，保证每轮循环 f 数组的长度都会增加 d。</p><p>例如 a=[2,3,1]，前三轮循环，找到的 LIS 为 [2,3] [1,2,3] [1,1,2,3]</p><p>后面每轮循环都只会让 f 的长度增加 1。 相当于每多一轮循环，中间就插入了一个 1。</p><p>猜想：只需要循环 sqrt(n) 左右次即可。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, t, d;<br>    cin &gt;&gt; n &gt;&gt; t;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    vi f;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt;= n &amp;&amp; t &gt; <span class="hljs-number">0</span>; i++) &#123;<br>        <span class="hljs-type">int</span> m = f.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> x : a) &#123;<br>            <span class="hljs-keyword">auto</span> j = <span class="hljs-built_in">lower_bound</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), x + <span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span> (j != f.<span class="hljs-built_in">end</span>()) &#123;<br>                *j = x;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                f.<span class="hljs-built_in">push_back</span>(x);<br>            &#125;<br>        &#125;<br>        d = f.<span class="hljs-built_in">size</span>() - m;<br>        t--;<br>    &#125;<br>    <span class="hljs-comment">//BUG(t);</span><br>    <span class="hljs-comment">//BUG(d);</span><br>    cout &lt;&lt; f.<span class="hljs-built_in">size</span>()+t*d &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/1778/F">Maximizing Root_848F</a></p><p>输入 T(≤5e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(2≤n≤1e5) k(0≤k≤n) 和长为 n 的数组 a(1≤a[i]≤1000)。<br />然后输入一棵无向树的 n-1 条边，节点编号从 1 开始。<br />根节点为 1。节点 i 的点权为 a[i]。</p><p>你可以执行如下操作至多 k 次：<br />选择一个没有操作过的节点 v 和一个整数 x，其中 x 必须满足 x 是子树 v 中所有点权的公约数。然后把子树 v 中的每个点权都乘上 x。</p><p>输出操作后，a[1] 最大是多少。</p><p>输入<br />2<br />5 2<br />24 12 24 6 12<br />1 2<br />1 3<br />2 4<br />2 5<br />5 3<br />24 12 24 6 12<br />1 2<br />1 3<br />2 4<br />2 5<br />输出<br />288<br />576</p><p><strong>Sol</strong>:</p><p>提示 1：为了让答案尽量大，从上到下操作比较好，还是从下到上操作比较好？</p><p>提示 2：答案一定是 a[1] 乘以它的一个因子。枚举这个因子 d。</p><p>提示 3：DFS 这棵树，什么情况下，子树是不需要操作的？什么情况下，子树只需要操作一次？什么情况下，子树只需要操作两次？</p><p><a href="https://www.luogu.com.cn/article/c5cqkwpk">灵神题解</a></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">divisors</span>(mx+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = mx; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i; j &lt;= mx; j+=i) &#123;<br>            divisors[j].<span class="hljs-built_in">push_back</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">ceilSqrt</span><span class="hljs-params">(mx+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= mx; i++) &#123;<br>        ceilSqrt[i] = <span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> x = i;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p = <span class="hljs-number">2</span>; p*p &lt;= x; p++) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> p2 = p*p; x%p2 == <span class="hljs-number">0</span>; x /= p2) &#123;<br>                ceilSqrt[i] *= p;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (x % p == <span class="hljs-number">0</span>) &#123;<br>                ceilSqrt[i] *= p;<br>                x /= p;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">1</span>) &#123;<br>            ceilSqrt[i] *= x;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> n , t, k;<br>    cin &gt;&gt; t;<br>    <span class="hljs-keyword">while</span> (t--) &#123;<br>        cin &gt;&gt; n &gt;&gt; k;<br>        <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>        <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">g</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;());<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> v,w;<br>            cin &gt;&gt; v &gt;&gt; w;<br>            v--;<br>            w--;<br>            g[v].<span class="hljs-built_in">push_back</span>(w);<br>            g[w].<span class="hljs-built_in">push_back</span>(v);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (k == <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; a[<span class="hljs-number">0</span>] &lt;&lt; endl;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-function">vi <span class="hljs-title">subGcd</span><span class="hljs-params">(n)</span></span>;<br>        std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs0;<br>        dfs0 = [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa) -&gt; <span class="hljs-type">void</span>&#123;<br>            subGcd[v] = a[v];<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : g[v]) &#123;<br>                <span class="hljs-keyword">if</span> (w != fa) &#123;<br>                    <span class="hljs-built_in">dfs0</span>(w, v);<br>                    subGcd[v] = <span class="hljs-built_in">gcd</span>(subGcd[v], subGcd[w]);<br>                &#125;<br>            &#125;<br>        &#125;;<br>        <span class="hljs-built_in">dfs0</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>        <span class="hljs-type">int</span> cnt;<br>        std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>)&gt; dfs;<br>        dfs = [&amp;](<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa, <span class="hljs-type">int</span> d) -&gt; <span class="hljs-type">void</span> &#123;<br>            <span class="hljs-keyword">if</span> (subGcd[v] % d == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (subGcd[v]*subGcd[v]%d == <span class="hljs-number">0</span>) &#123;<br>                cnt++;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (g[v].<span class="hljs-built_in">size</span>() == <span class="hljs-number">1</span> || a[v]*a[v]%d &gt; <span class="hljs-number">0</span>) &#123;<br>                cnt = <span class="hljs-number">1e9</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> w : g[v]) &#123;<br>                <span class="hljs-keyword">if</span> (w != fa) &#123;<br>                    <span class="hljs-built_in">dfs</span>(w, v, ceilSqrt[d]);<br>                &#125;<br>            &#125;<br>            cnt++;<br>        &#125;;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> d : divisors[a[<span class="hljs-number">0</span>]]) &#123;<br>            cnt = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> v : g[<span class="hljs-number">0</span>]) &#123;<br>                <span class="hljs-built_in">dfs</span>(v, <span class="hljs-number">0</span>, d);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (cnt &lt; k) &#123;<br>                cout &lt;&lt; a[<span class="hljs-number">0</span>]*d &lt;&lt; endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图论</tag>
      
      <tag>广度优先搜索（BFS）</tag>
      
      <tag>环检测</tag>
      
      <tag>模运算</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture8</title>
    <link href="/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/"/>
    <url>/2024/07/04/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第八课树索引"><a class="markdownIt-Anchor" href="#第八课树索引"></a> 第八课：树索引</h1><h2 id="1-表索引"><a class="markdownIt-Anchor" href="#1-表索引"></a> 1 表索引</h2><p>数据库系统内部可以使用多种不同的数据结构，例如内部元数据、核心数据存储、临时数据结构或表索引。对于可能设计范围扫描查询的表索引，哈希表可能不是最佳选择，因为它本质上是无序的。</p><p>表索引是表列子集的副本，它被组织和/或排序以便使用这些属性的子集进行有效访问。因此，DBMS可以对表索引执行查找，以更快地找到某些元组，而不是执行顺序扫描。DBMS确保表和索引的内容始终在逻辑上同步。</p><p>每个数据库创建的索引数量之间存在权衡。虽然索引越多查询速度越快，但索引也会占用内存并且需要维护。另外，保持它们同步还存在并发问题。DBMS的工作是找出用于执行查询的最佳索引。</p><h2 id="2-b树"><a class="markdownIt-Anchor" href="#2-b树"></a> 2 B+树</h2><p>B+树是一种自平衡树数据结构，可保持数据排序并允许在O(log(n))中进行搜索、顺序访问、插入和删除。它针对读取/写入大数据块的面向磁盘的DBMS进行了优化。</p><p>几乎每个支持保序索引的现代DBMS都使用B+树。有种特殊的数据结构叫做B-树，但人们也使用该术语来泛指一类数据结构。原始B-Tree和B+Tree之间的主要区别在于B-Tree在所有节点中存储键和值，而B+树仅在叶节点中存储值。现代 B+Tree 实现结合了其他 B-Tree 变体的功能，例如 B 链接树中使用的同级指针。</p><img src="../imgs/第八课：树索引/image-20240702174422330.png" alt="B+树形图" style="zoom:50%;" /><p>形式上，B+Tree 是一棵 M 路搜索树（其中 M 表示节点可以拥有的子节点的最大数量），具有以下属性：</p><ul><li>它是完美平衡的（所有叶子结点都是同一个深度）。</li><li>除根节点外的每个内部节点都至少是半满的（M/2 - 1 &lt;= 键数 &lt;= M-1)。</li><li>每个有k个键的内部节点有k+1个非空子节点。</li></ul><p>B+Tree 中的每个节点都包含一个键/值对数组。</p><p>对于叶节点，键是从索引所基于的属性派生的。虽然根据 B+Tree 的定义没有必要，但每个节点的数组几乎总是按键排序。叶节点值的两种方法是记录 ID 和元组数据。记录 ID 是指指向元组位置的指针，通常是主键。具有元组数据的叶节点存储每个节点中元组的实际内容。</p><p>对于内部节点，值包含指向其他节点的指针，并且键可以被认为是指南针。它们引导树遍历，但不表示叶节点上的键（以及它们的值）。这意味着您可能在内部节点（作为指南）中有一个在叶节点上找不到的键。尽管必须注意，传统上内部节点仅拥有叶节点中存在的那些键。</p><p>根据索引类型（首先为 NULL，最后为 NULL），空键将聚集在第一个叶节点或最后一个叶节点中。</p><h3 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h3><p>要在 B+Tree 中插入新条目，必须遍历树并使用内部节点来找出要将键插入到哪个叶节点。</p><ol><li><p>找到正确的叶子L</p></li><li><p>按排序顺序将新条目添加到 L 中：</p><ul><li>如果L有足够空间，则操作完成。</li><li>否则将叶子分为两个节点L和L2。均匀地重新分配条目并复制中间键。将指向 L2 的条目插入到 L 的父级中。</li></ul></li><li><p>要分割内部节点，请均匀地重新分配条目，但向上推中间键。</p></li></ol><h3 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h3><p>在插入中，当树太满时，我们有时不得不分割叶子，如果删除导致树小于半满，我们必须合并以重新平衡树。</p><ol><li><p>找到正确的叶子L</p></li><li><p>删除条目：</p><ul><li>如果 L 至少为半满，则操作完成。</li><li>否则，您可以尝试从兄弟姐妹那里借用来重新分配。</li><li>如果重新分配失败，则合并 L 和同级。</li></ul></li><li><p>如果发生合并，则必须删除父项中指向 L 的条目。</p></li></ol><h3 id="选型条件"><a class="markdownIt-Anchor" href="#选型条件"></a> 选型条件</h3><p>由于 B+Tree 是按顺序排序的，因此查找遍历速度很快，并且不需要整个键。如果查询提供搜索键的任何属性，则 DBMS 可以使用 B+Tree 索引。这与哈希索引不同，哈希索引需要搜索键中的所有属性。</p><p><img src="../imgs/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/image-20240702193242102.png" alt="图2:要在 B+Tree 上执行前缀搜索，需要查看键上的第一个属性，沿着路径向下并在叶子上执行顺序扫描，以找到所需的所有键。" /></p><h3 id="复制键"><a class="markdownIt-Anchor" href="#复制键"></a> 复制键</h3><p>有两种方法可以在 B+Tree 中复制键。</p><p>第一种方法是附加记录 ID 作为键的一部分。由于每个元组的记录 ID 都是唯一的，这将确保所有键都是可识别的。</p><p>第二种方法是允许叶节点溢出到包含重复键的溢出节点。虽然没有存储冗余信息，但这种方式维护和修改比较复杂</p><h3 id="聚集索引"><a class="markdownIt-Anchor" href="#聚集索引"></a> 聚集索引</h3><p>表按主键指定的排序顺序存储，作为堆或索引组织的存储。由于某些 DBMS 始终使用聚集索引，因此如果表没有显式主键，它们会自动创建隐藏的 row id 主键，但其他 DBMS 根本无法使用它们。</p><h3 id="堆聚类"><a class="markdownIt-Anchor" href="#堆聚类"></a> 堆聚类</h3><p>元组按照聚类索引指定的顺序在堆页中排序。如果使用聚簇索引的属性来访问元组，DBMS可以直接跳转到页面。</p><h3 id="索引扫描页面排序"><a class="markdownIt-Anchor" href="#索引扫描页面排序"></a> 索引扫描页面排序</h3><p>由于直接从非聚集索引检索元组效率很低，因此 DBMS 可以首先找出它需要的所有元组，然后根据它们的页 id 对它们进行排序。这样，每个页面只需提取一次。</p><h2 id="3-b树设计选择"><a class="markdownIt-Anchor" href="#3-b树设计选择"></a> 3 B+树设计选择</h2><h3 id="31-节点大小"><a class="markdownIt-Anchor" href="#31-节点大小"></a> 3.1 节点大小</h3><p>根据存储介质的不同，我们可能更喜欢更大或更小的节点大小。例如，存储在硬盘驱动器上的节点的大小通常约为兆字节，以减少查找数据所需的查找次数并分摊读取大量数据所需的昂贵磁盘成本，而内存数据库可能使用小至 512 字节的页面大小，以便将整个页面放入 CPU 缓存并减少数据碎片。这个选择还可以依赖于工作负载的类型。对于点查询而言，它会更喜欢尽可能小的页面，以减少加载不必要的额外信息的数量，而对于大规模顺序扫描而言，它可能更喜欢大页面以减少需要执行的获取次数。</p><h3 id="32-合并阈值"><a class="markdownIt-Anchor" href="#32-合并阈值"></a> 3.2 合并阈值</h3><p>虽然 B+Tree 有删除后合并下溢节点的规则，但有时暂时违反该规则可能会有益于减少删除操作的次数。例如，急于合并可能会导致抖动，其中大量连续的删除和插入操作会导致不断的拆分和合并。它还允许批量合并，其中多个合并操作同时发生，从而减少了在树上花费昂贵的写入锁存器的时间。</p><p>有一些合并策略会保留树中的小节点并在以后重建它，这使得树不平衡（如在 Postgres 中）。我们不会在课上讨论这个问题。</p><h3 id="33-可变长密钥"><a class="markdownIt-Anchor" href="#33-可变长密钥"></a> 3.3 可变长密钥</h3><p>目前我们只讨论了具有固定长度键的 B+树。然而，我们可能还希望支持可变长度密钥，例如大密钥的一小部分子集导致大量空间浪费的情况。有几种方法可以做到这一点：</p><ol><li><p><strong>指针</strong></p><p>我们可以只存储指向键的指针，而不是直接存储键。</p></li><li><p><strong>可变长节点</strong></p><p>我们还可以像平常一样存储密钥并允许可变长度节点。由于处理可变长度节点的内存管理开销很大，这通常是不可行的并且基本上不被使用。</p></li><li><p><strong>填充</strong></p><p>我们可以将每个键的大小设置为最大键的大小，并填充所有较短的键，而不是改变键的大小。在大多数情况下，这是对内存的巨大浪费，因此也看不到任何人使用它。</p></li><li><p><strong>键映射/间接</strong></p><p>几乎每个人都使用的方法是将键替换为单独字典中键值对的索引。这提供了显着的空间节省和潜在的快捷点查询（因为索引指向的键值对与叶节点指向的键值对完全相同）。由于字典索引值的大小较小，可以在索引的旁边放置每个键的前缀，这样在索引搜索和叶节点扫描时，如果前缀与搜索键不完全相同，可能并不需要追踪指针。</p></li></ol><p><img src="../imgs/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/image-20240703155322520.png" alt="图3:键映射/间接的示例。该映射存储键的一个小前缀，以及指向键值对的指针。" /></p><h3 id="34-节点内搜索"><a class="markdownIt-Anchor" href="#34-节点内搜索"></a> 3.4 节点内搜索</h3><p>一旦我们到达一个节点，我们仍然需要在该节点内搜索（要么从内部节点找到下一个节点，要么在叶节点中找到我们的键值）。虽然这相对简单，但仍然需要考虑一些权衡：</p><ol><li><p><strong>线性</strong></p><p>最简单的解决方案是扫描节点中的每个键，直到找到我们的键。一方面，我们不必担心对键进行排序，从而使插入和删除速度更快。另一方面，这是相对低效的，并且每次搜索的复杂度为 O(n)。这可以使用 SIMD（或等效）指令进行矢量化。</p></li><li><p><strong>二分</strong></p><p>更有效的搜索解决方案是保持每个节点排序并使用二分搜索来查找键。这就像跳转到节点中间并根据键之间的比较向左或向右旋转一样简单。这种方式的搜索效率要高得多，因为这种方法每次搜索的复杂度仅为 O(ln(n))。然而，插入变得更加昂贵，因为我们必须维护每个节点的排序。</p></li><li><p><strong>插值法</strong></p><p>这种方式的搜索效率要高得多，因为这种方法每次搜索的复杂度仅为 O(ln(n))。然而，插入变得更加昂贵，因为我们必须维护每个节点的排序。此方法利用存储的有关节点的任何元数据（例如最大元素、最小元素、平均值等），并使用它来生成键的大致位置。例如，如果我们在节点中查找 8，并且我们知道 10 是最大键，10−(n+ 1) 是最小键（其中 n 是每个节点中键的数量），那么我们知道从最大键开始向下搜索 2 个槽，因为在这种情况下，距离最大键 1 个槽的键必须是 9。尽管这是我们给出的最快的方法，但由于它对具有某些属性（如整数）和复杂性的密钥的适用性有限，因此该方法仅在学术数据库中出现。</p></li></ol><h2 id="4-优化"><a class="markdownIt-Anchor" href="#4-优化"></a> 4 优化</h2><h3 id="41-指针swizzling"><a class="markdownIt-Anchor" href="#41-指针swizzling"></a> 4.1 指针swizzling</h3><p>因为B+Tree的每个节点都存储在缓冲池中的一个页面中，所以每次加载新页面时，我们都需要从缓冲池中获取它，需要锁存和查找。要完全跳过此步骤，我们可以存储实际的原始指针来代替页面 ID（称为“swizzling”），从而完全防止缓冲池获取。我们可以在正常遍历索引时简单地存储页面查找的结果指针，而不是手动获取整个树并手动放置指针。请注意，我们必须跟踪哪些指针被混合，并在它们指向的页面被取消固定和受害时将它们解调回页面 ID。</p><h3 id="42-批量插入"><a class="markdownIt-Anchor" href="#42-批量插入"></a> 4.2 批量插入</h3><p>当 B+Tree 最初构建时，必须以通常的方式插入每个键将导致不断的分裂操作。由于我们已经给出了叶子同级指针，因此如果我们构造叶节点的排序链表，然后使用每个叶节点的第一个键从下往上轻松构建索引，则数据的初始插入会更有效。请注意，根据我们的上下文，我们可能希望尽可能紧密地包装叶子以节省空间，或者在每个叶子中留出空间，以便在需要分割之前允许更多插入。</p><h3 id="43-前缀压缩"><a class="markdownIt-Anchor" href="#43-前缀压缩"></a> 4.3 前缀压缩</h3><p>大多数时候，当我们在同一个节点中拥有键时，每个键的某些前缀都会有部分重叠（因为相似的键最终会在排序的 B+Tree 中紧邻彼此）。我们可以简单地将前缀存储在节点的开头一次，然后只在每个槽中包含每个键的唯一部分，而不是多次将此前缀存储为每个键的一部分。</p><p><img src="../imgs/%E7%AC%AC%E5%85%AB%E8%AF%BE%EF%BC%9A%E6%A0%91%E7%B4%A2%E5%BC%95/image-20240703162033096.png" alt="图 4：前缀压缩的示例。由于键按字典顺序排列，因此它们可能共享一些前缀。" /></p><h3 id="44-删除重复数据"><a class="markdownIt-Anchor" href="#44-删除重复数据"></a> 4.4 删除重复数据</h3><p>在允许非唯一键的索引的情况下，我们最终可能会得到包含相同键并附加不同值的叶节点。对此的一种优化可能是只写入一次密钥，然后在其后面写入所有关联的值。</p><h3 id="45-后缀截断"><a class="markdownIt-Anchor" href="#45-后缀截断"></a> 4.5 后缀截断</h3><p>大多数情况下，内部节点中的键条目仅用作路标，而不是其实际键值（即使索引中存在某个键，我们仍然必须搜索到底部以确保它没有被删除）。我们可以通过仅存储将探测器正确路由到正确节点所需的最小前缀来利用这一点。</p><h3 id="46-写入优化的-b-树"><a class="markdownIt-Anchor" href="#46-写入优化的-b-树"></a> 4.6 写入优化的 B+ 树</h3><p>拆分/合并节点操作的成本很高。因此，B-Tree 的某些变体（例如 Bε-Tree）会记录内部节点中的更改，并稍后将更新向下传播到叶节点。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>B+树</tag>
      
      <tag>表索引</tag>
      
      <tag>插入</tag>
      
      <tag>删除</tag>
      
      <tag>选型条件</tag>
      
      <tag>复制键</tag>
      
      <tag>聚集索引</tag>
      
      <tag>堆聚类</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>茶7.1-7.5</title>
    <link href="/2024/07/01/%E8%8C%B67.1-7.5/"/>
    <url>/2024/07/01/%E8%8C%B67.1-7.5/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶71-75"><a class="markdownIt-Anchor" href="#茶71-75"></a> 茶7.1-7.5</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon.</h2><p><a href="https://codeforces.com/problemset/problem/1840/D">Wooden Toy Festival_878D</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>一条街道上有 n 个工厂，第 i 个工厂的位置是 a[i]。<br />你需要建造 3 个仓库，仓库的位置由你决定，必须是整数。<br />每个工厂生产的物品要运到离其最近的仓库。</p><p>定义 d(i) = 第 i 个工厂到离其最近的仓库的距离。<br />设 M = 所有 d(i) 的最大值。<br />最小化 M，也就是最小化最大的工厂到仓库的距离。</p><p>输入<br />5<br />6<br />1 7 7 9 9 9<br />6<br />5 4 2 1 30 60<br />9<br />14 19 37 59 1 4 4 98 73<br />1<br />2<br />6<br />3 10 1 17 15 11<br />输出<br />0<br />2<br />13<br />0<br />1<br />解释<br />样例 1：在 1,7,9 处建仓库，最远距离为 0。<br />样例 2：在 3,30,60 处建仓库，最远距离为 2。<br />样例 3：在 14,50,85 处建仓库，最远距离为 13。</p><p><strong>Sol:</strong></p><p>二分答案+贪心。</p><p>把 a 从小到大排序。</p><p>设答案为 m，那么第一段（第一个仓库对应的工厂）的范围是 [a[0], a[0]+2m]，</p><p>二分找 a 中第一个大于 a[0]+2m 的数 a[i]，那么第二段的范围是 [a[i], a[i]+2m]。</p><p>继续二分，找 a 中第一个大于 a[i]+2m 的数 a[j]，那么第三段的范围是 [a[j], a[j]+2m]。</p><p>如果 a[j]+2m &gt;= a[n-1]，那么 check 是 true，否则是 false。 注意 i=n 和 j=n 的情况。</p><p>二分上界：可以直接写 1e9 或者 a[n-1]-a[0]，下面讨论更精细的上界。</p><p>假设答案 x 一定成立，那么极限情况下第一段是 [a0, a0+2x]，第二段是 [a0+2x+1, a0+4x+1]，第三段是 [a0+4x+2, a0+6x+2]，所以有 a[0]+6x+2 &lt;= a[n-1]</p><p>解得 x &gt;= ceil((a[n-1]-a[0]-2) / 6) = floor((a[n-1]-a[0]+3) / 6)</p><p>所以（开区间的）二分上界是 floor((a[n-1]-a[0]+3) / 6)。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-type">int</span> l=<span class="hljs-number">-1</span>,r=(a[n<span class="hljs-number">-1</span>] - a[<span class="hljs-number">0</span>] + <span class="hljs-number">3</span>) / <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">while</span>(r-l&gt;<span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-type">int</span> m=(l+r)&gt;&gt;<span class="hljs-number">1</span>;<br>        <span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">while</span>(i+<span class="hljs-number">1</span>&lt;a.<span class="hljs-built_in">size</span>()&amp;&amp;a[i+<span class="hljs-number">1</span>]-a[<span class="hljs-number">0</span>]&lt;=<span class="hljs-number">2</span>*m)&#123;<br>            ++i;<br>        &#125;<br>        <span class="hljs-type">int</span> j=n<span class="hljs-number">-1</span>;<br>        <span class="hljs-keyword">while</span>(j<span class="hljs-number">-1</span>&gt;=<span class="hljs-number">0</span>&amp;&amp;a.<span class="hljs-built_in">back</span>()-a[j<span class="hljs-number">-1</span>]&lt;=<span class="hljs-number">2</span>*m)&#123;<br>            --j;<br>        &#125;<br>        ++i;--j;<br>        <span class="hljs-keyword">if</span> (i &gt; j || a[j] - a[i] &lt;= <span class="hljs-number">2</span> * m) &#123;<br>            r = m;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = m;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;r&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue"><a class="markdownIt-Anchor" href="#tue"></a> Tue</h2><p><a href="https://codeforces.com/problemset/problem/1903/C">Theofanis’ Nightmare_912C</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤1e5) 和长为 n 的数组 a(-1e8≤a[i]≤1e8)。</p><p>你需要把 a 分割成若干非空段，假设分割成了 k 段，那么得分为：<br />第一段的元素和 * 1 + 第二段的元素和 * 2 + … + 第 k 段的元素和 * k</p><p>例如 [1,2,3,4] 分成两段 [1,2] 和 [3,4]，得分为<br />(1+2) * 1 + (3+4) * 2</p><p>输出最大得分。</p><p>输入<br />4<br />6<br />1 -3 7 -6 2 5<br />4<br />2 9 -5 -3<br />8<br />-3 -4 2 -5 1 10 17 23<br />1<br />830<br />输出<br />32<br />4<br />343<br />830</p><p><strong>Sol:</strong></p><p>等价转换。</p><p>和式可以视作 a 的若干后缀和之和。</p><p>例如 [1,2,3,4] 分成两段 [1,2] 和 [3,4]，得分为</p><p>(1+2) * 1 + (3+4) * 2 = (1+2+3+4) + (3+4)</p><p>所以计算 a 的所有后缀和，取其中大于 0 的后缀和相加，即为答案。注意整个数组的和一定要加进答案。</p><p>注意用 64 位整数。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    ll ans = <span class="hljs-number">0</span>;<br>    ll s = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = n<span class="hljs-number">-1</span>;i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        s += a[i];<br>        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span> || s &gt; <span class="hljs-number">0</span>) &#123;<br>            ans += s;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1849/D">https://codeforces.com/problemset/problem/1849/D</a></p><p>输入 n(1≤n≤2e5) 和长为 n 的数组 a(0≤a[i]≤2)。</p><p>最初，数组的每个元素都是蓝色的。<br />有两种类型的操作：</p><ul><li>支付一枚硬币，选择一个蓝色元素，将其涂成红色。</li><li>选择一个不等于 0 的红色元素和与其相邻的蓝色元素，将红色元素的数值减少 1，然后将蓝色元素涂成红色。<br />把每个元素都涂成红色，最少要支付多少金币？</li></ul><p>输入<br />3<br />0 2 0<br />输出 1</p><p>输入<br />4<br />0 0 1 1<br />输出 2</p><p>输入<br />7<br />0 1 0 0 1 0 2<br />输出 4</p><p><strong>Sol:</strong></p><p><a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solution/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-zuspx/">分组循环</a> +贪心。</p><p>内层循环寻找非 0 的段（连续子数组）。</p><p>对于非 0 的段（下标从 i 到 j），把端点 i 或者 j 涂成红色后，最终整个段都会变成红色。 如果段中没有 2，那么 i-1 或者 j+1 会变成红色，取决于一开始涂的是哪个端点。</p><p>贪心来说，优先把左边的变成红色，即如果 i&gt;0 且 i-1 不是红色，那么把 i-1 变成红色，否则把 j+1 变成红色。</p><p>如果段中有 2，那么把 2 涂成红色，最终 i-1 和 j+1 都会变成红色。</p><p>答案为段的个数，加上最后剩下的蓝色 0 的个数。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ) &#123;<br>        <span class="hljs-keyword">if</span> (a[i] == <span class="hljs-number">0</span>) &#123;<br>            ans++;<br>            i++;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> st = i;<br>        <span class="hljs-type">bool</span> h2 = <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span>(; i &lt; n &amp;&amp; a[i]&gt;<span class="hljs-number">0</span>; i++) &#123;<br>            <span class="hljs-keyword">if</span>(a[i]==<span class="hljs-number">2</span>) &#123;<br>                h2=<span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125;<br>        ans++;<br>        <span class="hljs-keyword">if</span> (st&gt;<span class="hljs-number">0</span> &amp;&amp; a[st<span class="hljs-number">-1</span>]==<span class="hljs-number">0</span>) &#123;<br>            ans--;<br>            <span class="hljs-keyword">if</span> (!h2) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span>(i &lt; n) &#123;<br>            a[i] = <span class="hljs-number">1</span>;<br>            i++;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/problemset/problem/455/C">Civilization_260C</a></p><p>输入 n m(0≤m&lt;n≤3e5) 和 q(1≤q≤3e5)。<br />然后输入一个森林的 m 条边。注：森林由多棵树组成。<br />然后输入 q 个询问，格式如下：<br />“1 x”：输出节点 x 所在的树的直径。<br />“2 x y”：如果节点 x 和节点 y 在同一棵树，什么也不做；否则在这两棵树之间连一条边，要求连边后，得到的新树的直径最小。<br />所有输入的节点编号均从 1 开始。</p><p>输入<br />6 0 6<br />2 1 2<br />2 3 4<br />2 5 6<br />2 3 2<br />2 5 3<br />1 1<br />输出<br />4</p><p><strong>Sol:</strong></p><p>在 <a href="https://leetcode.cn/problems/find-minimum-diameter-after-merging-two-trees/solutions/2826587/lian-jie-zhi-jing-zhong-dian-pythonjavac-0e1c/">周赛第四题</a> 的基础上，套一个带权并查集。</p><p>初始化：跑树形 DP 的同时，把树上的每个节点 x 和根节点 i 合并。在根节点 i 处记录直径信息 d[i]。</p><p>合并：按照周赛第四题的做法更新直径，如果要把 y 合并到 x 上，那么更新 d[x] = max(d[x], d[y], (d[x]+1)/2+(d[y]+1)/2+1)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">const</span> <span class="hljs-type">long</span> <span class="hljs-type">long</span> inf = numeric_limits&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>&gt;::<span class="hljs-built_in">max</span>();<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">dsu</span><br>&#123;<br>    vector&lt;<span class="hljs-type">int</span>&gt; fa, siz;<br>    <span class="hljs-built_in">dsu</span>(<span class="hljs-type">int</span> n)<br>    &#123;<br>        <span class="hljs-built_in">init</span>(n);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function">    </span>&#123;<br>        fa.<span class="hljs-built_in">resize</span>(n);<br>        siz.<span class="hljs-built_in">resize</span>(n, <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++)<br>        &#123;<br>            fa[i] = i;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> t = x;<br>        <span class="hljs-keyword">while</span> (fa[x] != x)<br>        &#123;<br>            x = fa[x];<br>        &#125;<br>        <span class="hljs-keyword">while</span> (t != x)<br>        &#123;<br>            <span class="hljs-type">int</span> p = t;<br>            fa[p] = x;<br>            t = fa[t];<br>        &#125;<br>        <span class="hljs-keyword">return</span> fa[x];<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> root1 = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-type">int</span> root2 = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (root1 != root2)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (root1 &lt; root2)<br>            &#123;<br>                fa[root2] = root1;<br>                siz[root2] += siz[root1];<br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                fa[root1] = root2;<br>                siz[root1] += siz[root2];<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">int</span> root = <span class="hljs-built_in">find</span>(x);<br>        <span class="hljs-keyword">return</span> siz[root];<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; q;<br>    <span class="hljs-function">dsu <span class="hljs-title">dsu</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">int</span> a,b;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        g[a].<span class="hljs-built_in">pb</span>(b);<br>        g[b].<span class="hljs-built_in">pb</span>(a);<br>        dsu.<span class="hljs-built_in">merge</span>(a, b);<br>    &#125;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt; &gt; <span class="hljs-built_in">st</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">dis</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        dis[i] = <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">auto</span> bfs = [&amp;](<span class="hljs-type">int</span> x) -&gt; <span class="hljs-type">int</span><br>    &#123;<br>        queue&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt;&gt; pq;<br>        st[x][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(x, <span class="hljs-number">0</span>));<br>        pair&lt;ll, ll&gt; tag = <span class="hljs-built_in">make_pair</span>(-inf, <span class="hljs-number">-1</span>);<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t = pq.<span class="hljs-built_in">front</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            <span class="hljs-type">int</span> a = t.first, dis = t.second;<br>            <span class="hljs-keyword">if</span> (dis &gt; tag.first)<br>            &#123;<br>                tag.first = dis;<br>                tag.second = a;<br>            &#125;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : g[a])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (st[b][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    st[b][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>                    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(b, dis + <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        ll ans = -inf;<br>        st[tag.second][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>        pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(tag.second, <span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">while</span> (!pq.<span class="hljs-built_in">empty</span>())<br>        &#123;<br>            <span class="hljs-keyword">auto</span> t = pq.<span class="hljs-built_in">front</span>();<br>            pq.<span class="hljs-built_in">pop</span>();<br>            ll a = t.first, dis = t.second;<br>            ans = <span class="hljs-built_in">max</span>(ans, dis);<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> b : g[a])<br>            &#123;<br>                <span class="hljs-keyword">if</span> (st[b][<span class="hljs-number">1</span>] == <span class="hljs-number">0</span>)<br>                &#123;<br>                    st[b][<span class="hljs-number">1</span>] = <span class="hljs-number">1</span>;<br>                    pq.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">make_pair</span>(b, dis + <span class="hljs-number">1</span>));<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (st[i][<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>)<br>        &#123;<br>            dis[i] = <span class="hljs-built_in">bfs</span>(i);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// for (int i = 1; i &lt;= n; i++)</span><br>    <span class="hljs-comment">// &#123;</span><br>    <span class="hljs-comment">//     cout &lt;&lt; i &lt;&lt; &quot; this dis &quot; &lt;&lt; dis[i] &lt;&lt; endl;</span><br>    <span class="hljs-comment">// &#125;</span><br>    <span class="hljs-keyword">while</span> (q--)<br>    &#123;<br>        <span class="hljs-type">int</span> t;<br>        cin &gt;&gt; t;<br>        <span class="hljs-keyword">if</span> (t == <span class="hljs-number">1</span>)<br>        &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            cout &lt;&lt; dis[dsu.<span class="hljs-built_in">find</span>(x)] &lt;&lt; endl;<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-type">int</span> x, y;<br>            cin &gt;&gt; x &gt;&gt; y;<br>            <span class="hljs-keyword">if</span> (!dsu.<span class="hljs-built_in">same</span>(x, y))<br>            &#123;<br>                <br>                <span class="hljs-type">int</span> fa1 = dsu.<span class="hljs-built_in">find</span>(x);<br>                <span class="hljs-type">int</span> fa2 = dsu.<span class="hljs-built_in">find</span>(y);<br>                <span class="hljs-type">int</span> d1 = dis[fa1];<br>                <span class="hljs-type">int</span> d2 = dis[fa2];<br>                dsu.<span class="hljs-built_in">merge</span>(x, y);<br>                <span class="hljs-type">int</span> d = <span class="hljs-built_in">max</span>(&#123;d1, d2, (d1 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + (d2 + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>&#125;);<br>                <span class="hljs-keyword">if</span> (fa1 &lt; fa2)<br>                &#123;<br>                    dis[fa1] = d;<br>                &#125;<br>                <span class="hljs-keyword">else</span><br>                &#123;<br>                    dis[fa2] = d;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125; <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/633/F">The Chocolate Spree</a></p><p>输入 n(2≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，表示每个节点的点权。<br />然后输入一棵树的 n-1 条边，节点编号从 1 开始。</p><p>你需要从这棵树中，选出两条不相交的路径，也就是没有节点会同时出现在两条路径中。<br />输出这两条路径的节点点权之和的最大值。</p><p>输入<br />9<br />1 2 3 4 5 6 7 8 9<br />1 2<br />1 3<br />1 4<br />1 5<br />1 6<br />1 7<br />1 8<br />1 9<br />输出 25</p><p>输入<br />2<br />20 10<br />1 2<br />输出 30</p><p><strong>Sol:</strong></p><p>如果只有一条路径，做法类似求 <a href="https://www.bilibili.com/video/BV17o4y187h1/">树的直径</a> ，把路径分解成左右两条链，dfs 返回从叶子到当前节点的最长链。</p><p><strong>方法一：两次 DFS（换根 DP）</strong></p><p>提示：枚举边，删除这条边，把这棵树一分为二，每部分只需要计算一条最大路径和。</p><p>分类讨论：</p><p>如果两条路径分别在两棵不相交子树中，那么做法和求直径是一样的，设当前节点为 v，维护前面遍历的 v 的儿子子树的最大路径和，加上当前儿子子树的最大路径和。</p><p>dfs 除了返回最长链，还要返回子树最大路径和。</p><p>如果两条路径分别在两棵相交子树中，考虑换根 DP，一条路径在子树 w 中，另一条路径从 v 开始的以下三条链中选两条：</p><p>v - w1 子树中的最长链（其中 w1 != w）</p><p>v - w2 子树中的最长链（其中 w2 != w）</p><p>v - 从父节点过来的最长链（在换根的过程中计算）</p><p><a href="https://codeforces.com/problemset/submission/633/268735935">代码一</a></p><p><strong>方法二：一次 DFS</strong></p><p>如右图所示，下文把： 从叶子往上到 v 的路径称作「链」。</p><p><img src="../imgs/%E8%8C%B67.1-7.5/image-20240705143418240.png" alt="dfs" /></p><p>由两条链拼成的路径叫做「路」。</p><p>由链 + 路组成的复合结构叫做「链路」。</p><p>注意链路中的链和路不一定在一起，可能间隔很远。</p><p>分类讨论，遍历 v 的子树列表时，假设当前遍历到子树 w，得到其「w 链」「w 路」「w 链路」，同时维护遍历过的子树的「最大链」「含 v 最大路」「不含 v 最大路」「最大链路」。其中「最大链」「最大链路」已经把 a[v] 算进去了。</p><p>如图，答案是以下三种情况的最大值： <img src="../imgs/%E8%8C%B67.1-7.5/image-20240705143402152.png" alt="dfs" /></p><p>max(含 v 最大路, 不含 v 最大路) + w 路</p><p>最大链 + w 链路</p><p>最大链路 + w 链</p><p>其中「最大链路」是以下三种情况的最大值：</p><p>w 链路 + a[v]</p><p>不含 v 最大路 + w 链 + a[v]</p><p>最大链 + w 路</p><p>注意链路这一复合结构，一定是链在上，路在下，不然无法往上加点。 不能是【含 v 最大路 + w 链】。</p><p>这也是为什么我们要区分这两种最大路。</p><p>含 v 最大路的计算方式同直径，取最大链 + w 链的最大值。</p><p>而最大链又是 w 链 + a[v] 的最大值。注意变量更新的顺序。</p><p>不含 v 最大路是 w 路的最大值。</p><p><a href="https://codeforces.com/problemset/submission/633/268854936">代码二</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> n, ans = <span class="hljs-number">0</span>;<br>vector&lt;<span class="hljs-type">int</span>&gt; a;<br>vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; g;<br><span class="hljs-function">tuple&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-type">int</span> val = a[v];<br>    <span class="hljs-type">int</span> maxChain = val;<br>    <span class="hljs-type">int</span> maxPathV = val;<br>    <span class="hljs-type">int</span> maxPathW = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> maxChainPath = val;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : g[v]) &#123;<br>        <span class="hljs-keyword">if</span> (w == fa) <span class="hljs-keyword">continue</span>;<br>        <span class="hljs-keyword">auto</span> [chainW, pathW, chainPathW] = <span class="hljs-built_in">dfs</span>(w, v);<br>        ans = <span class="hljs-built_in">max</span>(&#123;ans, maxPathV + pathW, maxPathW + pathW, maxChain + chainPathW, maxChainPath + chainW&#125;);<br>        maxChainPath = <span class="hljs-built_in">max</span>(&#123;maxChainPath, chainPathW + val, maxPathW + chainW + val, maxChain + pathW&#125;);<br>        maxPathV = <span class="hljs-built_in">max</span>(maxPathV, maxChain + chainW);<br>        maxPathW = <span class="hljs-built_in">max</span>(maxPathW, pathW);<br>        maxChain = <span class="hljs-built_in">max</span>(maxChain, chainW + val);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> &#123;maxChain, <span class="hljs-built_in">max</span>(maxPathV, maxPathW), maxChainPath&#125;;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    cin &gt;&gt; n;<br>    a.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    g.<span class="hljs-built_in">resize</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> v, w;<br>        cin &gt;&gt; v &gt;&gt; w;<br>        --v; --w;<br>        g[v].<span class="hljs-built_in">push_back</span>(w);<br>        g[w].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br><br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>);<br>    cout &lt;&lt; ans &lt;&lt; endl;<br><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>图论</tag>
      
      <tag>贪心算法</tag>
      
      <tag>二分查找</tag>
      
      <tag>DFS（深度优先搜索）</tag>
      
      <tag>树形DP</tag>
      
      <tag>并查集</tag>
      
      <tag>最短路径</tag>
      
      <tag>动态规划</tag>
      
      <tag>分治法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture7</title>
    <link href="/2024/07/01/%E7%AC%AC%E4%B8%83%E8%AF%BE%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    <url>/2024/07/01/%E7%AC%AC%E4%B8%83%E8%AF%BE%EF%BC%9A%E5%93%88%E5%B8%8C%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第七课哈希表"><a class="markdownIt-Anchor" href="#第七课哈希表"></a> 第七课：哈希表</h1><h2 id="1-数据结构"><a class="markdownIt-Anchor" href="#1-数据结构"></a> 1 数据结构</h2><p>DBMS 对系统内部的许多不同部分使用各种数据结构。一些例子包括：</p><ul><li>**内部元数据：**这是跟踪有关数据库和系统状态的信息的数据。比如：页表，页目录</li><li>**核心数据存储：**数据结构用作数据库中元组的基础存储。</li><li>**临时数据结构：**DBMS 可以在处理查询时动态构建临时数据结构以加速执行（例如，用于连接的哈希表）。</li><li>**表索引：**辅助数据结构可用于更轻松地查找特定元组。</li></ul><p>在实现DBMS的数据结构时，需要考虑两个主要的设计决策：</p><ol><li>数据组织：我们需要弄清楚如何布局存储以及在数据结构内存储哪些信息以支持高效访问。</li><li>并发性：我们还需要思考如何让多个线程访问数据结构而不引起问题，确保数据保持正确和健全。</li></ol><h2 id="2-哈希表"><a class="markdownIt-Anchor" href="#2-哈希表"></a> 2 哈希表</h2><p>哈希表实现了将键映射到值的关联数据抽象数据类型。它平均提供O（1）操作复杂度（最坏情况下为O（n））和O（n）存储复杂度。请注意，即使平均操作复杂度为O（1），在现实世界中也存在需要考虑的常数因子优化。</p><p>哈希表实现由两个方面组成：</p><ul><li>**哈希函数：**这告诉我们如何将大的密钥空间映射到更小的域中。它用于计算存储桶或槽数组的索引。我们需要考虑快速执行和冲突率之间的权衡。在一个极端，我们有一个哈希函数，它总是返回一个常量（非常快，但一切都是冲突）。在另一个极端，我们有一个“完美”的哈希函数，没有冲突，但需要很长时间才能计算。理想的设计是介于两者之间。</li><li>**哈希方案：**这告诉我们如何处理哈希后的密钥冲突。在这里，我们需要考虑分配一个大的哈希表以减少冲突和在发生冲突时必须执行额外的指令之间的权衡</li></ul><h2 id="3-哈希函数"><a class="markdownIt-Anchor" href="#3-哈希函数"></a> 3 哈希函数</h2><p>哈希函数接受任何键作为其输入。然后它返回该键的整数表示（即“哈希”）。该函数的输出是确定性的（即相同的密钥应始终生成相同的哈希输出）。</p><p>DBMS 不需要使用加密安全哈希函数（例如 SHA-256），因为我们不需要担心保护密钥内容。这些哈希函数主要由 DBMS 内部使用，因此信息不会泄漏到系统外部。一般来说，我们只关心哈希函数的速度和碰撞率。</p><p>目前最先进的哈希函数是 Facebook XXHash3。</p><h2 id="4-静态哈希方案"><a class="markdownIt-Anchor" href="#4-静态哈希方案"></a> 4 静态哈希方案</h2><p>静态哈希方案是哈希表大小固定的一种方案。这意味着如果DBMS耗尽了哈希表中的存储空间，那么它必须从头开始重建更大的哈希表，这是非常昂贵的。通常新哈希表的大小是原始哈希表的两倍。</p><p>为了减少浪费的比较次数，避免散列密钥的冲突很重要。通常，我们使用的槽数是预期元素数的两倍。</p><p>以下假设在现实中通常不成立：</p><ol><li>提前知道元素的数量</li><li>键是不唯一的</li><li>存在完美的哈希函数</li></ol><p>因此，我们需要适当选择哈希函数和哈希模式。</p><h3 id="41-线性探查哈希"><a class="markdownIt-Anchor" href="#41-线性探查哈希"></a> 4.1 线性探查哈希</h3><p>这是最基本的哈希方案。它通常也是最快的。它使用数组槽的循环缓冲区。哈希函数将键映射到槽。当发生冲突时，我们线性搜索相邻的槽，直到找到一个开放的槽。对于查找，我们可以检查键散列到的槽，并线性搜索，直到找到所需的条目。如果我们到达一个空槽或迭代哈希表中的每个槽，则该键不在表中。请注意，这意味着我们必须将键和值都存储在槽中，以便我们可以检查条目是否是所需的条目。删除则更加棘手。我们必须小心从槽中删除条目，因为这可能会阻止将来的查找找到已放在现在空槽下方的条目。这个问题有两种解决方案：</p><ul><li>最常见的方法是使用“墓碑”。我们没有删除该条目，而是将其替换为“逻辑删除”条目，该条目告诉未来的查找继续扫描。</li><li>另一种选择是在删除条目后移动相邻数据以填充现在的空槽。但是，我们必须小心，只移动最初移动的条目。这在实践中很少实现，因为当我们拥有大量密钥时，它的成本非常高。</li></ul><p>**非唯一键：**在同一键可能与多个不同值或元组关联的情况下，有两种方法。</p><ul><li>**单独的链表：**我们不存储带有键的值，而是存储一个指向单独存储区域的指针，该存储区域包含所有值的链表，这可能会溢出到多个页面。</li><li>**冗余键：**更常见的方法是简单地在表中多次存储相同的键。即使我们这样做，所有线性探测仍然有效。</li></ul><p><strong>优化：</strong></p><p>有多种方法可以进一步优化此哈希方案：</p><ul><li>基于数据类型或键大小的专用哈希表实现：它们存储数据、执行拆分等的方式可能有所不同。例如，如果我们有字符串键，我们可以在原始哈希表中存储较小的字符串，而对于较大的字符串仅存储指针或哈希。</li><li>将元数据存储在单独的数组中：一个示例是将空槽/逻辑删除信息存储在打包位图中作为页头的一部分或存储在单独的哈希表中，这将帮助我们避免查找已删除的键。</li><li>维护哈希表及其槽的版本：由于为哈希表分配内存非常昂贵，因此我们可能希望重复重用相同的内存。要清除表并使其条目无效，我们可以增加表的版本计数器，而不是将每个槽标记为已删除/空。如果槽版本与表版本不匹配，则槽可以被视为空。</li></ul><p>Google的absl::flat_hash_map是线性探针哈希的最先进的实现。</p><h3 id="42-cuckoo哈希"><a class="markdownIt-Anchor" href="#42-cuckoo哈希"></a> 4.2 Cuckoo哈希</h3><p>这种方法不再使用一个单一的哈希表，而是维护多个具有不同哈希函数的哈希表。这些哈希函数使用相同的算法（例如XXHash、CityHash），通过使用不同的种子值为相同的键生成不同的哈希值。</p><p>当我们插入时，我们会检查每个表并选择一个具有空闲插槽的表（如果有多个表都有一个插槽，可以比较负载因子，或者更常见的，随机选择一个表）。如果没有表有空闲插槽，我们会选择（通常是随机选择一个）并驱逐旧条目。然后我们将旧条目重新哈希到另一个表中。在极少数情况下，我们可能会陷入一个循环。如果发生这种情况，我们可以使用新的哈希函数种子重建所有哈希表（不太常见）或使用更大的表重建哈希表（更常见）。</p><p>Cuckoo 哈希保证 O(1) 查找和删除，但插入可能更昂贵。</p><p>**教授注：**Cuckoo哈希的本质是多个哈希函数将一个键映射到不同的槽。在实践中，Cuckoo哈希是通过多个哈希函数来实现的，这些函数将一个键映射到单个哈希表中的不同槽。此外，由于散列可能并不总是 O(1)，Cuckoo散列查找和删除的成本可能超过 O(1)。</p><h2 id="5-动态哈希方案"><a class="markdownIt-Anchor" href="#5-动态哈希方案"></a> 5 动态哈希方案</h2><p>静态散列方案要求 DBMS 知道它想要存储的元素数量。否则，如果需要增大/缩小表的大小，则必须重建表。</p><p>动态哈希方案能够根据需要调整哈希表的大小，而无需重建整个表。这些方案以不同的方式执行大小调整，可以最大化读取或写入。</p><h3 id="51-链式哈希"><a class="markdownIt-Anchor" href="#51-链式哈希"></a> 5.1 链式哈希</h3><p>这是最常见的动态哈希方案。 DBMS 为哈希表中的每个槽维护一个存储桶的链表。散列到同一槽的键被简单地插入到该槽的链表中。</p><p>为了查找一个元素，我们散列到它的存储桶，然后扫描它。这可以通过在存储桶指针列表中额外存储布隆过滤器来优化，这会告诉我们链表中是否不存在某个键，并帮助我们避免在这种情况下进行查找。</p><h3 id="52-可扩展哈希"><a class="markdownIt-Anchor" href="#52-可扩展哈希"></a> 5.2 可扩展哈希</h3><p>链式哈希的改进变体，它分割存储桶而不是让链永远增长。这种方法允许哈希表中的多个槽位置指向同一个桶链。</p><p>重新平衡哈希表背后的核心思想是在拆分时移动存储桶条目，并增加要检查的位数以查找哈希表中的条目。这意味着 DBMS 只需要在分割链的桶内移动数据；所有其他桶保持不变。</p><ul><li>DBMS 维护全局和局部深度位计数，确定在槽数组中查找存储桶所需的位数</li><li>当存储桶已满时，DBMS 会拆分存储桶并重新排列其元素。如果分割桶的局部深度小于全局深度，则新的桶将被添加到现有的槽数组中。否则，DBMS 将槽数组的大小加倍以容纳新的存储桶，并增加全局深度计数器。</li></ul><h3 id="53-线性哈希"><a class="markdownIt-Anchor" href="#53-线性哈希"></a> 5.3 线性哈希</h3><p>该方案不会在桶溢出时立即拆分桶，而是维护一个 split 指针来跟踪下一个要拆分的桶。无论这个指针是否指向溢出的桶，DBMS 总是会分裂。溢出标准由实现决定。</p><ul><li>当任何桶溢出时，在指针位置分裂桶。添加新的槽条目和新的哈希函数，并应用此函数对拆分存储桶中的键进行重新哈希。</li><li>如果原始哈希函数映射到先前已被分割指针指向的槽，则应用新的哈希函数来确定键的实际位置。</li><li>当指针到达最后一个槽时，删除原来的哈希函数并将指针移回到开头。</li></ul><p>如果split指针下面的最高bucket是空的，我们还可以删除该bucket，并将split指针反向移动，从而缩小哈希表的大小。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>哈希表</tag>
      
      <tag>静态哈希方案</tag>
      
      <tag>动态哈希方案</tag>
      
      <tag>线性探查哈希</tag>
      
      <tag>Cuckoo哈希</tag>
      
      <tag>链式哈希</tag>
      
      <tag>可扩展哈希</tag>
      
      <tag>线性哈希</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>茶6.24-6.28</title>
    <link href="/2024/06/24/%E8%8C%B66.24-6.28/"/>
    <url>/2024/06/24/%E8%8C%B66.24-6.28/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶624-628"><a class="markdownIt-Anchor" href="#茶624-628"></a> 茶6.24-6.28</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/problemset/problem/1759/E">https://codeforces.com/problemset/problem/1759/E</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤2e5) h(1≤h≤1e6) 和长为 n 的数组 a(1≤a[i]≤1e8)。</p><p>一开始你有一个数 sum，初始值为 h。<br />每次操作，你可以选择如下三种操作的其中一个：</p><ol><li>删除一个 小于sum的 a[i]，然后把 sum 增加 floor(a[i]/2)。</li><li>sum *= 2，该操作至多执行 2 次。</li><li>sum *= 3，该操作至多执行 1 次。</li></ol><p>输出最多可以删除多少个数。</p><p>输入<br />8<br />4 1<br />2 1 8 9<br />3 3<br />6 2 60<br />4 5<br />5 1 100 5<br />3 2<br />38 6 3<br />1 1<br />12<br />4 6<br />12 12 36 100<br />4 1<br />2 1 1 15<br />3 5<br />15 1 13<br />输出<br />4<br />3<br />3<br />3<br />0<br />4<br />4<br />3</p><p><strong>Sol：</strong></p><p>枚举 *2 和 *3 的使用顺序，有三种情况：</p><p>*2 *2 *3</p><p>*2 *3 *2</p><p>*3 *2 *2</p><p>对于每种顺序，贪心从小到大遍历 a（所以需要把 a 排序），如果 a[i] &gt;= 当前数字就使用乘法。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">f</span><span class="hljs-params">(vll a, ll sum, ll* f)</span> </span>&#123;<br>    <span class="hljs-type">int</span> now = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-literal">true</span>) &#123;<br>        <span class="hljs-keyword">if</span>(now == a.<span class="hljs-built_in">size</span>()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (a[now] &lt; sum) &#123;<br>            sum += a[now++]/<span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">3</span>)&#123;<br>            sum *= f[i++];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> now;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n,sum;<br>    cin&gt;&gt;n&gt;&gt;sum;<br>    <span class="hljs-function">vll <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a);<br>    ll now = <span class="hljs-number">0</span>;<br>    ll f1[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>&#125;;ll f2[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">2</span>&#125;;ll f3[<span class="hljs-number">3</span>] = &#123;<span class="hljs-number">3</span>,<span class="hljs-number">2</span>,<span class="hljs-number">2</span>&#125;;<br>    cout &lt;&lt; <span class="hljs-built_in">max</span>(<span class="hljs-built_in">f</span>(a,sum,f1),<span class="hljs-built_in">max</span>(<span class="hljs-built_in">f</span>(a,sum,f2),<span class="hljs-built_in">f</span>(a,sum,f3))) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue"><a class="markdownIt-Anchor" href="#tue"></a> Tue</h2><p><a href="https://codeforces.com/contest/1883/problem/F">You Are So Beautiful_905F</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>输出 a 有多少个非空连续子数组 b，满足 b 是 a 的唯一子序列（不存在其他的子序列等于 b）。</p><p>输入<br />6<br />1<br />1<br />2<br />1 1<br />3<br />1 2 1<br />4<br />2 3 2 1<br />5<br />4 5 4 5 4<br />10<br />1 7 7 2 3 4 3 2 1 100<br />输出<br />1<br />1<br />4<br />7<br />4<br />28</p><p>考察子数组最左边和最右边的元素。</p><p>条件一：子数组最左边的元素 a[L]，其左侧不能有等于 a[L] 的元素，否则子序列不唯一。</p><p>条件二：子数组最右边的元素 a[R]，其右侧不能有等于 a[R] 的元素，否则子序列不唯一。</p><p>结论：满足这两个条件，则子序列是唯一的。</p><p>证明：用反证法证明。</p><p>假设子序列不唯一，那么另一个子序列的不同下标一定位于 [L,R] 内部（如果位于 [L,R] 外面就破坏了条件一或条件二），但是这个范围内的所有下标我们都选了，不可能存在一个子序列没有而另一个子序列有的情况，矛盾，故原命题成立。</p><p>怎么计算子数组个数呢？ 前后缀分解。</p><p>处理出每个 a[i] 首次和最后一次出现的位置。（实际只需要处理最后一次） 枚举 a[i] 作为左端点，那么 a[i] 必须是首次出现的元素，我们还需要知道 &gt;=i 的且是最后一次出现的元素的个数，具体见代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    mii r;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        r[a[i]]=i;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    map&lt;<span class="hljs-type">int</span>, <span class="hljs-type">bool</span>&gt; vis;<br>    <span class="hljs-type">int</span> rs = r.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (!vis[a[i]]) &#123;<br>            vis[a[i]] = <span class="hljs-literal">true</span>;<br>            ans += rs; <br>        &#125;<br>        <span class="hljs-keyword">if</span> (r[a[i]] == i) &#123;<br>            rs--;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1862/E">Kolya and Movie Theatre_894E</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n m(1≤m≤n≤2e5) d(1≤d≤1e9) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。</p><p>从 a 中选一个长度至多为 m 的子序列 b。<br />设 b 的最后一个数在 a 中的下标为 i，定义 f(b)=sum(b)-i*d。（下标从 1 开始）<br />你需要最大化 f(b)。如果 b 是空的，那么 f(b)=0。</p><p>注：子序列不一定连续。</p><p>输入<br />6<br />5 2 2<br />3 2 5 4 6<br />4 3 2<br />1 1 1 1<br />6 6 6<br />-82 45 1 -77 39 11<br />5 2 2<br />3 2 5 4 8<br />2 1 1<br />-1 2<br />6 3 2<br />-8 8 -2 -1 9 0<br />输出<br />2<br />0<br />60<br />3<br />0<br />7</p><p><strong>Sol:</strong></p><p>枚举最后一个数的下标 i=1,2,3,…,n，同时维护前 m 大的正数。</p><p>那么答案就是【堆中元素之和 - i*d】的最大值。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, d;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; d;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    set&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; s;<br>    <span class="hljs-type">int</span> sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> cur = sum + a[i] - d * (i + <span class="hljs-number">1</span>);<br>        ans = <span class="hljs-built_in">max</span>(ans, cur);<br>        <span class="hljs-keyword">if</span> (a[i] &gt; <span class="hljs-number">0</span>) &#123;<br>            s.<span class="hljs-built_in">insert</span>(&#123;a[i], i&#125;);<br>            sum += a[i];<br>            <span class="hljs-keyword">if</span> (s.<span class="hljs-built_in">size</span>() &gt;= m) &#123;<br>                <span class="hljs-comment">// BUG(s.begin()-&gt;first);</span><br>                sum -= (s.<span class="hljs-built_in">begin</span>()-&gt;first);<br>                s.<span class="hljs-built_in">erase</span>(s.<span class="hljs-built_in">begin</span>());<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/contest/1851/problem/G">The Great Equalizer_894E</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5，m 之和 ≤2e5，q 之和 ≤2e5。<br />每组数据输入 n(2≤n≤2e5) m(1≤m≤2e5)，表示一个 n 点 m 边的无向图。节点编号从 1 开始。保证图中无自环和重边。<br />然后输入长为 n 的数组 h(1≤h[i]≤1e9)。每个节点有一座山，第 i 座山的高度为 h[i]。<br />然后输入 m 条边。<br />然后输入 q(1≤q≤2e5) 和 q 个询问，每个询问输入 a b e(0≤e≤1e9)。</p><p>从第 i 座山移动到和 i 相邻的第 j 座山，你的能量会减少 h[j]-h[i]。如果这个值是负数则你会增加能量。<br />只有在移动后能量 &gt;= 0 的情况下才能从 i 移动到 j。<br />对于每个询问，回答：在你初始能量为 e 的情况下，能否从第 a 座山移动到第 b 座山？输出 YES 或 NO。注意节点编号从 1 开始。</p><p>样例太长，请在原题查看。</p><p>离线+并查集。</p><p><strong>Sol：</strong></p><p>根据题意，从 a 到 b，路径上的山的高度必须都 &lt;= h[a] + e。</p><p>把询问按照 h[a]+e 从小到大排序，把 h 也从小到大排序（带上下标一起排序）。</p><p>双指针遍历询问和 h 数组，对于所有高度 &lt;= h[a]+e 的山 x，我们将 x 及其高度 &lt;= x 的邻居用并查集合并。</p><p>合并后，如果发现 a 和 b 被合并在一起，就说明可以从 a 到 b。</p><p>为了找到 x 的所有高度 &lt;= x 的邻居，在读取 m 条边时，总是把 h 值大的点指向 h 值小的点。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Dsu</span> &#123;<br>    std::vector&lt;<span class="hljs-type">int</span>&gt; f, siz;<br>    <span class="hljs-function"><span class="hljs-keyword">explicit</span> <span class="hljs-title">Dsu</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> : f(n), siz(n, <span class="hljs-number">1</span>) &#123;</span> std::<span class="hljs-built_in">iota</span>(f.<span class="hljs-built_in">begin</span>(), f.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>); &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> f[x] == x ? x : f[x] = <span class="hljs-built_in">find</span>(f[x]); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">same</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">find</span>(x) == <span class="hljs-built_in">find</span>(y); &#125;<br>    <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">merge</span><span class="hljs-params">(<span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y)</span> </span>&#123;<br>        x = <span class="hljs-built_in">find</span>(x);<br>        y = <span class="hljs-built_in">find</span>(y);<br>        <span class="hljs-keyword">if</span> (x == y) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        siz[x] += siz[y];<br>        f[y] = x;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">size</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123; <span class="hljs-keyword">return</span> siz[<span class="hljs-built_in">find</span>(x)]; &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, q;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vi <span class="hljs-title">h</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; h[i];<br>    <span class="hljs-function">vector&lt;pii&gt; <span class="hljs-title">es</span><span class="hljs-params">(m)</span></span>;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 4&gt; &gt; events;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;[u, v] : es) &#123;<br>        cin &gt;&gt; u &gt;&gt; v;<br>        --u; --v;<br>        events.<span class="hljs-built_in">push_back</span>(&#123;<span class="hljs-built_in">max</span>(h[u], h[v]), <span class="hljs-number">-1</span>, u, v&#125;);<br>    &#125;<br>    cin &gt;&gt; q;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        <span class="hljs-type">int</span> u, v, e;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; e;<br>        --u; --v;<br>        events.<span class="hljs-built_in">push_back</span>(&#123;(h[u] + e), i, u, v&#125;);<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(events);<br>    <span class="hljs-function">Dsu <span class="hljs-title">dsu</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(q)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [w, id, u, v] : events) &#123;<br>        <span class="hljs-keyword">if</span> (id &gt;= <span class="hljs-number">0</span> &amp;&amp; id &lt; q) &#123;<br>            ans[id] = dsu.<span class="hljs-built_in">same</span>(u, v);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            dsu.<span class="hljs-built_in">merge</span>(u, v);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;q; i++) &#123;<br>            cout &lt;&lt; (ans[i]?<span class="hljs-string">&quot;YES&quot;</span>:<span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>        &#125;<br>        cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/797/F">Mice and Holes_edu19F</a></p><p>输入 n(1≤n≤5000) 和 m(1≤m≤5000)。<br />然后输入长为 n 的数组 a(-1e9≤a[i]≤1e9)，表示在数轴上有 n 个一样的小球，第 i 个小球的位置是 a[i]。<br />然后输入 m 行，每行两个数 pi(-1e9≤pi≤1e9) 和 ci(1≤ci≤5000)，表示有 m 个洞，第 i 个洞的位置是 pi，能容纳 ci 个小球。</p><p>把所有小球都移入洞中，移动距离之和的最小值是多少？<br />如果无法满足，输出 -1。</p><p>输入<br />4 5<br />6 2 8 9<br />3 6<br />2 1<br />3 6<br />4 7<br />4 7<br />输出 11</p><p>输入<br />7 2<br />10 20 30 40 50 45 35<br />-1000000000 10<br />1000000000 1<br />输出 7000000130</p><p><strong>Sol:</strong></p><p>划分型 DP + 单调队列优化。</p><p>没做过划分型 DP 的可以看看 <a href="https://leetcode.cn/circle/discuss/tXLS3i/">动态规划题单</a></p><p>不了解单调队列的可以看看<a href="https://www.bilibili.com/video/BV1bM411X72E/">【基础算法精讲 27】</a></p><p>首先有如下贪心结论：</p><p>把小球和洞按照位置从小到大排序，那么最左边的若干个小球（可能 0 个）进第一个洞，接下来的若干小球（可能 0 个）进第二个洞，依此类推。</p><p>于是问题变成，把 a 分成若干段，第 i 段的小球（不能超过 ci 个）进第 i 个洞，移动距离之和为  sum(abs(a[j] - pi) for j in 这一段)</p><p>按照划分型 DP 的套路，定义：</p><p>f[i] [j] = a[:j] 进前 i 个洞的距离和</p><p>注意这个定义 j=0 表示没有小球，j=1 表示第一个小球，j=n 表示所有小球。</p><p>考虑最后一个子数组的小球进第 i 个洞的距离和。</p><p>枚举最后一个子数组的左端点 L，从 f[i-1] [L] 转移到 f[i] [j]，考虑 a[L:j] 对最优解的影响，设 abs(a[j]-pi) 的前缀和数组为 s，那么有</p><p>f[i] [j] = min{ f[i-1] [L] + s[j] - s[L] } = min{ f[i-1] [L] - s[L] } + s[j]</p><p>其中 L 属于区间 [j-ci,j]。如果 L=j 表示没有小球移动到第 i 个洞。</p><p>由于上式随着 j 的变大，L 的最小值也在变大，所以是一个滑动窗口最小值问题，可以用单调队列优化。</p><p>单调队列保存 (f[i-1] [j] - s[j], j)，注意额外保存下标。由于计算的是最小值，右边遇到更小的可以把左边更大（或者相等）的弹出，所以是单调队列从左到右是严格递增的，队首就是转移来源的最小值。</p><p>即 f[i] [j] = 队首 + s[j]。 如果队首的下标 &lt; j - ci，那么弹出队首。</p><p>初始值 f[0] [0] = 0, f[0] [j] = inf (j &gt;= 1)。</p><p>最后答案为 f[m] [n]。</p><p>代码实现时，由于队列中保存了 f[i-1] [.] 的信息，所以 f 数组的第一个维度可以去掉。</p><p><strong>Code(学习一下):</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> int long long</span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">int</span> dp[<span class="hljs-number">5005</span>][<span class="hljs-number">5005</span>],a[<span class="hljs-number">5005</span>],b[<span class="hljs-number">5005</span>],c[<span class="hljs-number">5005</span>];<br>pair &lt;<span class="hljs-type">int</span>,<span class="hljs-type">int</span>&gt; d[<span class="hljs-number">5005</span>];<br><span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">D</span><span class="hljs-params">(<span class="hljs-type">int</span> x,<span class="hljs-type">int</span> y)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(x,y)-<span class="hljs-built_in">min</span>(x,y);<br>&#125;<br><span class="hljs-function"><span class="hljs-type">signed</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br><span class="hljs-type">int</span> n,m;<br>cin &gt;&gt; n &gt;&gt; m;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=n;i++)<br>cin &gt;&gt; a[i];<br><span class="hljs-built_in">sort</span>(a+<span class="hljs-number">1</span>,a+n+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>cin &gt;&gt; d[i].first &gt;&gt; d[i].second;<br><span class="hljs-built_in">sort</span>(d+<span class="hljs-number">1</span>,d+m+<span class="hljs-number">1</span>);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++) b[i]=d[i].first,c[i]=d[i].second;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;=m;i++)<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>dp[i][j]=<span class="hljs-number">1e18</span>;<br>dp[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>]=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">1</span>;i&lt;=m;i++)<br>&#123;<br><span class="hljs-type">int</span> w[<span class="hljs-number">5005</span>]=&#123;&#125;,qzh[<span class="hljs-number">5005</span>]=&#123;&#125;;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">1</span>;j&lt;=n;j++)<br>qzh[j]=<span class="hljs-built_in">D</span>(b[i],a[j])+qzh[j<span class="hljs-number">-1</span>];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++) w[j]=dp[i<span class="hljs-number">-1</span>][j]-qzh[j];<br><span class="hljs-type">int</span> q[<span class="hljs-number">5005</span>]=&#123;&#125;,head=<span class="hljs-number">1</span>,tail=<span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j=<span class="hljs-number">0</span>;j&lt;=n;j++)<br>&#123;<br><span class="hljs-keyword">while</span>(head&lt;=tail&amp;&amp;w[q[tail]]&gt;w[j]) --tail;<br><span class="hljs-keyword">while</span>(head&lt;=tail&amp;&amp;q[head]&lt;j-c[i]) ++head;<br>q[++tail]=j;<br>dp[i][j]=qzh[j]+w[q[head]];<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(dp[m][n]&gt;<span class="hljs-number">8e17</span>) dp[m][n]=<span class="hljs-number">-1</span>;<br>cout &lt;&lt; dp[m][n];<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Greedy Algorithm</tag>
      
      <tag>Subsequence</tag>
      
      <tag>Prefix Sum</tag>
      
      <tag>Binary Search</tag>
      
      <tag>Codeforces</tag>
      
      <tag>Sorting</tag>
      
      <tag>Offline Queries</tag>
      
      <tag>Union-Find</tag>
      
      <tag>Monotonic Queue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture6</title>
    <link href="/2024/06/17/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/"/>
    <url>/2024/06/17/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第六课缓冲池"><a class="markdownIt-Anchor" href="#第六课缓冲池"></a> 第六课：缓冲池</h1><h2 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1 介绍</h2><p>DBMS负责管理其内存并在磁盘上来回移动数据。由于在大多数情况下，数据无法直接在磁盘中进行操作，因此任何数据库必须能够有效地将表示为文件的数据从磁盘移动到内存中，以便可以使用。交互的示意图如图一所示。理想情况下，从执行引擎的角度来看，它应该“看起来”好像所有数据都在内存中。它不必担心如何将数据提取到内存中。</p><p><img src="../imgs/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/image-20240617170556181.png" alt="图1" /></p><p>思考这个问题的另一种方式是从空间和时间控制的角度来考虑。</p><p>空间控制是指页面在磁盘上物理写入的位置。空间控制的目标是使经常一起使用的页面在磁盘上尽可能物理地靠近。</p><p>时间控制是指何时将页面读入内存以及何时将其写入磁盘。时间控制旨在最大限度地减少因必须从磁盘读取数据而导致的停顿数量。</p><h2 id="2-locks-vs-latchs"><a class="markdownIt-Anchor" href="#2-locks-vs-latchs"></a> 2 Locks vs. Latchs</h2><p>在讨论DBMS如何保护其内部元素时，我们需要区分locks和latchs</p><p>**Locks：**锁是一种更高级别的逻辑原语，可保护数据库的内容（例如元组、表、数据库）免受其他事务的影响。事务将在其整个持续时间内保持锁定。数据库系统可以向用户公开在运行查询时持有哪些锁。需要能够回滚更改。</p><p>**Latchs：**latch是一种低级保护原语，DBMS用于其内部数据结构（例如哈希表、内存区域）中的关键部分。Latchs仅在执行操作期间被保持。不需要能够回滚更改。</p><h2 id="3-缓冲池"><a class="markdownIt-Anchor" href="#3-缓冲池"></a> 3 缓冲池</h2><p>缓冲池是从磁盘读取的页面的内存缓存。它本质上是在数据库内部分配的一个大内存区域，用于存储从磁盘获取的页面。</p><p>缓冲池的内存区域组织为固定大小页面的数组。每个数组条目称为一个帧。当DBMS请求一页时，会将其从磁盘复制到缓冲池的其中一个帧。当一个页面被请求时，数据库系统能先查找缓冲池。只有这个页面没有找到时，系统才会从磁盘中获取这个页面的一个copy。脏页被缓冲并且不会立即写回。缓冲池的内存组织图见图 2。</p><p><img src="../imgs/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/image-20240617172314457.png" alt="图2" /></p><h3 id="缓冲池元数据"><a class="markdownIt-Anchor" href="#缓冲池元数据"></a> 缓冲池元数据</h3><p>缓冲池必须维护某些元数据才能有效且正确地使用。</p><p>首先，页表是内存中的哈希表，用于跟踪当前内存中的页面。它将页面 ID 映射到缓冲池中的帧位置。由于缓冲池中页面的顺序不一定反映磁盘上的顺序，因此这个额外的间接层允许识别池中的页面位置。</p><p>注意：不要将页表与页目录混淆，页目录是从页 id 到数据库文件中页位置的映射。对页目录的所有更改都必须记录在磁盘上，以便 DBMS 在重新启动时能够找到。</p><p>页表还维护每页的附加元数据、脏标志和引脚/引用计数器。</p><p>每当线程修改页面时，都会设置脏标志。这向存储管理器表明该页必须写回磁盘。</p><p>引脚/引用计数器跟踪当前正在访问该页面（读取或修改它）的线程数。线程在访问页面之前必须增加计数器。如果页面的引脚计数大于零，则不允许存储管理器从内存中逐出该页面。固定不会阻止其他事务同时访问该页面。</p><h2 id="内存分配策略"><a class="markdownIt-Anchor" href="#内存分配策略"></a> 内存分配策略</h2><p>数据库中的内存根据两种策略分配给缓冲池。</p><p>全局策略涉及 DBMS 应该做出的决策，以使正在执行的整个工作负载受益。它考虑所有活动事务以找到分配内存的最佳决策。</p><p>另一种选择是本地策略，它做出的决策将使单个查询或事务运行得更快，即使这对整个工作负载不利。本地策略将帧分配给特定事务，而不考虑并发事务的行为。</p><p>大多数系统结合使用全局视图和局部视图。</p><h2 id="4-缓冲池优化"><a class="markdownIt-Anchor" href="#4-缓冲池优化"></a> 4 缓冲池优化</h2><p>有多种方法可以优化缓冲池以适应应用程序的工作负载。</p><h3 id="多缓冲池"><a class="markdownIt-Anchor" href="#多缓冲池"></a> 多缓冲池</h3><p>DBMS 可以出于不同目的维护多个缓冲池（即每个数据库缓冲池、每个页面类型缓冲池）。然后，每个缓冲池都可以采用针对存储在其中的数据量身定制的本地策略。此方法有助于减少锁存争用并提高局部性。</p><p>将所需页面映射到缓冲池的两种方法是对象 ID 和散列。</p><p>对象 ID 涉及扩展记录 ID 以具有对象标识符。然后通过对象标识符，可以维护从对象到特定缓冲池的映射。</p><p>另一种方法是散列，其中 DBMS 对页面 id 进行散列以选择要访问的缓冲池。</p><h3 id="预获取"><a class="markdownIt-Anchor" href="#预获取"></a> 预获取</h3><p>DBMS 还可以通过基于查询计划预取页面来进行优化。然后，在处理第一组页面时，可以将第二组页面预取到缓冲池中。DBMS 在顺序访问多个页面时通常使用此方法。缓冲池管理器还可以预取树索引数据结构中的叶页。</p><h3 id="扫描共享同步扫描"><a class="markdownIt-Anchor" href="#扫描共享同步扫描"></a> 扫描共享（同步扫描）</h3><p>查询游标可以重用从存储或运算符计算中检索的数据。这允许多个查询附加到扫描表的单个游标。如果一个查询开始扫描并且已经有一个查询在执行此操作，则 DBMS 会将第二个查询的游标附加到现有游标。DBMS 跟踪第二个查询与第一个查询的连接位置，以便在到达数据结构末尾时完成扫描。</p><h3 id="旁路缓冲池"><a class="markdownIt-Anchor" href="#旁路缓冲池"></a> 旁路缓冲池</h3><p>顺序扫描操作符不会将获取的页面存储在缓冲池中以避免开销。相反，内存对于正在运行的查询来说是本地的。如果操作员需要读取磁盘上连续的大量页面，则此方法非常有效。缓冲池旁路还可以用于临时数据（排序、连接）。</p><h2 id="5-缓存替换策略"><a class="markdownIt-Anchor" href="#5-缓存替换策略"></a> 5 缓存替换策略</h2><p>当DBMS需要释放帧以为新页面腾出空间时，它必须决定从缓冲池里移除哪个页面。</p><p>替换策略是 DBMS 实现的一种算法，用于在需要空间时决定从缓冲池中逐出哪些页。</p><p>替换策略的实施目标是提高正确性、准确性、速度和元数据开销。</p><h3 id="最近最少使用lru"><a class="markdownIt-Anchor" href="#最近最少使用lru"></a> 最近最少使用（LRU）</h3><p>最近最少使用的替换策略维护每个页面上次访问时间的时间戳。 DBMS 选择逐出具有最早时间戳的页面。该时间戳可以存储在单独的数据结构中，例如队列，以允许排序并通过减少驱逐时的排序时间来提高效率。</p><h3 id="clock"><a class="markdownIt-Anchor" href="#clock"></a> CLOCK</h3><p>CLOCK 策略是 LRU 的近似，不需要每页单独的时间戳。在CLOCK策略中，每个页面都被赋予一个参考位。当访问页面时，设置为1。</p><p>为了形象化这一点，请使用“时钟指针”将页面组织在循环缓冲区中。扫描时检查页面的位是否设置为 1。如果是，则设置为零，如果否，则将其逐出。通过这种方式，时钟指针可以记住驱逐之间的位置。</p><p><img src="../imgs/%E7%AC%AC%E5%85%AD%E8%AF%BE%EF%BC%9A%E7%BC%93%E5%86%B2%E6%B1%A0/image-20240618143256776.png" alt="图3" /></p><h3 id="备选方案"><a class="markdownIt-Anchor" href="#备选方案"></a> 备选方案</h3><p>LRU 和 CLOCK 替换策略存在许多问题。</p><p>也就是说，LRU 和 CLOCK 容易受到顺序泛洪的影响，其中缓冲池的内容由于顺序扫描而被损坏。由于顺序扫描会快速读取许多页面，因此缓冲池会被填满，并且来自其他查询的页面会被逐出，因为它们将具有较早的时间戳。在这种情况下，最新的时间戳并不能准确反映我们实际想要驱逐的页面。</p><p>针对LRU和CLOCK策略的缺点，存在三种解决方案。</p><p>一种解决方案是 LRU-K，它将最后 K 个引用的历史记录作为时间戳进行跟踪，并计算后续访问之间的间隔。该历史记录用于预测下次访问页面的时间。</p><p>另一个优化是每个查询的本地化。 DBMS 根据每个事务/查询选择要驱逐的页面。这可以最大限度地减少每个查询对缓冲池的污染。</p><p>最后，优先级提示允许事务在查询执行期间根据每个页面的上下文告诉缓冲池页面是否重要。</p><h3 id="脏页"><a class="markdownIt-Anchor" href="#脏页"></a> 脏页</h3><p>有两种方法可以处理含有脏位的页面。最快的选择是删除缓冲池中任何未脏的页面。较慢的方法是将脏页写回磁盘以确保其更改被持久化。</p><p>这两种方法说明了快速驱逐与将来不会再次读取的脏写页面之间的权衡。</p><p>避免不必要地写出页面问题的一种方法是后台写入。通过后台写入，DBMS 可以定期遍历页表并将脏页写入磁盘。当脏页被安全写入时，DBMS 可以逐出该页或只是取消设置脏标志。</p><h2 id="6-其他内存池"><a class="markdownIt-Anchor" href="#6-其他内存池"></a> 6 其他内存池</h2><p>DBMS 需要内存来存储元组和索引以外的内容。这些其他内存池可能并不总是由磁盘支持，具体取决于实现。</p><ul><li>排序+连接缓冲区</li><li>查询缓存</li><li>维护缓冲器</li><li>日志缓冲区</li><li>字典缓存</li></ul><h2 id="7-操作系统页面缓存"><a class="markdownIt-Anchor" href="#7-操作系统页面缓存"></a> 7 操作系统页面缓存</h2><p>大多数磁盘操作都是通过操作系统 API 进行的。除非另有明确说明，否则操作系统维护自己的文件系统缓存。</p><p>大多数 DBMS 使用直接 I/O 来绕过操作系统的缓存，以避免页面的冗余副本以及必须管理不同的逐出策略。</p><p>Postgres 是使用操作系统页面缓存的数据库系统的示例。</p><h2 id="8-磁盘io调度"><a class="markdownIt-Anchor" href="#8-磁盘io调度"></a> 8 磁盘IO调度</h2><p>DBMS 维护内部队列来跟踪来自整个系统的页面读/写请求。任务的优先级是根据以下几个因素确定的：</p><ul><li>顺序IO和随机IO</li><li>关键路径任务与后台任务</li><li>表、索引、日志、临时数据</li><li>事务信息</li><li>基于用户的SLA</li></ul>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Buffer Pool</tag>
      
      <tag>Locks vs. Latches</tag>
      
      <tag>Page Table</tag>
      
      <tag>Global vs. Local Memory Allocation</tag>
      
      <tag>Multi-Buffer Pool</tag>
      
      <tag>Prefetching</tag>
      
      <tag>Scan Sharing</tag>
      
      <tag>Bypassing Buffer Pool</tag>
      
      <tag>Cache Replacement Policies</tag>
      
      <tag>LRU (Least Recently Used)</tag>
      
      <tag>CLOCK Algorithm</tag>
      
      <tag>LRU-K</tag>
      
      <tag>Priority Hints</tag>
      
      <tag>Dirty Pages</tag>
      
      <tag>Background Writing</tag>
      
      <tag>Other Memory Pools</tag>
      
      <tag>Operating System Page Cache</tag>
      
      <tag>Direct I/O</tag>
      
      <tag>Disk I/O Scheduling</tag>
      
      <tag>Sequential vs. Random I/O</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>茶6.17-6.21</title>
    <link href="/2024/06/17/%E8%8C%B66.17-6.21/"/>
    <url>/2024/06/17/%E8%8C%B66.17-6.21/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶617-621"><a class="markdownIt-Anchor" href="#茶617-621"></a> 茶6.17-6.21</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/problemset/problem/1077/C">Good Array_521C</a></p><p>输入 n(2≤n≤2e5) 和长为 n 的数组 a(1≤a[i]≤1e6)。</p><p>对于数组 b，如果 b 中存在一个数 x，使得 x = b 中其余元素之和，则称 b 为「好数组」。</p><p>如果删除 a[i] 可以使剩余元素组成好数组，则称 i 为「好下标」。<br />输出 a 的好下标的个数，以及所有好下标（任意顺序）。注意下标从 1 开始。</p><p>输入<br />5<br />2 5 1 2 2<br />输出<br />3<br />4 1 5</p><p>输入<br />4<br />8 3 5 2<br />输出<br />2<br />1 4</p><p>输入<br />5<br />2 1 2 4 3<br />输出<br />0</p><p><strong>Sol:</strong></p><p>记录最大值，如果删除的不是最大值，检查总和是否是最大值的两倍即可。如果删除的是最大值，则看删除后的总和是否是第二大值的两倍。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ma = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) &#123;<br>        cin &gt;&gt; a[i];<br>        sum += a[i];<br>        ma = <span class="hljs-built_in">max</span>(ma,a[i]);<br>    &#125;<br>    vi b = a;<br>    <span class="hljs-built_in">sort</span>(b);<br>    vi ans;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span>(a[i]!=ma) &#123;<br>            <span class="hljs-keyword">if</span>(ma*<span class="hljs-number">2</span>==(sum-a[i]))&#123;<br>                ans.<span class="hljs-built_in">pb</span>(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(a[i]==ma) &#123;<br>            <span class="hljs-keyword">if</span>(b[n<span class="hljs-number">-2</span>]*<span class="hljs-number">2</span>==(sum-a[i])) &#123;<br>                ans.<span class="hljs-built_in">pb</span>(i+<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans.<span class="hljs-built_in">size</span>() &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:ans) &#123;<br>        cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue"><a class="markdownIt-Anchor" href="#tue"></a> Tue</h2><p><a href="https://codeforces.com/problemset/problem/976/C">Nested Segments_43C</a></p><p>输入 n(1≤n≤3e5) 和 n 个闭区间，区间的左右端点在 [1,1e9] 内。</p><p>从这 n 个区间中，选出两个区间 [L[i], R[i]] 和 [L[j], R[j]]，<br />满足 i ≠ j 且 L[j] &lt;= L[i] &lt;= R[i] &lt;= R[j]，也就是区间 j 包含区间 i。</p><p>输出 i 和 j（按照输入的顺序，下标从 1 开始）。<br />如果不存在这样的区间，输出两个 -1。</p><p>输入<br />5<br />1 10<br />2 9<br />3 9<br />2 3<br />2 9<br />输出<br />2 1</p><p>输入<br />3<br />1 5<br />2 6<br />6 20<br />输出<br />-1 -1</p><p><strong>Sol:</strong></p><p>把区间按照左端点从小到大排序，左端点相同的，按照右端点从大到小排序。</p><p>排序后，遍历区间。 对于区间 i，如果区间 i 被区间 j 包含，那么区间 j 一定是我们之前遍历过的区间（因为左端点从小到大排序了）。</p><p>所以只要区间 j 的右端点 &gt;= 区间 i 的右端点，那么区间 j 就可以包含区间 i。</p><p>那么维护遍历过的区间的右端点的最大值 mxR 即可。</p><p>这也说明为什么左端点相同时，要按照右端点从大到小排序。如果有左端点相同的情况，如此排序可以保证先把 mxR 更新成大的，然后遇到右端点小的，找到答案。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n;<br>    cin &gt;&gt; n;<br>    vector&lt;pair&lt;pii, <span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">a</span>(n);<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) &#123;<br>        cin &gt;&gt; a[i].F.F &gt;&gt; a[i].F.second;<br>        a[i].S = i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), [](<span class="hljs-type">const</span> pair&lt;pii, <span class="hljs-type">int</span>&gt;&amp; x, <span class="hljs-type">const</span> pair&lt;pii, <span class="hljs-type">int</span>&gt;&amp; y) &#123;<br>        <span class="hljs-keyword">return</span> x.F.F &lt; y.F.F || (x.F.F == y.F.F &amp;&amp; x.F.S &gt; y.F.S);<br>    &#125;);<br>    ll mxR = <span class="hljs-number">0</span>, mxI = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : a) &#123;<br>        <span class="hljs-keyword">if</span> (p.F.S &lt;= mxR) &#123;<br>            cout &lt;&lt; p.S + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; mxI + <span class="hljs-number">1</span> &lt;&lt; endl;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (p.F.S &gt; mxR) &#123;<br>            mxR = p.F.S;<br>            mxI = p.S;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; <span class="hljs-string">&quot; &quot;</span> &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1950/F">0, 1, 2, Tree!_937F</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 a+b+c 之和 ≤3e5。<br />每组数据输入 a,b,c (0≤a,b,c≤1e5 且 1≤a+b+c)。</p><p>有一棵二叉树，其中 a 个节点有两个儿子，b 个节点有一个儿子，c 个节点没有儿子。<br />输出这棵二叉树的最小高度。<br />注意这里的高度是根到最远叶节点的路径上的边的个数。<br />特别地，只有一个节点的二叉树的高度为 0。</p><p>进阶：做到 O(1) 时间。</p><p>输入<br />10<br />2 1 3<br />0 0 1<br />0 1 1<br />1 0 2<br />1 1 3<br />3 1 4<br />8 17 9<br />24 36 48<br />1 0 0<br />0 3 1<br />输出<br />2<br />0<br />1<br />1<br />-1<br />3<br />6<br />-1<br />-1<br />3</p><p><strong>Sol:</strong></p><p>把这三种节点（有两个/一个/零个儿子）分别记作 A B C。</p><p>整体思路： 一层一层地放置，先放 A，然后 B，最后 C。</p><p>先判断 -1。 由于 a 个节点 A 会产生 a+1 个「插座」，可以插入恰好 a+1 个节点，所以必须满足 a+1=c。</p><p>B 节点由于插入插座后自己又产生了一个插座，所以无需判断 b。</p><p>对于节点 A 来说，一层一层地放置，可以放 a 的二进制长度层，设其为 h1。 最后一层还留有 k = 2^h1 - 1 - a 个「插座」，可以放一部分节点 B。</p><p>如果 b-k &gt; 0，那么剩下的 b-k 个节点需要 h2 = ceil((b-k)/(a+1)) 层。</p><p>最后一层放节点 C。</p><p>所以树高为 h1 + h2 + 1 - 1 = h1 + h2，减一是因为按照题目规定，高度等于层数减一。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> a,b,c;<br>    cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;<br>    <span class="hljs-keyword">if</span> (a+<span class="hljs-number">1</span> != c) &#123;<br>        cout &lt;&lt; <span class="hljs-number">-1</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> h = a == <span class="hljs-number">0</span>? <span class="hljs-number">0</span> : <span class="hljs-built_in">log2</span>(a) + <span class="hljs-number">1</span>;<br>    b -= (<span class="hljs-number">1</span>&lt;&lt;h) - c;<br>    <span class="hljs-keyword">if</span> (b &gt; <span class="hljs-number">0</span>) &#123;<br>        h += (b<span class="hljs-number">-1</span>)/c + <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; h &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/contest/1926/problem/G">Vlad and Trouble at MIT_928G</a></p><p>输入 T(≤1e3) 表示 T 组数据。所有数据的 n 之和 ≤1e5。<br />每组数据输入 n(2≤n≤1e5) 和 n-1 个数 a2,a3,…,an (1≤ai&lt;i)，表示节点 i 和节点 ai 之间有一条无向边。<br />这 n-1 条无向边形成了一棵树，节点编号从 1 到 n。<br />然后输入长为 n 的字符串 s，只包含字母 P S C，表示节点 i 的类型是 s[i]。</p><p>最少要切断多少条边，使得类型为 P 的节点都无法到达任意类型为 S 的节点？</p><p>输入<br />3<br />3<br />1 1<br />CSP<br />4<br />1 2 2<br />PCSS<br />4<br />1 2 2<br />PPSS<br />输出<br />1<br />1<br />2</p><p><strong>Sol：</strong></p><p>首先简单分析一下性质：</p><p>如果树上至少有一个非 C 节点，那么对于类型为 C 的节点，它要么和 S 连通，要么和 P 连通（不能都连通）。</p><p>对于其他类型的节点也是一样的，S 只能和 S 连通，不能和 P 连通；P 只能和 P 连通，不能和 S 连通。</p><p>定义 f[x] [0] 表示节点 x 和 S 连通（相当于和 P 不连通）最少需要切断的边。如果 s[x]=P，则 f[x] [0] = inf。</p><p>定义 f[x] [1] 表示节点 x 和 P 连通（相当于和 S 不连通）最少需要切断的边。如果 s[x]=S，则 f[x] [1] = inf。</p><p>假设 1 是树的根。从 1 开始 DFS，跑一个树形 DP。</p><p>遍历 x 的儿子 y，如果 x 要和 S 连通，那么分类讨论：</p><p>如果 y 也和 S 连通，则 f[x] [0] += f[y] [0]。</p><p>如果 y 和 P 连通，则 f[x] [0] += f[y] [1] + 1，因为需要断开 x 和 y 之间的边。</p><p>二者取最小值，得</p><p>f[x] [0] += min(f[y] [0], f[y] [1] + 1)。</p><p>同理得</p><p>f[x] [1] += min(f[y] [1], f[y] [0] + 1)。</p><p>代码实现时，无需建树，直接从 i=n 开始倒着遍历，转移到其父节点 a[i] 上。</p><p>答案为 min(f[1] [0], f[1] [1])。</p><p>如果假设 1 的父节点是 0，答案也可以是 min(f[0] [0], f[0] [1])。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    string s;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i &lt;= n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>    &#125;<br>    cin &gt;&gt; s;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">f</span>(n+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(<span class="hljs-number">2</span>));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; g = f[i];<br>        <span class="hljs-keyword">if</span> (s[i<span class="hljs-number">-1</span>] != <span class="hljs-string">&#x27;C&#x27;</span>) &#123;<br>            g[s[i<span class="hljs-number">-1</span>]&amp;<span class="hljs-number">1</span>] = <span class="hljs-number">1e9</span>;<br>        &#125;<br>        f[a[i]][<span class="hljs-number">0</span>] += <span class="hljs-built_in">min</span>(g[<span class="hljs-number">0</span>],g[<span class="hljs-number">1</span>]+<span class="hljs-number">1</span>);<br>        f[a[i]][<span class="hljs-number">1</span>] += <span class="hljs-built_in">min</span>(g[<span class="hljs-number">0</span>]+<span class="hljs-number">1</span>,g[<span class="hljs-number">1</span>]);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-built_in">min</span>(f[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], f[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/1400/G">Mercenaries_94G</a></p><p>输入 n(1≤n≤3e5) 和 m(0≤m≤min(20,n*(n-1)/2))。<br />解释：有 n 个雇佣兵，从中选择一些人（至少一个人），组成一支部队。m 的含义见下。</p><p>然后输入 n 个闭区间的左右端点 [Li,Ri]，范围 [1,n]。<br />解释：如果选了第 i 位雇佣兵，那么部队的大小必须在闭区间 [Li,Ri] 中。</p><p>最后输入 m 对数字 (ai, bi)，满足 1≤ai&lt;bi≤n。<br />解释：这 m 对雇佣兵相互憎恨，如果选了第 ai 位雇佣兵，那么不能选第 bi 位雇佣兵，反之亦然。</p><p>输出有多少种选法，模 998244353。</p><p>输入<br />3 0<br />1 1<br />2 3<br />1 3<br />输出 3</p><p>输入<br />3 1<br />1 1<br />2 3<br />1 3<br />2 3<br />输出 2</p><p><strong>Sol:</strong></p><p>如果 m=0，要怎么做？</p><p>枚举部队人数 i=1,2,…,n，对于固定的 i，有多少种选法？</p><p>我们需要知道有多少个闭区间包含 i。</p><p>对于每个区间 [L,R]，把 [L,R] 内的数都加一。这可以用差分数组解决。</p><p>计算差分数组的前缀和，得到 cnt 数组，也就是有 cnt[i] 个区间包含 i，那么选法就是 C(cnt[i],i)。</p><p>所以 m=0 的时候，一共有</p><p>∑C(cnt[i],i)</p><p>种选法，其中 i=1,2,…,n。</p><p>回到原问题。</p><p>考虑容斥。</p><p>从不考虑 m 对约束的方案数中，减去不合法的方案数（选了 m 对约束中的）。</p><p>这可以用子集容斥计算。</p><p>枚举 m 对约束的子集，假设子集中有 j 个人，相当于这 j 个人一定要选，那么选法就是</p><p>∑C(cnt[i]-j,i-j)</p><p>其中 i=p,p+1,…,q，其中 p 和 q 是这 j 个人对应区间的交集的左右端点。</p><p>如何高效地计算上述和式？</p><p>由于 m 至多 20，所以 j 至多 40。</p><p>对 0~40 这 41 个不同的 j，计算 C(cnt[i]-j,i-j) 的前缀和。</p><p>组合数可以通过预处理阶乘及其逆元快速计算。</p><p>记得取模：组合数取模，前缀和取模，最后返回的答案要保证是非负数（因为容斥里面有负数）。</p><p><strong>Code(抄自jls）:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">constexpr</span> <span class="hljs-type">int</span> P = <span class="hljs-number">998244353</span>;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">power</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b)</span> </span>&#123;<br>    <span class="hljs-type">int</span> res = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (; b; b &gt;&gt;= <span class="hljs-number">1</span>, a = <span class="hljs-number">1ll</span> * a * a % P)<br>        <span class="hljs-keyword">if</span> (b &amp; <span class="hljs-number">1</span>)<br>            res = <span class="hljs-number">1ll</span> * res * a % P;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>    std::cin.<span class="hljs-built_in">tie</span>(<span class="hljs-literal">nullptr</span>);<br>    <span class="hljs-type">int</span> n, m;<br>    std::cin &gt;&gt; n &gt;&gt; m;<br>    std::vector&lt;std::vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">add</span>(n + <span class="hljs-number">1</span>), <span class="hljs-built_in">del</span>(n + <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        <span class="hljs-type">int</span> l, r;<br>        std::cin &gt;&gt; l &gt;&gt; r;<br>        add[l].<span class="hljs-built_in">push_back</span>(i);<br>        del[r].<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(m)</span>, <span class="hljs-title">b</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">id</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-type">int</span> cnt = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>        std::cin &gt;&gt; a[i] &gt;&gt; b[i];<br>        --a[i];<br>        --b[i];<br>        <span class="hljs-keyword">if</span> (id[a[i]] == <span class="hljs-number">-1</span>)<br>            id[a[i]] = cnt++;<br>        <span class="hljs-keyword">if</span> (id[b[i]] == <span class="hljs-number">-1</span>)<br>            id[b[i]] = cnt++;<br>    &#125;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">fac</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">invFac</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    fac[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>        fac[i] = <span class="hljs-number">1ll</span> * fac[i - <span class="hljs-number">1</span>] * i % P;<br>    invFac[n] = <span class="hljs-built_in">power</span>(fac[n], P - <span class="hljs-number">2</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i; --i)<br>        invFac[i - <span class="hljs-number">1</span>] = <span class="hljs-number">1ll</span> * invFac[i] * i % P;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ways</span><span class="hljs-params">(m + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">in</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-type">int64_t</span> mask = <span class="hljs-number">0</span>;<br>    ways[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> tot = <span class="hljs-number">0</span>, tp = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> C = [&amp;](<span class="hljs-type">int</span> n, <span class="hljs-type">int</span> m) &#123;<br>        <span class="hljs-keyword">if</span> (n &lt; m || m &lt; <span class="hljs-number">0</span>)<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">return</span> (<span class="hljs-type">int</span>)(<span class="hljs-number">1ll</span> * fac[n] * invFac[m] % P * invFac[n - m] % P);<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : add[i]) &#123;<br>            in[x] = <span class="hljs-number">1</span>;<br>            ++(id[x] == <span class="hljs-number">-1</span> ? tot : tp);<br>        &#125;<br>        <span class="hljs-type">int64_t</span> nMask = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (in[a[j]])<br>                nMask |= <span class="hljs-number">1ll</span> &lt;&lt; id[a[j]];<br>            <span class="hljs-keyword">if</span> (in[b[j]])<br>                nMask |= <span class="hljs-number">1ll</span> &lt;&lt; id[b[j]];<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nMask != mask) &#123;<br>            mask = nMask;<br>            std::<span class="hljs-built_in">fill</span>(ways.<span class="hljs-built_in">begin</span>(), ways.<span class="hljs-built_in">end</span>(), <span class="hljs-number">0</span>);<br>            std::function&lt;<span class="hljs-type">void</span>(<span class="hljs-type">int</span>, <span class="hljs-type">int64_t</span>, <span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> x, <span class="hljs-type">int64_t</span> s, <span class="hljs-type">int</span> coef) &#123;<br>                <span class="hljs-keyword">if</span> (x == m) &#123;<br>                    <span class="hljs-type">int</span> p = __builtin_popcountll(s);<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; ++j)<br>                        ways[j] = (ways[j] + <span class="hljs-number">1ll</span> * coef * <span class="hljs-built_in">C</span>(tp - p, j - p)) % P;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (in[a[x]] &amp;&amp; in[b[x]])<br>                    <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, s | <span class="hljs-number">1ll</span> &lt;&lt; id[a[x]] | <span class="hljs-number">1ll</span> &lt;&lt; id[b[x]], P - coef);<br>                <span class="hljs-built_in">dfs</span>(x + <span class="hljs-number">1</span>, s, coef);<br>            &#125;;<br>            <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>);<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt;= m; ++j)<br>            ans = (ans + <span class="hljs-number">1ll</span> * ways[j] * <span class="hljs-built_in">C</span>(tot, i - j)) % P;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> x : del[i]) &#123;<br>            in[x] = <span class="hljs-number">0</span>;<br>            --(id[x] == <span class="hljs-number">-1</span> ? tot : tp);<br>        &#125;<br>    &#125;<br>    std::cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>dfs</tag>
      
      <tag>dp</tag>
      
      <tag>prefix sum</tag>
      
      <tag>sorting</tag>
      
      <tag>Tree dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture5</title>
    <link href="/2024/06/11/%E7%AC%AC%E4%BA%94%E8%AF%BE%EF%BC%9A%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9/"/>
    <url>/2024/06/11/%E7%AC%AC%E4%BA%94%E8%AF%BE%EF%BC%9A%E5%AD%98%E5%82%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%8E%8B%E7%BC%A9/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第五课存储模型和压缩"><a class="markdownIt-Anchor" href="#第五课存储模型和压缩"></a> 第五课：存储模型和压缩</h1><h2 id="1-数据库工作负载"><a class="markdownIt-Anchor" href="#1-数据库工作负载"></a> 1 数据库工作负载</h2><p><strong>OLTP：在线事务处理</strong></p><p>OLTP工作负载特点是快速的、时长短的操作，重复的操作和对单个实体进行的简单查询。OLTP工作负载通常处理的写入操作多于读取操作，而且每次只读取/更新少量数据。一个例子是亚马逊的网店。用户可以向购物车中添加物品并购买，但这些操作只影响他们自己的账户。</p><p><strong>OLAP：在线分析处理</strong></p><p>OLAP工作负载特点是长时间运行的复杂查询和对数据库大部分数据的读取。在OLAP工作负载中，数据库通常通过分析和从OLTP端收集的我现有数据派生新数据。一个例子是亚马逊计算在匹兹堡在下雨的某一天最畅销的商品。</p><p><strong>HTAP：混合事务+分析处理</strong></p><p>一个新型的工作负载（最近变得流行）是HTAP，即OLTP工作负载和OLAP工作负载同时存在于同一个数据库中。</p><h2 id="2-存储模型"><a class="markdownIt-Anchor" href="#2-存储模型"></a> 2 存储模型</h2><p>存储元组的方式有很多种。到目前为止，我们已经假设了n元存储模型。</p><h3 id="n元存储模型nsm"><a class="markdownIt-Anchor" href="#n元存储模型nsm"></a> <strong>N元存储模型（NSM）</strong></h3><p>在n元存储模型中，数据库管理系统将单个元组的所有属性连续存储在单个页面中。这种方法非常适合OLTP工作负载，其中请求以插入为主，事务往往只操作单个实体。之所以理想，是因为只需要一次操作就可以获取单个元组的所有属性。</p><p>优点：</p><ul><li>快速插入、更新和删除。</li><li>适用于需要整个元组的查询。</li></ul><p>缺点：</p><ul><li>对于扫描表的大部分或属性子集来说效率低下。</li></ul><h3 id="分解存储模型dsm"><a class="markdownIt-Anchor" href="#分解存储模型dsm"></a> <strong>分解存储模型（DSM）</strong></h3><p>在分解存储模型中，数据库管理系统（DBMS）将所有元组的单个属性（列）连续地存储在一块数据块中。因此，它也被称为“列存储”。这个模型非常适用于具有许多只读查询以及在表的某个属性子集上执行大型扫描的OLAP工作负载。</p><p>优点：</p><ul><li>减少了IO浪费的数量，因为DBMS只读取查询所需的数据。</li><li>由于增加了局部性和缓存数据重用，查询处理更好。</li><li>数据压缩更好。</li></ul><p>缺点：</p><ul><li>对于点查询、插入、更新和删除较慢，因为需要进行元组分割/拼接。</li></ul><p>使用列存储时，将元组重新组合有两种常见的方法：最常用的方法是固定长度的偏移量。在这种方法中，给定列中的值将属于与同一偏移量处的另一个列中的值相同的元组。因此，列中的每个值都必须具有相同的长度。</p><p>较少使用的方法是使用嵌入式元组id。在这种方法中，对于列中的每个属性，DBMS都会存储一个元组Id（例如主键）。然后，系统还将存储一个映射来告诉它如何跳转到具有该id的每个属性。需要注意的是，这种方法需要为每个属性条目存储一个元组id，因此存储开销较大。</p><h3 id="混合分区特性pax"><a class="markdownIt-Anchor" href="#混合分区特性pax"></a> <strong>混合分区特性（PAX）</strong></h3><p>在混合分区特性（PAX）存储模型中，数据库管理系统在数据库页面中进行垂直分区特性。这样做的目的是在保留行存储的空间局部性优势的同时，获得列存储更快处理的好处。</p><p>在PAX中，行被水平分为一组组行。在每个行组中，属性被垂直分为列。每个行组类似于其子集行的列存储。</p><p>PAX文件具有包含指向文件行组偏移量的目录的全局头，每个行组维护其自己的标题，其中包含有关其内容的元数据。</p><h2 id="3-数据库压缩"><a class="markdownIt-Anchor" href="#3-数据库压缩"></a> 3 数据库压缩</h2><p>压缩在基于磁盘的数据库管理系统中被广泛使用，因为磁盘I/O（几乎总是）是主要的瓶颈。在只读分析工作负载的系统中特别受欢迎。如果数据库管理系统能够在压缩和解压缩的计算开销较大的情况下事先压缩有用的元组，它可以获取更多的有用元组。</p><p>内存数据库管理系统更加复杂，因为它们不需要从磁盘中获取数据来执行查询。内存比硬盘快得多，但压缩数据库减少了DRAM需求和处理需求。它们必须在速度与压缩比之间达到平衡。压缩数据库减少DRAM需求。它可能会降低查询执行期间的CPU成本。</p><p>如果数据集完全是随机位，就无法进行压缩。然而，真实世界数据集具有适合压缩的关键属性。</p><ul><li>属性值的高度偏斜分布（例如，布朗语料库的齐普夫分布）</li><li>同一元组的属性之间具有很高的相关性（例如，邮编与城市，订购日期与发货日期之间的关系）。</li></ul><p>鉴于此，我们希望数据库压缩方案具备以下特性：</p><ul><li>必须产生固定长度的值。唯一的例外是存储在独立池中的可变长度数据。这是因为DBMS应该遵循字节对齐，并能够使用偏移量访问数据。</li><li>允许DBMS在查询执行过程中尽可能地推迟解压缩（延迟物质化）。</li><li>必须是无损的方案，因为人们不喜欢丢失数据。任何种类的有损压缩必须在应用层执行。</li></ul><p><strong>压缩粒度</strong></p><p>我们想要压缩的数据类型极大地影响了可以使用的压缩方案。有四个压缩粒度级别：</p><ul><li>块级别：压缩同一表中的一组元组。</li><li>元组级别：压缩整个元组的内容（仅适用于NSM）。</li><li>属性级别：压缩元组中的单个属性值。可以针对同一元组的多个属性进行压缩。</li><li>列级别：压缩为多个元组存储的一个或多个属性的多个值（仅适用于DSM）。这样可以使用更复杂的压缩方案。</li></ul><h2 id="4-朴素压缩"><a class="markdownIt-Anchor" href="#4-朴素压缩"></a> 4 朴素压缩</h2><p>DBMS将数据使用一种通用算法进行压缩（例如gzip、LZO、LZ4、Snappy、Brotli、Oracle OZIP、Zstd）。虽然DBMS可以使用多种压缩算法，但工程师通常选择那些在提供更快的压缩/解压缩速度的同时提供较低的压缩比的算法。</p><p>MySQL InnoDB中使用了一种基本的压缩方法。DBMS压缩磁盘页面，将它们添加到2KB的幂的大小并存储到缓冲池中。然而，每次DBMS尝试读取/修改数据时，缓冲池中的压缩数据必须首先解压缩。</p><p>由于访问数据需要解压缩压缩数据，这限制了压缩方案的范围。如果目标是将整个表压缩成一个巨大的块，则使用基本的压缩方案将是不可能的，因为每次访问都需要压缩/解压缩整个表。因此，MySQL将表分成较小的块，因为压缩范围受到限制。</p><p>另一个问题是这些基本方案也没有考虑数据的高级含义或语义。该算法对数据的结构和查询计划访问数据的方式都是无视的。因此，这也消除了使用延迟实例化的机会，因为DBMS无法判断何时可以延迟解压缩数据。</p><h2 id="5-柱状压缩"><a class="markdownIt-Anchor" href="#5-柱状压缩"></a> 5 柱状压缩</h2><p><strong>游程编码(RLE)</strong></p><p>它将同一列中连续的相同数值转换为三元组：</p><ul><li>属性的值</li><li>列段中的起始位置</li><li>运行中的元素数量</li></ul><p>DBMS应该事先智能地对列进行排序，以最大限度地压缩机会。这样可以聚集重复属性，从而增加压缩比率。需要注意的是，RLE的有效性在很大程度上取决于底层数据的特性（例如每个数据中属性的数量和频率）。</p><p><strong>位压缩编码</strong></p><p>当属性的所有值都小于该值声明的最大尺寸时，可以用较少的位数存储它们。</p><p><strong>大多数编码</strong></p><p>使用特殊标记来指示值是否超过了最大尺寸的位压缩变种，并维护查找表来存储它们。</p><p><strong>位图编码</strong></p><p>DBMS (数据库管理系统) 为每个特定属性值存储一个单独的位图，其中向量中的偏移量对应元组位置。位图中的第i个位置对应于表中的第i个元组，指示该值是否存在。为了避免分配大块的连续内存，位图通常被分割成分块。</p><p>这种方法只适用于值的基数较低的情况，因为位图的大小与属性值的基数成线性比例。如果值的基数很高，则位图可能比原始数据集更大。</p><p><strong>增量编码</strong></p><p>不存储精确值，而是记录相邻列中后续值之间的差异。基础值可以内联存储或存储在单独的查找表中。我们还可以对存储的增量使用RLE（游程长度编码）以获得更好的压缩比。</p><p><strong>递增式编码</strong></p><p>这是一种增量编码的类型，常见的前缀或后缀以及其长度被记录下来，以避免重复。这种方法在有序数据中效果最好。</p><p><strong>字典压缩</strong></p><p>字典压缩是最常见的数据库压缩方案。数据库管理系统（DBMS）通过使用较小的代码替换值中的频繁模式来进行压缩。然后，它仅存储这些代码和一个数据结构（即字典），将这些代码映射到它们的原始值上。字典压缩方案需要支持快速的编码/解码和范围查询。</p><p>编码和解码：字典需要决定如何对数据进行编码（将未压缩的值转换为其压缩形式）和解码（将压缩的值转换回其原始形式）。因此，无法使用哈希函数。</p><p>编码值还需要支持与原始值相同的排序顺序（即保序编码）。这确保在压缩数据上运行的压缩查询返回与在原始数据上运行的未压缩查询一致的结果。这种保序属性允许直接对代码执行操作。</p><p>**注意：**列压缩方案最适用于读取密集型工作负载，并可能需要额外的支持来处理写入操作。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OLTP</tag>
      
      <tag>OLAP</tag>
      
      <tag>Storage Models</tag>
      
      <tag>Database Compression</tag>
      
      <tag>Columnar Compression</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture4</title>
    <link href="/2024/06/11/%E7%AC%AC%E5%9B%9B%E8%AF%BE%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%EF%BC%88Part%202%EF%BC%89/"/>
    <url>/2024/06/11/%E7%AC%AC%E5%9B%9B%E8%AF%BE%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%EF%BC%88Part%202%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第四课数据库存储第二部分"><a class="markdownIt-Anchor" href="#第四课数据库存储第二部分"></a> 第四课：数据库存储（第二部分）</h1><h2 id="1-日志结构存储"><a class="markdownIt-Anchor" href="#1-日志结构存储"></a> 1 日志结构存储</h2><p>一些与插槽页设计相关的问题有：</p><ul><li>碎片化：删除元组可能会在页面上留下空隙，使其无法完全利用。</li><li>无用的磁盘IO：由于非易失性存储的块定向性特性，更新一个元组需要获取整个块。</li><li>随机磁盘 I/O：磁盘读取器可能要跳到 20 个不同的位置来更新 20 个不同的元组，这可能非常慢。</li></ul><p>如果我们在一个只允许创建新页面而不允许覆写的系统上工作，那该怎么办呢？日志结构存储模型基于这个假设，并解决了上述一些问题。</p><p>**日志结构存储：**DBMS不是存储元组，而是仅存储元组的更改日志记录。DBMS将新的日志条目追加到内存缓冲区中，而不检查之前的记录，然后按顺序将更改写入磁盘。</p><ul><li>记录包含了元组的唯一标识符、操作类型（PUT/DELETE）以及对于PUT操作来说，元组的内容。</li><li>要读取一条记录，DBMS会逆向扫描日志文件，从最新的到最旧的，以找到元组的最新内容。</li><li>快速写入，潜在的读取缓慢。磁盘写入是顺序进行的，并且现有页面是不可变的，这减少了随机磁盘输入/输出。适用于只追加存储。</li><li>为了避免读取时间过长，数据库管理系统可以通过索引（用于簿记）来让它能够跳转到日志中的特定位置。</li><li>日志最终会变得很大。数据库管理系统可以定期压缩日志，仅保留跨多个页面的每个元组的最新更改。</li><li>在压缩之后，不再需要排序，因为每个元组只有一个，所以数据库管理系统可以按照ID进行排序以进行更快的查找。这被称为排序字符串表（Sorted String Tables，SSTables）。</li><li>在通用整理中，任何日志文件都可以一起整理。在层级整理中，最小的文件是 level 0。Level 0 文件可以整理成更大的 level 1 文件，level 1 文件可以整理成 level 2 文件，依此类推。</li><li>缺点是压缩成本昂贵，同时也会导致写放大（对于每个逻辑写入，可能存在多次物理写入）。</li></ul><h2 id="2-索引组织存储"><a class="markdownIt-Anchor" href="#2-索引组织存储"></a> 2 索引组织存储</h2><p>注意，无论是面向页面的存储还是日志结构化存储，都依赖额外的索引来查找单个元组，因为表本身是无序的。在索引组织存储方案中，数据库管理系统直接将表的元组作为索引数据结构的值进行存储。数据库管理系统会使用类似分槽页面的页面布局，并且通常按照键值将元组在页面上进行排序。</p><h2 id="3-数据表示"><a class="markdownIt-Anchor" href="#3-数据表示"></a> 3 数据表示</h2><p>元组中的数据本质上只是字节数组，并且不会跟踪属性的种类。这是由DBMS负责指导如何跟踪并解释这些字节。数据表示方案是DBMS用于存储值的字节的方式。</p><p>DBMSs希望确保元组是字对齐的，这样CPU就可以在访问时不会出现任何意外的行为或额外的工作。通常采用两种方法：</p><ul><li>填充：在属性后添加空位以确保元组对齐字边界。</li><li>重新排序：交换物理布局中属性的顺序，以确保它们对齐。</li></ul><p>元组中可以存储五种高级数据类型：整数、可变精度数、固定小数点精度数、可变长度值以及日期/时间。</p><h3 id="整数"><a class="markdownIt-Anchor" href="#整数"></a> 整数</h3><p>大多数数据库管理系统（DBMS）使用IEEE-754标准规定的&quot;C/C++&quot;的&quot;本地&quot;数据类型来存储整数。这些值是固定长度的。</p><p>例如：INTEGER，BIGINT，SMALLINT，TINYINT。</p><h3 id="可变精度数"><a class="markdownIt-Anchor" href="#可变精度数"></a> 可变精度数</h3><p>这些是不精确和可变精度的数值类型，使用IEEE-754标准规定的“本地”C/C++类型。这些值也是固定长度的。</p><p>与任意精度的数字相比，变精度数字的运算速度更快，因为CPU可以直接在其上执行指令。然而，在进行计算时可能会产生舍入误差，因为某些数字无法精确表示。</p><p>例如：FLOAT，REAL。</p><h3 id="固定小数点精度数"><a class="markdownIt-Anchor" href="#固定小数点精度数"></a> 固定小数点精度数</h3><p>这些是具有任意精度和小数位的数字数据类型。它们通常以精确、可变长度的二进制表示形式存储（几乎像字符串一样），并附带额外的元数据，告诉系统数据的长度和小数点位置等信息。</p><p>当舍入误差是不可接受的时候，使用这些数据类型，但数据库管理系统会因为追求精确性而付出性能的代价。</p><p>例子：NUMERIC，DECIMAL。</p><h3 id="可变长度值"><a class="markdownIt-Anchor" href="#可变长度值"></a> 可变长度值</h3><p>这些代表了任意长度的数据类型。它们通常以一个头部存储，以跟踪字符串的长度，以便轻松跳转到下一个值。它还可能包含数据的校验和。</p><p>大多数数据库管理系统不允许元组的大小超过一个页面的大小。那些允许的系统会将数据存储在特殊的“溢出”页面上，并使元组包含对该页面的引用。这些溢出页面可以包含对其他溢出页面的指针，直到所有数据都可以存储。</p><p>一些系统可以让您将这些大值存储在外部文件中，然后元组将包含对该文件的指针。例如：如果数据库存储图片信息，DBMS可以在外部文件中存储这些照片而不是占用大量的数据库空间。这个的一个不足之处是数据库管理系统无法操作这个文件的内容。因此，它没有持久性或事务保护。</p><p>例如：VARCHAR、VARBINARY、TEXT、BLOB。</p><h3 id="日期和时间"><a class="markdownIt-Anchor" href="#日期和时间"></a> 日期和时间</h3><p>日期/时间的表示方式因不同系统而异。通常，它们被表示为自Unix纪元以来的某个时间单位（微/毫）秒。</p><p>示例：TIME、DATE、TIMESTAMP。</p><h3 id="空数据类型"><a class="markdownIt-Anchor" href="#空数据类型"></a> 空数据类型</h3><p>在数据库管理系统中，有三种常见的方法来表示空值。</p><ul><li>**空列位图头：**在一个集中的头部中存储一个位图，指定哪些属性是空值。这是最常见的方法。</li><li>**特殊值：**为数据类型指定一个值来表示空值（例如，INT32的最小值）。</li><li>**每个属性的空标志：**存储一个标志，标记一个值是否为空。这种方法不推荐使用，因为它不是存储效率高。对于每个值，数据库管理系统必须使用多个位来避免破坏字对齐。</li></ul><h2 id="4-系统目录"><a class="markdownIt-Anchor" href="#4-系统目录"></a> 4 系统目录</h2><p>为了使DBMS能够解读元组的内容，它维护一个内部目录来告诉它有关数据库的元数据。</p><p>元数据内容：</p><ul><li>数据库所拥有的表和列，以及这些表上的索引</li><li>数据库的用户及其权限</li><li>表的统计信息以及其中包含的内容（例如，属性的最大值）。</li></ul><p>大多数数据库管理系统（DBMS）将其目录存储在其表格所使用的格式内部。它们使用特定的代码来&quot;引导&quot;这些目录表。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Log-Structured Storage</tag>
      
      <tag>Index-Organized Storage</tag>
      
      <tag>Data Representation</tag>
      
      <tag>System Catalog</tag>
      
      <tag>Write Amplification</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>茶6.10-6.14</title>
    <link href="/2024/06/11/%E8%8C%B66.10-6.14/"/>
    <url>/2024/06/11/%E8%8C%B66.10-6.14/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶610-614"><a class="markdownIt-Anchor" href="#茶610-614"></a> 茶6.10-6.14</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/problemset/problem/1364/B">Most socially-distanced subsequence_649B</a></p><p>输入 T(≤2e4) 表示 T 组数据。所有数据的 n 之和 ≤1e5。<br />每组数据输入 n(2≤n≤1e5) 和一个 1~n 的排列 p。</p><p>选一个 p 的长度至少为 2 的子序列 b，最大化 b 的所有相邻元素的绝对差的和。<br />即 S=|b1-b2|+|b2-b3|+…<br />在 S 最大的前提下，b 的长度尽量小。<br />输出任意一个符合要求的 b。</p><p>注：子序列不一定连续。</p><p>输入<br />2<br />3<br />3 2 1<br />4<br />1 3 4 2<br />输出<br />2<br />3 1<br />3<br />1 4 2</p><p><strong>Sol：</strong></p><p>上升段和下降段只需要考虑首尾元素，例如 p=[1,3,5,4,2] 选 b=[1,5,2]。</p><p>选上升段/下降段中间的元素，不会影响 S，所以不选。</p><p>结论：选择所有的峰顶峰谷，以及第一个数和最后一个数。</p><p>注：在本题的约束下，其实 b 是唯一的。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n - <span class="hljs-number">1</span>) cin &gt;&gt; a[i];   <br>    vi ans;<br>    ans.<span class="hljs-built_in">push_back</span>(a[<span class="hljs-number">0</span>]);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        <span class="hljs-keyword">if</span> (a[i - <span class="hljs-number">1</span>] &lt; a[i] == (a[i] &gt; a[i + <span class="hljs-number">1</span>])) &#123;<br>            ans.<span class="hljs-built_in">push_back</span>(a[i]);<br>        &#125;<br>    &#125;<br>    ans.<span class="hljs-built_in">push_back</span>(a[n - <span class="hljs-number">1</span>]);<br>    cout&lt;&lt;ans.<span class="hljs-built_in">size</span>();<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-built_in">print</span>(ans);<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue"><a class="markdownIt-Anchor" href="#tue"></a> Tue</h2><p><a href="https://codeforces.com/problemset/problem/1362/C">https://codeforces.com/problemset/problem/1362/C</a></p><p>输入 T(≤1e4) 表示 T 组数据。<br />每组数据输入 n(1≤n≤1e18)。</p><p>定义 popcount(x) 为 x 二进制中的 1 的个数。<br />输出 popcount(0^1) + popcount(1^2) + popcount(2^3) + … + popcount((n-1)^n)。<br />其中 ^ 表示异或。</p><p>输入<br />5<br />5<br />7<br />11<br />1<br />2000000000000<br />输出<br />8<br />11<br />19<br />1<br />3999999999987</p><p><strong>Sol：</strong></p><p>考虑每一位的贡献。</p><p>由于任意相邻数字的奇偶性不同，所以 i 和 i-1 的二进制最低位不同，这贡献了 n 个 1。</p><p>当且仅当 i 是偶数时，i 和 i-1 的二进制次低位不同，这贡献了 floor(n/2) 个 1。</p><p>当且仅当 i 是 4 的倍数（二进制末尾是 00）时，i 和 i-1 的二进制从低到高第三位不同，这贡献了 floor(n/4) 个 1。</p><p>依此类推。 所以答案为 n + floor(n/2) + floor(n/4) + …  考虑到下取整舍去的数字，这也等于 2n - popcount(n)。</p><p>灵神：<a href="https://codeforces.com/contest/1362/submission/265130910">写法一</a>  <a href="https://codeforces.com/problemset/submission/1362/265142699">写法二</a></p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">//重点是思路</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n;<br>    cin &gt;&gt; n;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>(n) &#123;<br>        ans += n;<br>        n /= <span class="hljs-number">2</span>;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1879/D">Sum of XOR Functions_155D</a></p><p>输入 n(1≤n≤3e5) 和长为 n 的数组 a(0≤a[i]≤1e9)。</p><p>定义 f(L,R) 为连续子数组 a[L] 到 a[R] 的异或和。</p><p>计算所有 f(L,R)*(R-L+1) 的和，其中 L &lt;= R。</p><p>输出答案模 998244353 的结果。</p><p><strong>样例：</strong></p><p>输入 3 1 3 2</p><p>输出 12</p><p>输入 4 39 68 31 80</p><p>输出 1337</p><p>输入 7 313539461 779847196 221612534 488613315 633203958 394620685 761188160</p><p>输出 257421502</p><p><strong>Sol:</strong></p><p>让我们分别解决每个位的问题。</p><p>当我们固定一个比特（记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> ）时，我们要做的就是求解二进制字符串（记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi></mrow><annotation encoding="application/x-tex">s</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">s</span></span></span></span> ）的原始问题。需要注意的是，如果某段上有奇数个 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，则该段上的 XOR 值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，否则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>0</mn></mrow><annotation encoding="application/x-tex">0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 。因此，对于固定位 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> ，我们必须计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>n</mi></msubsup><msubsup><mo>∑</mo><mrow><mi>r</mi><mo>=</mo><mi>l</mi></mrow><mi>n</mi></msubsup><mi>g</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{l=1}^{n} \sum_{r=l}^{n} g(l, r) \cdot (r - l + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mrel mtight">=</span><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> ，其中如果子串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>s</mi><mi>l</mi></msub><mo separator="true">,</mo><msub><mi>s</mi><mrow><mi>l</mi><mo>+</mo><mn>1</mn></mrow></msub><mo separator="true">,</mo><mo>…</mo><mo separator="true">,</mo><msub><mi>s</mi><mi>r</mi></msub></mrow><annotation encoding="application/x-tex">s_l, s_{l + 1}, \dots, s_r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.638891em;vertical-align:-0.208331em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mbin mtight">+</span><span class="mord mtight">1</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.208331em;"><span></span></span></span></span></span></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner">…</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">s</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.151392em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 中字符 1 的个数是奇数，则计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">g(l, r) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ，否则计算 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>g</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">g(l, r) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> 。</p><p>现在我们来研究一下，如果子串的右边界是固定的（记为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> ），如何解决这个问题。我们来表示一个函数（我们称之为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">pref(x)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span></span></span></span> ），它等于长度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 的前缀上的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 个数，模数为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>2</mn></mrow><annotation encoding="application/x-tex">2</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span></span></span></span> 。因此，如果前缀 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>x</mi></mrow><annotation encoding="application/x-tex">x</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">x</span></span></span></span> 中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 的个数为偶数，则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">pref(x) = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span> ，否则为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo stretchy="false">(</mo><mi>x</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">pref(x) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal">x</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。</p><p>如果子串 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 的右边界固定不变，那么我们需要考虑左边界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 、 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi><mo>&lt;</mo><mi>r</mi></mrow><annotation encoding="application/x-tex">l &lt; r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.73354em;vertical-align:-0.0391em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>+</mo><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo stretchy="false">(</mo><mi>r</mi><mo stretchy="false">)</mo><mo>=</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">pref(l) + pref(r) = 1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> 。我们需要维护这样的左边界的数量（对于有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">pref(l) = i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的边界，让它成为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cnt_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ）和它们的总和（对于有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>f</mi><mo stretchy="false">(</mo><mi>l</mi><mo stretchy="false">)</mo><mo>=</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">pref(l) = i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">p</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mord mathnormal">e</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 的边界，让它成为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi>O</mi><mi>f</mi><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">sumOfL_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ）。当我们遍历 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 时，可以很容易地保持这些值。</p><p>为什么需要这些值？如果我们将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(r - l + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 段的长度表示为右边界和左边界之差，就可以计算出固定右边界 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></msubsup><mi>g</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{l=1}^{r} g(l, r) \cdot (r - l + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 值（如果我们将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>l</mi></mrow><annotation encoding="application/x-tex">l</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span></span></span></span> 视为包含边界，将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 视为不包含边界，就可以从公式中舍弃 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mn>1</mn></mrow><annotation encoding="application/x-tex">1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">1</span></span></span></span> ）。因此， <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msubsup><mo>∑</mo><mrow><mi>l</mi><mo>=</mo><mn>1</mn></mrow><mi>r</mi></msubsup><mi>g</mi><mo stretchy="false">(</mo><mi>l</mi><mo separator="true">,</mo><mi>r</mi><mo stretchy="false">)</mo><mo>⋅</mo><mo stretchy="false">(</mo><mi>r</mi><mo>−</mo><mi>l</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sum_{l=1}^{r} g(l, r) \cdot (r - l + 1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.104002em;vertical-align:-0.29971000000000003em;"></span><span class="mop"><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">∑</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.804292em;"><span style="top:-2.40029em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.01968em;">l</span><span class="mrel mtight">=</span><span class="mord mtight">1</span></span></span></span><span style="top:-3.2029em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.29971000000000003em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">1</span><span class="mclose">)</span></span></span></span> 可以表述为这些线段的右边界之和（等于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>r</mi></mrow><annotation encoding="application/x-tex">r</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">r</span></span></span></span> 乘以不同左边界的个数）与这些线段的左边界之和（保持在 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi>O</mi><mi>f</mi><mi>L</mi></mrow><annotation encoding="application/x-tex">sumOfL</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">L</span></span></span></span> 中）的差。</p><p>现在我们只需遍历右边界并求和，同时保持 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>c</mi><mi>n</mi><msub><mi>t</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">cnt_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76508em;vertical-align:-0.15em;"></span><span class="mord mathnormal">c</span><span class="mord mathnormal">n</span><span class="mord"><span class="mord mathnormal">t</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 和 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>s</mi><mi>u</mi><mi>m</mi><mi>O</mi><mi>f</mi><msub><mi>L</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">sumOfL_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8888799999999999em;vertical-align:-0.19444em;"></span><span class="mord mathnormal">s</span><span class="mord mathnormal">u</span><span class="mord mathnormal">m</span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord"><span class="mord mathnormal">L</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的值。不要忘了，我们只解决了 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> 位的问题，稍后我们需要合并每一位的结果（并确保将 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>b</mi></mrow><annotation encoding="application/x-tex">b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">b</span></span></span></span> /-th 位的结果乘以 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msup><mn>2</mn><mi>b</mi></msup></mrow><annotation encoding="application/x-tex">2^b</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.849108em;vertical-align:0em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.849108em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">b</span></span></span></span></span></span></span></span></span></span></span> ）。</p><p>总体复杂度为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>A</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log A)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">A</span><span class="mclose">)</span></span></span></span> ，其中 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>A</mi></mrow><annotation encoding="application/x-tex">A</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord mathnormal">A</span></span></span></span> 是对数组中数值的限制。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-type">const</span> ll N = <span class="hljs-number">300005</span>;<br><span class="hljs-type">const</span> ll MOD = <span class="hljs-number">998244353</span>;<br>ll n;<br>ll a[N];<br><span class="hljs-function"><span class="hljs-type">int</span>  <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i)<br>        cin &gt;&gt; a[i];<br>    ll res = <span class="hljs-number">0</span>;    <br>    <span class="hljs-keyword">for</span> (ll b = <span class="hljs-number">0</span>; b &lt; <span class="hljs-number">30</span>; ++b) &#123;<br>        ll cur = <span class="hljs-number">0</span>;<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">cnt</span>(<span class="hljs-number">2</span>);<br>        vector &lt;<span class="hljs-type">int</span>&gt; <span class="hljs-built_in">sumOfL</span>(<span class="hljs-number">2</span>);<br>        cnt[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>        ll x = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>            x ^= ((a[i] &gt;&gt; b) &amp; <span class="hljs-number">1</span>);<br>            ll sumOfR = (cnt[x ^ <span class="hljs-number">1</span>] * <span class="hljs-number">1LL</span> * (i + <span class="hljs-number">1</span>)) % MOD;<br>            cur = (cur + (sumOfR - sumOfL[x ^ <span class="hljs-number">1</span>] + MOD) % MOD) % MOD;<br>            cnt[x]++;<br>            sumOfL[x] = (sumOfL[x] + (i + <span class="hljs-number">1</span>)) % MOD;<br>        &#125;<br>        res = (res + (<span class="hljs-number">1</span> &lt;&lt; b) * <span class="hljs-number">1LL</span> * cur) % MOD;<br>    &#125;<br>    cout &lt;&lt; res &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/problemset/problem/1237/D">Balanced Playlist_Global5D</a></p><p>输入 n(2≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e9)。</p><p>0x3F 的播放列表中有 n 首歌，列表中的第 i 首歌的好听度为 a[i]。 这 n 首歌按照【列表循环】模式播放。播放完第 n 首歌，就会播放第 1 首歌。 如果 0x3F 听到一首歌，发现它的好听度 * 2 小于之前听到的最好听的歌，那么 0x3F 就会立刻停止播放。</p><p>输出 n 个数，其中第 i 个数等于，从播放列表中的第 i 首歌开始听，到停止播放时，完整播放的歌曲数目（停止播放时的那首歌不算）。</p><p>对于同一首歌，如果它被完整播放 x 次，就会统计 x 次。见示例 2。</p><p>如果可以无限循环，输出 -1。</p><p><strong>样例：</strong></p><p>输入 4 11 5 2 7 输出 1 1 3 2</p><p>输入 4 3 2 5 3 输出 5 4 3 6</p><p>输入 3 4 3 6 输出 -1 -1 -1</p><p><strong>Sol:</strong></p><p>这个问题有很多解决方法。</p><p>首先，要确定答案是否都是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>−</mo><mn>1</mn></mrow><annotation encoding="application/x-tex">-1</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">−</span><span class="mord">1</span></span></span></span> ，可以比较最大值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的一半和最小值 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 。</p><p>其次，请注意，在前 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个音轨中，我们将听最大值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的音轨，而在接下来的 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>n</mi></mrow><annotation encoding="application/x-tex">n</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathnormal">n</span></span></span></span> 个音轨中，我们将停在最小值为 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 的音轨上。因此，要假装循环播放列表是线性的，只需重复三次即可。</p><p>对于每首曲目 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> ，让我们找到下一首曲目 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi></mrow><annotation encoding="application/x-tex">j</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span></span></span> ，其冷却度大于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>x</mi><mi>i</mi></msub></mrow><annotation encoding="application/x-tex">x_i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> ，下一首曲目 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>k</mi></mrow><annotation encoding="application/x-tex">k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> 的冷却度小于 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><msub><mi>x</mi><mi>i</mi></msub><mn>2</mn></mfrac></mrow><annotation encoding="application/x-tex">\frac{x_i}{2}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.056492em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7114919999999999em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">2</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.4101em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight"><span class="mord mathnormal mtight">x</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3280857142857143em;"><span style="top:-2.357em;margin-left:0em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.143em;"><span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span> 。那么很容易看出，如果是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&lt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j &lt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&lt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，我们就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><msub><mi>c</mi><mi>j</mi></msub><mo>+</mo><mi>j</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">c_i = c_j + j - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8694379999999999em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.311664em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> ，如果是 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>j</mi><mo>&gt;</mo><mi>k</mi></mrow><annotation encoding="application/x-tex">j &gt; k</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.85396em;vertical-align:-0.19444em;"></span><span class="mord mathnormal" style="margin-right:0.05724em;">j</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">&gt;</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span></span></span></span> ，我们就有 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>c</mi><mi>i</mi></msub><mo>=</mo><mi>k</mi><mo>−</mo><mi>i</mi></mrow><annotation encoding="application/x-tex">c_i = k - i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.58056em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal">c</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.31166399999999994em;"><span style="top:-2.5500000000000003em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.77777em;vertical-align:-0.08333em;"></span><span class="mord mathnormal" style="margin-right:0.03148em;">k</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 。</p><p>因此，剩下的工作就是在每条音轨 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>i</mi></mrow><annotation encoding="application/x-tex">i</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.65952em;vertical-align:0em;"></span><span class="mord mathnormal">i</span></span></span></span> 之后找到下一条音轨，而该音轨的冷度位于某个值段中。这可以通过二进制搜索 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><msup><mo><mi>log</mi><mo>⁡</mo></mo><mn>2</mn></msup><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log^2 n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.148448em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop"><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8984479999999999em;"><span style="top:-3.1473400000000002em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">2</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 中的段树，二进制搜索 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 中的稀疏表，二进制搜索 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>O</mi><mo stretchy="false">(</mo><mi>n</mi><mi>log</mi><mo>⁡</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">O(n \log n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop">lo<span style="margin-right:0.01389em;">g</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> 中的堆栈来实现…另外，如果我们按照cool的程度递增/递减的顺序排列轨道，我们也可以用两个指针和类似于 C++ 集合或 Java TreeSet 的结构来回答这些查询。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(<span class="hljs-number">3</span> * n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; a[i];<br>        a[i + n] = a[i + <span class="hljs-number">2</span> * n] = a[i];<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(<span class="hljs-number">3</span> * n)</span></span>;<br>    vi st_max;<br>    vi st_min;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">3</span> * n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">while</span> (!st_max.<span class="hljs-built_in">empty</span>() &amp;&amp; a[st_max.<span class="hljs-built_in">back</span>()] &lt; a[i]) &#123;<br>            st_max.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!st_min.<span class="hljs-built_in">empty</span>() &amp;&amp; a[st_min.<span class="hljs-built_in">back</span>()] &gt; a[i]) &#123;<br>            st_min.<span class="hljs-built_in">pop_back</span>();  <br>        &#125;<br>        <span class="hljs-type">int</span> low = <span class="hljs-number">0</span>, high = (<span class="hljs-type">int</span>) st_min.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-keyword">while</span> (low &lt; high) &#123;<br>            <span class="hljs-type">int</span> mid = (low + high) &gt;&gt; <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">if</span> (a[st_min[mid]] * <span class="hljs-number">2</span> &lt; a[i]) &#123;<br>                low = mid + <span class="hljs-number">1</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                high = mid;<br>            &#125;<br>        &#125;<br>        <span class="hljs-type">int</span> nxt = <span class="hljs-number">3</span> * n;<br>        <span class="hljs-keyword">if</span> (low &gt; <span class="hljs-number">0</span>) &#123;<br>            nxt = <span class="hljs-built_in">min</span>(nxt, st_min[low - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (!st_max.<span class="hljs-built_in">empty</span>()) &#123;<br>            nxt = <span class="hljs-built_in">min</span>(nxt, st_max.<span class="hljs-built_in">back</span>());<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nxt &lt; <span class="hljs-number">3</span> * n &amp;&amp; a[nxt] &gt;= a[i]) &#123;<br>            ans[i] = ans[nxt];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans[i] = nxt;<br>        &#125;<br>        st_min.<span class="hljs-built_in">push_back</span>(i);<br>        st_max.<span class="hljs-built_in">push_back</span>(i);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (i &gt; <span class="hljs-number">0</span>) &#123;<br>            cout &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>        cout &lt;&lt; (ans[i] == <span class="hljs-number">3</span> * n ? <span class="hljs-number">-1</span> : ans[i] - i);<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/1584/F">Strange LCS</a></p><p>输入 T(≤5) 表示 T 组数据。</p><p>每组数据输入 n(2≤n≤10) 和 n 个字符串，只包含大写和小写英文字母，且对于每个字符串，每个字母最多出现两次。</p><p>计算这 n 个字符串的最长公共子序列（LCS）。</p><p>输出 LCS 的长度和任意 LCS。</p><p><strong>样例：</strong></p><p>输入</p><p>4</p><p>2</p><p>ABC</p><p>CBA</p><p>2</p><p>bacab</p><p>defed</p><p>3</p><p>abcde</p><p>aBcDe</p><p>ace</p><p>2</p><p>codeforces</p><p>technocup</p><p>输出</p><p>1</p><p>A</p><p>0</p><p>3</p><p>ace</p><p>3</p><p>coc</p><p><strong>Sol:</strong></p><p>首先思考：如果每个字母至多出现一次，要怎么做？</p><p>如果对于每个字符串，字母x都出现在字母y的左边，那么就在x到y之间连一条有向边。</p><p>问题变成求有向无环图（DAG）的最长路，这可以用记忆化搜索（或者拓扑排序）来解决。</p><p>那么有两个字符串，字母x的在第一个字符串的下标为i1和i2,在第二个字符串中下标为j1和j2，那么字母x就有四种不同位置的组合。</p><p>推广到n个字符串，每个字母至多有2<sup>n</sup>种不同的位置组合。</p><p>用二进制数mask记录字母c在各个字符串中的位置，记为（mask，c）。</p><ul><li>mask二进制从低到高第i位为0，表示c位于s[i]中的左边那个c的下标。</li><li>mask二进制从低到高第i位为1，表示c位于s[i]中的右边那个c的下标。</li></ul><p>如果对于每个字符串，字母x都出现在字母y的左边，那么就在（mask，x）到（mask2，y）之间连一条有向边。同样，就变成了上述的问题。</p><p>考虑使用记忆话搜索计算，定义dfs(mask,c)表示LCS首字母为c，位置组合为mask时的LCS长度。</p><p>枚举下一个字母ch，设ch在各个字符串中的位置为mask2，则用dfs（mask2，ch）+1更新答案的最大值（下面代码把+1放在返回前计算）。</p><p>注意这里mask2要贪心的计算如果两个ch都满足，优先取最左边的。</p><p>答案为dfs(0,0) - 1,这里取字符’\0’作为LCS的首字母，这样就无需在dfs外面枚举LCS的首字母了。</p><p>为了输出具体方案，可以用一个from数组，在dfs中记录转移来源。</p><p><strong>Code(buhui）:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vector&lt;string&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : a) cin &gt;&gt; c;<br>    vector&lt;map&lt;<span class="hljs-type">char</span>, vector&lt;<span class="hljs-type">int</span>&gt;&gt;&gt; <span class="hljs-built_in">gist</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; (<span class="hljs-type">int</span>)a[i].<span class="hljs-built_in">size</span>(); j++) gist[i][a[i][j]].<span class="hljs-built_in">pb</span>(j);<br>    &#125;<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, <span class="hljs-type">int</span>&gt; dp;<br>    map&lt;vector&lt;<span class="hljs-type">int</span>&gt;, vector&lt;<span class="hljs-type">int</span>&gt;&gt; pr;<br>    dp[<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>)] = <span class="hljs-number">0</span>;<br>    set&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; q;<br>    q.<span class="hljs-built_in">insert</span>(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>));<br>    <span class="hljs-keyword">while</span> (q.<span class="hljs-built_in">size</span>()) &#123;<br>        vector&lt;<span class="hljs-type">int</span>&gt; now = *q.<span class="hljs-built_in">begin</span>();<br>        q.<span class="hljs-built_in">erase</span>(q.<span class="hljs-built_in">begin</span>());<br>        <span class="hljs-type">int</span> val = dp[now];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;a&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;z&#x27;</span>; c++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span></span>;<br>            <span class="hljs-type">bool</span> bad = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> id = <span class="hljs-built_in">upper_bound</span>(<span class="hljs-built_in">all</span>(gist[i][c]), now[i]) - gist[i][c].<span class="hljs-built_in">begin</span>();;<br>                <span class="hljs-keyword">if</span> (id == (<span class="hljs-type">int</span>)gist[i][c].<span class="hljs-built_in">size</span>()) &#123;<br>                    bad = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                nxt[i] = gist[i][c][id];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bad) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!dp.<span class="hljs-built_in">count</span>(nxt)) q.<span class="hljs-built_in">insert</span>(nxt);<br>            <span class="hljs-keyword">if</span> (!dp.<span class="hljs-built_in">count</span>(nxt) || dp[nxt] &lt; val + <span class="hljs-number">1</span>) &#123;<br>                dp[nxt] = val + <span class="hljs-number">1</span>;<br>                pr[nxt] = now;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c = <span class="hljs-string">&#x27;A&#x27;</span>; c &lt;= <span class="hljs-string">&#x27;Z&#x27;</span>; c++) &#123;<br>            <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">nxt</span><span class="hljs-params">(n)</span></span>;<br>            <span class="hljs-type">bool</span> bad = <span class="hljs-number">0</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>                <span class="hljs-type">int</span> id = <span class="hljs-built_in">upper_bound</span>(<span class="hljs-built_in">all</span>(gist[i][c]), now[i]) - gist[i][c].<span class="hljs-built_in">begin</span>();;<br>                <span class="hljs-keyword">if</span> (id == (<span class="hljs-type">int</span>)gist[i][c].<span class="hljs-built_in">size</span>()) &#123;<br>                    bad = <span class="hljs-number">1</span>;<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br>                nxt[i] = gist[i][c][id];<br>            &#125;<br>            <span class="hljs-keyword">if</span> (bad) <span class="hljs-keyword">continue</span>;<br>            <span class="hljs-keyword">if</span> (!dp.<span class="hljs-built_in">count</span>(nxt)) q.<span class="hljs-built_in">insert</span>(nxt);<br>            <span class="hljs-keyword">if</span> (!dp.<span class="hljs-built_in">count</span>(nxt) || dp[nxt] &lt; val + <span class="hljs-number">1</span>) &#123;<br>                dp[nxt] = val + <span class="hljs-number">1</span>;<br>                pr[nxt] = now;<br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">now</span><span class="hljs-params">(n, <span class="hljs-number">-1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;c : dp) &#123;<br>        <span class="hljs-keyword">if</span> (ans &lt; c.second) &#123;<br>            ans = c.second;<br>            now = c.first;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    string s = <span class="hljs-string">&quot;&quot;</span>;<br>    <span class="hljs-keyword">while</span> (now != <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n, <span class="hljs-number">-1</span>)) &#123;<br>        s += a[<span class="hljs-number">0</span>][now[<span class="hljs-number">0</span>]];<br>        now = pr[now];<br>    &#125;<br>    <span class="hljs-built_in">reverse</span>(<span class="hljs-built_in">all</span>(s));<br>    cout &lt;&lt; s &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">return</span>;<br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>greedy</tag>
      
      <tag>bitmask</tag>
      
      <tag>stack</tag>
      
      <tag>binary_search</tag>
      
      <tag>lcs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>div3-950</title>
    <link href="/2024/06/07/DIV3_950/"/>
    <url>/2024/06/07/DIV3_950/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="div3_950"><a class="markdownIt-Anchor" href="#div3_950"></a> <a href="https://codeforces.com/contest/1980">DIV3_950</a></h1><h2 id="a"><a class="markdownIt-Anchor" href="#a"></a> A</h2><p><a href="https://codeforces.com/contest/1980/problem/A">Problem Generator_950A</a></p><p><strong>题意：</strong></p><p>输入n，m和字符串s，s包含’A’, ‘B’, ‘C’, ‘D’, ‘E’, ‘F’, 和 ‘G’.</p><p>要求我们需要添加的最少的字符个数，使得s中的各个字符都至少有m个</p><p><strong>Sol:</strong></p><p>遍历计数，不够的添加，够了就不加</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;;<br>    cin&gt;&gt;n&gt;&gt;m;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">vis</span><span class="hljs-params">(<span class="hljs-number">7</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> c:s) &#123;<br>        vis[c-<span class="hljs-string">&#x27;A&#x27;</span>]++;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>        <span class="hljs-comment">//cout &lt;&lt; m - vis[i] &lt;&lt; &quot; &quot;;</span><br>        <span class="hljs-keyword">if</span>(vis[i] &gt;= m) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += m - vis[i];<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="b"><a class="markdownIt-Anchor" href="#b"></a> B</h2><p><a href="https://codeforces.com/contest/1980/problem/B">Choosing Cubes_950B</a></p><p><strong>题意：</strong></p><p>给你一个长度为n的数组，和一个下标f，按从大到小排序，删掉k个值，看f是否会被删掉</p><p><strong>Sol：</strong></p><p>统计大于下标f的值的个数count1和大于等于下标f的值的个数count2，如果count1&gt;=k，那么f就一定不会被删除。如果count1&lt;k&amp;&amp;count2&lt;k，那么f就可能被删除。否则，f一定会被删除。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, f, k;<br>    cin&gt;&gt;n&gt;&gt;f&gt;&gt;k;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;   <br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;n; i++) cin&gt;&gt;a[i];<br>    <span class="hljs-type">int</span> fav = a[f<span class="hljs-number">-1</span>];<br>    <span class="hljs-type">int</span> cnt1 = <span class="hljs-number">0</span>,cnt2 = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> num:a) &#123;<br>        <span class="hljs-keyword">if</span>(num &gt; fav) cnt1++;<br>        <span class="hljs-keyword">if</span>(num &gt;= fav) cnt2++;<br>    &#125;<br>    <span class="hljs-comment">//cout &lt;&lt; cnt1 &lt;&lt; &quot; &quot; &lt;&lt; cnt2 &lt;&lt; endl;</span><br>    <span class="hljs-keyword">if</span>(cnt2 &lt;= k) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;YES&quot;</span> &lt;&lt;endl;<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (cnt1 &lt; k &amp;&amp; cnt2 &gt; k) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;MAYBE&quot;</span> &lt;&lt; endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;NO&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="c"><a class="markdownIt-Anchor" href="#c"></a> C</h2><p><a href="https://codeforces.com/contest/1980/problem/C">Sofia and the Lost Operations_950C</a></p><p><strong>题意解释：</strong></p><p>Sofia有一个包含𝑛个整数的数组𝑎1,𝑎2,…,𝑎𝑛。她对它感到厌倦，于是决定对它进行𝑚个修改操作。<br />每个修改操作由一对数字⟨𝑐𝑗,𝑑𝑗⟩描述，意味着数组中索引为𝑐𝑗的元素应赋值为𝑑𝑗，即执行赋值𝑎𝑐𝑗=𝑑𝑗。在依次应用所有修改操作后，Sofia丢弃了得到的数组。<br />最近，你发现了一个包含𝑛个整数的数组𝑏1,𝑏2,…,𝑏𝑛。你想知道这个数组是否是Sofia的数组。你知道原始数组的值，以及值𝑑1,𝑑2,…,𝑑𝑚。值𝑐1,𝑐2,…,𝑐𝑚被遗失了。<br />是否存在一个序列𝑐1,𝑐2,…,𝑐𝑚，使得将修改操作⟨𝑐1,𝑑1,⟩,⟨𝑐2,𝑑2,⟩,…,⟨𝑐𝑚,𝑑𝑚⟩依次应用到数组𝑎1,𝑎2,…,𝑎𝑛能将其转换为数组𝑏1,𝑏2,…,𝑏𝑛？</p><p>输入<br />第一行包含一个整数𝑡（1≤𝑡≤104）——测试用例的数量。<br />然后是每个测试用例的描述。<br />每个测试用例的第一行包含一个整数𝑛（1≤𝑛≤2⋅105）——数组的大小。<br />每个测试用例的第二行包含𝑛个整数𝑎1,𝑎2,…,𝑎𝑛（1≤𝑎𝑖≤109）——原始数组的元素。<br />每个测试用例的第三行包含𝑛个整数𝑏1,𝑏2,…,𝑏𝑛（1≤𝑏𝑖≤109）——找到的数组的元素。<br />第四行包含一个整数𝑚（1≤𝑚≤2⋅105）——修改操作的数量。<br />第五行包含𝑚个整数𝑑1,𝑑2,…,𝑑𝑚（1≤𝑑𝑗≤109）——每个修改操作的保留值。<br />保证所有测试用例中𝑛的值之和不超过2⋅105，同样保证所有测试用例中𝑚的值之和不超过2⋅105。</p><p>输出<br />输出𝑡行，每行是对应测试用例的答案。作为答案，如果存在合适的序列𝑐1,𝑐2,…,𝑐𝑚，则输出“YES”，否则输出“NO”。<br />你可以以任何形式输出答案（例如，字符串“yEs”、“yes”、“Yes”和“YES”都将被识别为肯定答案）。</p><p>示例<br />输入<br />7<br />3<br />1 2 1<br />1 3 2<br />4<br />1 3 1 2<br />4<br />1 2 3 5<br />2 1 3 5<br />2<br />2 3<br />5<br />7 6 1 10 10<br />3 6 1 11 11<br />3<br />4 3 11<br />4<br />3 1 7 8<br />2 2 7 10<br />5<br />10 3 2 2 1<br />5<br />5 7 1 7 9<br />4 10 1 2 9<br />8<br />1 1 9 8 7 2 10 4<br />4<br />1000000000 203 203 203<br />203 1000000000 203 1000000000<br />2<br />203 1000000000<br />1<br />1<br />1<br />5<br />1 3 4 5 1<br />输出<br />YES<br />NO<br />NO<br />NO<br />YES<br />NO<br />YES</p><p><strong>Sol:</strong></p><p>遍历原始数组和找到的数组，如果对应位置的元素不相等，则在mp1中记录找到的数组元素出现的次数，并增加计数器cnt。</p><p>遍历修改操作的保留值数组d，如果在mp1中找到对应的值，则减少对应值的出现次数，并减少计数器cnt。</p><p>如果计数器cnt为0，并且修改操作的保留值数组d的最后一个值在mp2中出现，则输出“YES”，否则输出“NO”。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k,l;<br>    cin&gt;&gt;n&gt;&gt;k&gt;&gt;l;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n*k)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n*k;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-type">int</span> rg = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">upper_bound</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), a[<span class="hljs-number">0</span>] + l) - a.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-keyword">if</span> (rg &lt; n) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans += a[u++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; k - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (rg - u &gt; n - i - <span class="hljs-number">1</span>) &#123;<br>                u++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="d"><a class="markdownIt-Anchor" href="#d"></a> D</h2><p><a href="https://codeforces.com/contest/1980/problem/D">GCD-sequence_950D</a></p><p><strong>题意：</strong></p><p>判断是否可以从数组𝑎中移除一个数字，使得计算得到的GCD序列𝑏是非递减的。也就是说，𝑏𝑖≤𝑏𝑖+1始终成立。</p><p><strong>Sol:</strong></p><ol><li>计算数组a中相邻两个数的最大公约数，将结果存入数组b中。</li><li>判断数组b是否是非递减序列，如果是则输出&quot;YES&quot;，否则进行下一步。</li><li>遍历数组a，尝试移除其中的一个数字，然后重新计算GCD序列，判断是否能得到非递减序列，如果能则输出&quot;YES&quot;，否则输出&quot;NO&quot;。</li></ol><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin&gt;&gt; a[i];   <br>    vi b;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n - <span class="hljs-number">1</span>; i++) &#123;<br>        b.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">gcd</span>(a[i], a[i + <span class="hljs-number">1</span>]));<br>    &#125;<br>    <span class="hljs-type">int</span> inv = <span class="hljs-number">0</span>, pos = <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; b.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        <span class="hljs-keyword">if</span> (b[i] &gt; b[i + <span class="hljs-number">1</span>]) inv++, pos = i;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (inv == <span class="hljs-number">0</span> || pos == <span class="hljs-number">-1</span>) &#123;<br>        cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> good = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> remove_pos = <span class="hljs-built_in">max</span>(<span class="hljs-number">0</span>, pos - <span class="hljs-number">3</span>); remove_pos &lt; <span class="hljs-built_in">min</span>(n, pos + <span class="hljs-number">3</span>); ++remove_pos) &#123;<br>      <span class="hljs-type">int</span> rvp = remove_pos;<br>      <span class="hljs-keyword">auto</span> c = a;<br>      c.<span class="hljs-built_in">erase</span>(c.<span class="hljs-built_in">begin</span>() + rvp);<br>      vector&lt;<span class="hljs-type">int</span>&gt; bb;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i + <span class="hljs-number">1</span> &lt; c.<span class="hljs-built_in">size</span>(); ++i) &#123;<br>        bb.<span class="hljs-built_in">push_back</span>(<span class="hljs-built_in">gcd</span>(c[i], c[i + <span class="hljs-number">1</span>]));<br>      &#125;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-built_in">is_sorted</span>(<span class="hljs-built_in">all</span>(bb))) &#123;<br>        good = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; (good ? <span class="hljs-string">&quot;YES&quot;</span> : <span class="hljs-string">&quot;NO&quot;</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="e"><a class="markdownIt-Anchor" href="#e"></a> E</h2><p><a href="https://codeforces.com/contest/1980/problem/E">Permutation of Rows and Columns_950E</a></p><p><strong>题意：</strong></p><ul><li>给定t组测试用例。</li><li>每个测试用例包括两行，第一行包含两个整数n和m，表示矩阵的大小。</li><li>接下来的n行包含m个整数，表示矩阵a的元素。</li><li>再接下来的n行包含m个整数，表示矩阵b的元素。</li><li>输出对于每个测试用例，如果可以通过交换矩阵a的行或列来得到矩阵b，则输出&quot;YES&quot;，否则输出&quot;NO&quot;。</li></ul><p><strong>Sol:</strong></p><p>规律：按照每行的最小元素进行排序，然后再定义对应的转置矩阵，同样按照每行的最小元素进行排序，最后比较该矩阵的元素，若存在不相等的情况，则无法转换，否则满足。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">a</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m));<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">b</span>(n, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(m));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>        cin &gt;&gt; a[i][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>        cin &gt;&gt; b[i][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-type">int</span> bad = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(a), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; i, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; j) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(i)) &lt; *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(j));<br>    &#125;);<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(b), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; i, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; j) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(i)) &lt; *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(j));<br>    &#125;);<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">c</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt; &gt; <span class="hljs-built_in">d</span>(m, <span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n));<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; m; ++j) &#123;<br>        c[j][i] = a[i][j];<br>        d[j][i] = b[i][j];<br>      &#125;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(c), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; i, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; j) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(i)) &lt; *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(j));<br>    &#125;);<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(d), [](<span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; i, <span class="hljs-type">const</span> vector&lt;<span class="hljs-type">int</span>&gt;&amp; j) &#123;<br>      <span class="hljs-keyword">return</span> *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(i)) &lt; *<span class="hljs-built_in">min_element</span>(<span class="hljs-built_in">all</span>(j));<br>    &#125;);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; ++i) &#123;<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; ++j) &#123;<br>        <span class="hljs-keyword">if</span> (c[i][j] != d[i][j]) &#123;<br>          bad = <span class="hljs-number">1</span>;<br>          <span class="hljs-keyword">break</span>;<br>        &#125;<br>      &#125;<br>    &#125;<br>    cout &lt;&lt; (bad ? <span class="hljs-string">&quot;NO&quot;</span> : <span class="hljs-string">&quot;YES&quot;</span>) &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="f1"><a class="markdownIt-Anchor" href="#f1"></a> F1</h2><p><a href="https://codeforces.com/contest/1980/problem/F1">Field Division_950F1</a></p><p>Alice和Bob正在划分一个田地。田地是一个大小为𝑛×𝑚（2≤𝑛,𝑚≤109）的矩形，行从上到下编号为1到𝑛，列从左到右编号为1到𝑚。位于第𝑟行第𝑐列的单元格表示为(𝑟,𝑐)。</p><p>Bob有𝑘（2≤𝑘≤2⋅105）个喷泉，它们都位于田地的不同单元格中。Alice负责划分田地，但她必须满足几个条件：</p><ul><li>要划分田地，Alice将从田地的左侧或顶部的任何空闲单元格开始她的路径，并且每次移动都向下或向右相邻的单元格。她的路径将在田地的右侧或底部结束。</li><li>Alice的路径将把田地分成两部分——一部分属于Alice（这部分包括她的路径的单元格），另一部分属于Bob。</li><li>Alice将拥有包括单元格(𝑛,1)的部分。</li><li>Bob将拥有包括单元格(1,𝑚)的部分。</li></ul><p>Alice希望以尽可能多的单元格来划分田地。 Bob希望保留所有的喷泉，但他可以把其中一个喷泉给Alice。首先输出整数𝛼——如果Bob不给她任何喷泉（即所有喷泉都将留在Bob的部分），则Alice的地块的最大可能大小。然后输出𝑘个非负整数𝑎1,𝑎2,…,𝑎𝑘，其中：</p><ul><li>如果Bob给Alice第𝑖个喷泉后，Alice的地块的最大可能大小不增加（即保持等于𝛼），则𝑎𝑖=0；</li><li>如果Bob给Alice第𝑖个喷泉后，Alice的地块的最大可能大小增加（即变大于𝛼），则𝑎𝑖=1。</li></ul><p>输入</p><ul><li>第一行包含一个整数𝑡（1≤𝑡≤104）——测试用例的数量。</li><li>每个测试用例的第一行包含三个整数𝑛,𝑚和𝑘（2≤𝑛,𝑚≤109，2≤𝑘≤2⋅105）——田地的大小和喷泉的数量。</li><li>然后是𝑘行，每行包含两个数字𝑟𝑖和𝑐𝑖（1≤𝑟𝑖≤𝑛，1≤𝑐𝑖≤𝑚）——第𝑖个喷泉所在单元格的坐标。保证所有单元格都不同，并且它们中没有一个是(𝑛,1)。</li></ul><p>保证所有测试用例中𝑘的总和不超过2⋅105。</p><p>输出 对于每个测试用例，首先输出𝛼——如果Bob不给她任何喷泉，Alice的地块的最大可能大小。然后输出𝑘个非负整数𝑎1,𝑎2,…,𝑎𝑘，其中：</p><ul><li>如果Bob给Alice第𝑖个喷泉后，Alice的地块的最大可能大小不增加（即保持等于𝛼），则输出0；</li><li>如果Bob给Alice第𝑖个喷泉后，Alice的地块的最大可能大小增加（即变大于𝛼），则输出1。</li></ul><p>如果您输出任何其他正数而不是1，只要它适合64位有符号整数类型，它也将被识别为1。</p><p><strong>Sol：</strong></p><p>Alice只能向下或向右移动，如果在第𝑖行有𝑥个单元格属于她，那么在第(𝑖−1)行她最多只能有𝑥个单元格。最大地块的构建可以表示如下：我们将从下到上遍历行，并跟踪我们在下面一行收集了多少单元格。在当前行，我们将收集相同数量的单元格，或者收集直到该行最左边的喷泉的所有单元格，如果这样的单元格更少。</p><p>相对于Alice的地块边界，喷泉有三种可能的位置：</p><ol><li>喷泉没有相邻的单元格属于Alice的地块；</li><li>喷泉有一个相邻的单元格属于Alice的地块；</li><li>喷泉有两个相邻的单元格属于Alice的地块。</li></ol><p>只有在移除第三种喷泉位置时，即所谓的角落，Alice的地块面积才会改变。因为角落已经形成，在下面一行Alice有更多的单元格，当移除这个喷泉时，她将能够至少带走一个单元格，并且对它的答案将是1。对于其他两种位置，移除喷泉不会改变地块的大小，它们的答案将是0（您可以自行证明）。</p><p>为了确保解决方案不依赖于田地的大小，我们将按照𝑥坐标的降序对喷泉进行排序，如果𝑥相等，则按𝑦坐标的升序排序。我们将按照这个顺序遍历喷泉，跟踪最后一个角落的坐标，并在找到新的角落时更新答案。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;pii&gt; <span class="hljs-title">a</span><span class="hljs-params">(k)</span></span>;<br>    map&lt;pii, <span class="hljs-type">int</span>&gt; idx;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        cin &gt;&gt; a[i].F &gt;&gt; a[i].S;<br>        idx[a[i]] = i;<br>    &#125;<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(a), [](<span class="hljs-type">const</span> pii &amp;a, <span class="hljs-type">const</span> pii &amp;b) &#123;<br>        <span class="hljs-keyword">if</span> (a.F != b.F) <span class="hljs-keyword">return</span> a.F &gt; b.F;<br>        <span class="hljs-keyword">return</span> a.S &lt; b.S;<br>    &#125;);<br>    <span class="hljs-function">vi <span class="hljs-title">ans</span><span class="hljs-params">(k)</span></span>;<br>    <span class="hljs-type">int</span> total = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">int</span> cur = m + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> last = n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e : a) &#123;<br>        <span class="hljs-keyword">if</span> (cur &gt; e.S) &#123;<br>            ans[idx[e]] = <span class="hljs-number">1</span>;<br>            total += (cur - <span class="hljs-number">1</span>) * (last - e.F);<br>            cur = e.S;<br>            last = e.F;<br>        &#125;<br>    &#125;<br>    total += (cur - <span class="hljs-number">1</span>) * last;<br>    cout &lt;&lt; total &lt;&lt; endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> e : ans) cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="f2"><a class="markdownIt-Anchor" href="#f2"></a> F2</h2><p><a href="https://codeforces.com/contest/1980/problem/F2">Field Division_950F2</a></p><p>题意参照<a href="#F1">F1</a>,困难版本，输出的不是是否增加，而是增加面积数</p><p><strong>Sol：</strong></p><p>让我们使用简单版本的解决方案来预先计算存储在前缀上的信息。 只有当喷泉被移除时，它才会停止成为一个角落，因为前缀上最左边的角落在移除后不会再向左移动。 为了计算面积的变化，让我们做一个重要的观察：如果喷泉𝑗不是一个角落，那么它要么无法成为一个角落，要么只有在按排序顺序在它之前的最后一个角落被移除后才会成为一个角落。它是在喷泉𝑗之前出现的最左边的角落，按排序顺序下一个角落的行号会严格更高。 因此，我们需要做以下事情：对于每个角落，计算在不考虑它的情况下直到下一个角落的面积，这将有助于我们在计算面积时进行预计算。每个喷泉只会被处理一次，因此时间复杂度为𝑂(𝑛)。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-function">vector&lt;pii&gt; <span class="hljs-title">a</span><span class="hljs-params">(k)</span></span>;<br>    map&lt;pii, <span class="hljs-type">int</span>&gt; idx;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>        cin &gt;&gt; a[i].x &gt;&gt; a[i].y;<br>        idx[a[i]] = i;<br>    &#125;<br>    idx[&#123;<span class="hljs-number">0</span>,<span class="hljs-number">0</span>&#125;] = k++;<br>    a.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>    <span class="hljs-built_in">sort</span>(<span class="hljs-built_in">all</span>(a), [](<span class="hljs-type">const</span> pii &amp;a, <span class="hljs-type">const</span> pii &amp;b) &#123;<br>        <span class="hljs-keyword">if</span> (a.x != b.x) <span class="hljs-keyword">return</span> a.x &gt; b.x;<br>        <span class="hljs-keyword">return</span> a.y &lt; b.y;<br>    &#125;);<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(k)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">total</span><span class="hljs-params">(k + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">cur</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, m + <span class="hljs-number">1</span>)</span>, <span class="hljs-title">last</span><span class="hljs-params">(k + <span class="hljs-number">1</span>, n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)&#123;<br>        <span class="hljs-keyword">auto</span> e = a[i - <span class="hljs-number">1</span>];<br>        total[i] = total[i - <span class="hljs-number">1</span>];<br>        cur[i] = cur[i - <span class="hljs-number">1</span>];<br>        last[i] = last[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(cur[i] &gt; e.y) &#123;<br>            ans[idx[e]] = <span class="hljs-number">1</span>;<br>            total[i] += (cur[i] - <span class="hljs-number">1</span>) * (last[i] - e.x);<br>            cur[i] = e.y;<br>            last[i] = e.x;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; total[k] &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= k; ++i)&#123;<br>        <span class="hljs-keyword">auto</span> e = a[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">if</span>(ans[idx[e]] == <span class="hljs-number">0</span>)<span class="hljs-keyword">continue</span>;<br>        <span class="hljs-type">int</span> tot = total[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> cr = cur[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-type">int</span> lst = last[i - <span class="hljs-number">1</span>];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = i + <span class="hljs-number">1</span>; j &lt;= k; ++j)&#123;<br>            <span class="hljs-keyword">auto</span> ee = a[j - <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span>(cr &gt; ee.y)&#123;<br>                tot += (cr - <span class="hljs-number">1</span>) * (lst - ee.x);<br>                cr = ee.y;<br>                lst = ee.x;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(ans[idx[ee]] == <span class="hljs-number">1</span>)&#123;<br>                ans[idx[e]] = tot - total[j];<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    ans.<span class="hljs-built_in">pop_back</span>();<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> e: ans) cout &lt;&lt; e &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="g"><a class="markdownIt-Anchor" href="#g"></a> G</h2><p><a href="https://codeforces.com/contest/1980/problem/G">Yasya and the Mysterious Tree_950G</a></p><p><strong>题意：</strong></p><p>Yasya在森林中漫步时意外发现了一棵具有𝑛个顶点的树。树是一个无环的连通无向图。 在树旁边，女孩发现了一份古老的手稿，上面写着𝑚个查询。查询可以有两种类型。 第一种查询由整数𝑦描述。树中每条边的权重被替换为该边的权重与整数𝑦的按位异或。 第二种查询由顶点𝑣和整数𝑥描述。Yasya选择一个顶点𝑢（1≤𝑢≤𝑛，𝑢≠𝑣），并在树中从𝑣到𝑢画一条权重为𝑥的双向边。然后Yasya在结果图中找到一个简单环，并计算其中所有边的按位异或值。她希望选择一个顶点𝑢，使得计算出的值最大。在给定的约束条件下可以证明这样的环存在且唯一（不依赖于𝑢的选择）。如果𝑣和𝑢之间已经存在一条边，那么简单环就是路径𝑣→𝑢→𝑣。 请帮助Yasya回答所有的查询。</p><p><strong>输入</strong></p><p>第一行包含一个整数𝑡（1≤𝑡≤104）——测试用例的数量。</p><p>接下来是每个测试用例的描述。</p><p>每个测试用例的第一行包含两个整数𝑛，𝑚（2≤𝑛≤2⋅105，1≤𝑚≤2⋅105）——树中顶点的数量和查询的数量。</p><p>每个测试用例的接下来𝑛−1行包含三个整数𝑣，𝑢，𝑤（1≤𝑣,𝑢≤𝑛，1≤𝑤≤109）——树中某条边的端点和权重。 保证给定的边构成一棵树。</p><p>每个测试用例的接下来𝑚行描述了查询：</p><p>^ 𝑦（1≤𝑦≤109）——第一种查询的参数；</p><p>? 𝑣 𝑥（1≤𝑣≤𝑛，1≤𝑥≤109）——第二种查询的参数。</p><p>保证所有测试用例中𝑛的总和不超过2⋅105。对于𝑚也是一样的。</p><p><strong>输出</strong></p><p>对于每个测试用例，输出第二种查询的答案。</p><p><strong>Sol</strong></p><p>我们将把树放在顶点1上，并计算从顶点到根节点路径上每个顶点𝑑𝑣的异或值。这可以通过深度优先遍历在𝑂(𝑛)时间复杂度内完成。</p><p>现在让我们来学习如何在每个查询中以𝑂(𝑛)时间复杂度解决问题。第一类查询可以直接执行。注意由于异或运算的属性，数值只会在奇深度的顶点（根节点的深度为0）发生改变。同时，它们的改变很简单：与𝑦异或即可。为了回答第二类查询，需要意识到简单循环路径𝑣→lca(𝑣,𝑢)→𝑢→𝑣的异或值等于𝑑𝑣⊕𝑑𝑢⊕𝑥。实际上，从lca(v, u)到根节点的路径将被计算两次，所以最终异或值为0，并且不会包含任何其他额外的边。通过适当的技巧，你可以尝试使用AVX指令加速这种解决方案，但是时间限制设置得很严格。</p><p>对于问题的完整解决方案，可以使用前缀树（trie）数据结构。借助它，可以在𝑂(log𝑥)时间复杂度内找到集合中与𝑥异或后结果最大的𝑦。由于𝑑𝑣会不同地改变，你需要使用两个前缀树——分别用于偶数和奇数高度的顶点。第一类操作可以累积在变量𝑤odd中，并添加到异或表达式中。此外，在回答第二类查询时，不要忘记从所需的前缀树中删除𝑑𝑣，然后再插入回去。为此，可以在每个顶点中维护一个叶子节点的计数器，并在遍历过程中使用这些信息。</p><p>因此，最终的时间复杂度为𝑂((𝑛+𝑚)log109)。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">trie</span> &#123;<br>    <span class="hljs-type">int</span> l, c;<br>    vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt; &gt; node;<br>    vector&lt;<span class="hljs-type">int</span>&gt; cnt;<br>    <span class="hljs-built_in">trie</span>(<span class="hljs-type">int</span> l, <span class="hljs-type">int</span> max_members) : <span class="hljs-built_in">l</span>(l), <span class="hljs-built_in">c</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">node</span>((l + <span class="hljs-number">2</span>) * max_members + <span class="hljs-number">3</span>), <span class="hljs-built_in">cnt</span>((l + <span class="hljs-number">2</span>) * max_members + <span class="hljs-number">3</span>) &#123;&#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">add</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">bool</span> has_bit = (<span class="hljs-number">1</span> &lt;&lt; i) &amp; x;<br>            <span class="hljs-keyword">if</span> (!node[cur][has_bit]) &#123;<br>                node[cur][has_bit] = ++c;<br>            &#125;<br>            cur = node[cur][has_bit];<br>            ++cnt[cur];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">bool</span> has_bit = (<span class="hljs-number">1</span> &lt;&lt; i) &amp; x;<br>            <span class="hljs-keyword">if</span> (!node[cur][has_bit]) &#123;<br>                node[cur][has_bit] = ++c;<br>            &#125;<br>            cur = node[cur][has_bit];<br>            --cnt[cur];<br>        &#125;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">find_max</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>        <span class="hljs-type">int</span> cur = <span class="hljs-number">0</span>, ans = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = l; i &gt;= <span class="hljs-number">0</span>; --i) &#123;<br>            <span class="hljs-type">bool</span> has_bit = (<span class="hljs-number">1</span> &lt;&lt; i) &amp; x;<br>            <span class="hljs-keyword">if</span> (node[cur][!has_bit] &amp;&amp; cnt[node[cur][!has_bit]]) &#123;<br>                ans += <span class="hljs-number">1</span> &lt;&lt; i;<br>                cur = node[cur][!has_bit];<br>            &#125;<br>            <span class="hljs-keyword">else</span> &#123;<br>                cur = node[cur][has_bit];<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> ans;<br>    &#125;<br>&#125;;<br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e5</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">int</span> x[N];<br>bitset&lt;N&gt; dp;<br>vector&lt;array&lt;<span class="hljs-type">int</span>, 2&gt; &gt; e[N];<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> c, <span class="hljs-type">int</span> p)</span> </span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> [i, w] : e[c]) &#123;<br>        <span class="hljs-keyword">if</span> (i == p) &#123;<br>            <span class="hljs-keyword">continue</span>;<br>        &#125;<br>        dp[i] = !dp[c];<br>        x[i] = x[c] ^ w;<br>        <span class="hljs-built_in">dfs</span>(i, c);<br>    &#125;<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n, m, gx = <span class="hljs-number">0</span>;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        e[i].<span class="hljs-built_in">clear</span>();<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>, u, v, w; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;<br>        e[u].<span class="hljs-built_in">push_back</span>(&#123;v, w&#125;);<br>        e[v].<span class="hljs-built_in">push_back</span>(&#123;u, w&#125;);<br>    &#125;<br>    <span class="hljs-built_in">dfs</span>(<span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-function">vector&lt;trie&gt; <span class="hljs-title">t</span><span class="hljs-params">(<span class="hljs-number">2</span>, trie(<span class="hljs-number">30</span>, n))</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        t[dp[i]].<span class="hljs-built_in">add</span>(x[i]);<br>    &#125;<br>    <span class="hljs-keyword">while</span> (m--) &#123;<br>        <span class="hljs-type">char</span> c;<br>        cin &gt;&gt; c;<br>        <span class="hljs-keyword">if</span> (c == <span class="hljs-string">&#x27;^&#x27;</span>) &#123;<br>            <span class="hljs-type">int</span> y;<br>            cin &gt;&gt; y;<br>            gx ^= y;<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">int</span> a, b;<br>            cin &gt;&gt; a &gt;&gt; b;<br>            t[dp[a]].<span class="hljs-built_in">remove</span>(x[a]);<br>            <span class="hljs-type">int</span> same_group = t[dp[a]].<span class="hljs-built_in">find_max</span>(x[a] ^ b);<br>            <span class="hljs-type">int</span> diff_group = t[<span class="hljs-number">1</span> - dp[a]].<span class="hljs-built_in">find_max</span>(x[a] ^ b ^ gx);<br>            t[dp[a]].<span class="hljs-built_in">add</span>(x[a]);<br>            cout &lt;&lt; <span class="hljs-built_in">max</span>(same_group, diff_group) &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="conclusion"><a class="markdownIt-Anchor" href="#conclusion"></a> Conclusion</h2><p>太久没打脑袋不灵光。。但是d和e如果写过的话是可以做的，确实不难。没想到三个题也能加几分，下次再练练。</p>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>sortings</tag>
      
      <tag>constructive algorithms</tag>
      
      <tag>number theory</tag>
      
      <tag>implementation</tag>
      
      <tag>data structures</tag>
      
      <tag>dfs and similar</tag>
      
      <tag>bitmasks</tag>
      
      <tag>graphs</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture3</title>
    <link href="/2024/06/07/%E7%AC%AC%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%EF%BC%88Part%201%EF%BC%89/"/>
    <url>/2024/06/07/%E7%AC%AC%E4%B8%89%E8%AF%BE%EF%BC%9A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%EF%BC%88Part%201%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第三课数据库存储part-1"><a class="markdownIt-Anchor" href="#第三课数据库存储part-1"></a> 第三课：数据库存储（Part 1）</h1><h2 id="1-存储"><a class="markdownIt-Anchor" href="#1-存储"></a> 1 存储</h2><hr /><p>我们将专注于以磁盘为导向的DBMS架构，假设数据库的主要存储位置在非易失性磁盘上。</p><p>在存储层次的顶部，你拥有离CPU最近的设备。这是最快的存储设备，但也是最小和最昂贵的。离CPU越远，存储设备越大但速度越慢。这些设备的每GB价格也越便宜。</p><p>易失性设备：</p><ul><li>易失性意味着如果你将设备断电，那么数据将丢失。</li><li>易失性存储支持快速的随机访问，并且具有以字节为寻址单位的位置。这意味着程序可以跳转到任何字节地址并获取那里的数据。</li><li>对于我们的目的，我们将始终将这种存储类型称为“内存”。</li></ul><p>非易失性设备</p><ul><li>非易失性意味着存储设备不需要持续供电才能保留其存储的位。</li><li>它也是块/页可寻址的。这意味着为了在特定偏移处读取一个值，程序首先必须将包含程序想要读取的值的4KB页面加载到内存中。</li><li>非易失性存储在顺序访问方面传统上更好（同时读取多个连续数据块）。</li><li>我们将其称为“磁盘”。我们不会在固态存储（SSD）和旋转硬盘（HDD）之间进行（重大）区分。</li></ul><p>还有一种相对较新的存储设备正在变得越来越受欢迎，被称为非易失性内存。这些设备旨在兼具DRAM的速度和磁盘的持久性，可谓兼具两者之优势。我们在这门课程中不涉及这些设备，并且目前尚未广泛使用于生产中。可能最著名的例子是Optane；不幸的是，英特尔在2022年夏天停止生产该产品。请注意，您可能会在之前的参考资料中看到将非易失性内存称为“非挥发性内存”的说法。</p><p>你可能会看到关于NVMe SSD的参考资料，其中NVMe代表非易失性内存扩展。这些NVMe SSD与持久内存模块不是同一种硬件。相反，它们是通过改进的硬件接口连接的典型闪存驱动器。这种改进的硬件接口允许更快的传输速度，利用了NAND闪存性能的改进。</p><p>由于我们的DBMS架构假设数据库存储在磁盘上，DBMS的组件负责确定如何在非易失性磁盘和易失性内存之间传输数据，因为系统不能直接在磁盘上操作数据。</p><p>我们将重点放在隐藏磁盘延迟上，而不是寄存器和缓存的优化，因为从磁盘获取数据非常慢。如果从L1缓存引用中读取数据需要1秒钟的时间，而从SSD读取数据需要4.4小时，从HDD读取数据需要3.3周的时间。</p><h2 id="2-基于磁盘的dbms概述"><a class="markdownIt-Anchor" href="#2-基于磁盘的dbms概述"></a> 2 基于磁盘的DBMS概述</h2><hr /><p>数据库全部存储在磁盘上，数据库文件中的数据被组织成页，第一页是目录页。为了对数据进行操作，数据库管理系统需要将数据加载到内存中。它通过拥有一个缓冲池来管理磁盘和内存之间的数据传输。DBMS还拥有一个执行引擎来执行查询。执行引擎会向缓冲池请求特定的页，缓冲池会负责将该页加载到内存中并向执行引擎提供该页在内存中的指针。缓冲池管理器将确保在执行引擎在内存中操作该部分时，该页存在。</p><h2 id="3-dbms-vs-os"><a class="markdownIt-Anchor" href="#3-dbms-vs-os"></a> 3 DBMS vs OS</h2><hr /><p>DBMS的一个高级设计目标是支持超过可用内存的数据库。由于读写磁盘是昂贵的，必须仔细管理磁盘使用。我们不希望从磁盘获取数据时出现大的停顿，从而导致其他事务减缓。我们希望DBMS能够在等待从磁盘获取数据时处理其他查询。</p><p>这个高级设计目标类似于虚拟内存，其中有一个大的地址空间和一个能够从磁盘上载入页面的操作系统位置。</p><p>实现虚拟内存的一种方法是使用mmap将文件的内容映射到进程的地址空间中，这使得操作系统负责在磁盘和内存之间移动页面。然而，不幸的是，如果mmap遇到也错误，进程将被阻塞。</p><ul><li>如果你需要写入，就不应该在你的数据库管理系统中使用mmap。</li><li>数据库管理系统（几乎）总是希望自己控制事物，并且在这方面做得更好，因为它对所访问的数据和正在处理的查询有更多了解。</li><li>操作系统不是你的朋友。</li></ul><p>可以通过以下方式使用操作系统：</p><ul><li>madvise：告诉操作系统你计划何时读取某些页面。</li><li>mlock：告诉操作系统不要把内存范围交换到磁盘。</li><li>msync：告诉操作系统将内存范围刷新到磁盘。</li></ul><p>出于正确性和性能的原因，我们不建议在DBMS中使用mmap。</p><p>尽管系统可能具备类似操作系统提供的功能，但是将这些过程由DBMS自己实现可以给它带来更好的控制和性能。</p><h2 id="4-文件存储"><a class="markdownIt-Anchor" href="#4-文件存储"></a> 4 文件存储</h2><hr /><p>在最基本的形式中，数据库管理系统将数据库存储为磁盘上的文件。有些可能使用文件层次结构，而另一些可能使用单个文件（例如，SQLite）。</p><p>操作系统对这些文件的内容一无所知。只有数据库管理系统知道如何解读这些内容，因为它们是以特定于数据库管理系统的方式进行编码的。</p><p>DBMS 的存储管理器负责管理数据库的文件。它将文件表示为一个page的集合。它还跟踪哪些数据已被读取和写入页面以及这些页面中有多少可用空间。</p><h2 id="5-数据库页"><a class="markdownIt-Anchor" href="#5-数据库页"></a> 5 数据库页</h2><hr /><p>DBMS将数据库组织在一个或多个文件中，这些文件包含了称为页的固定大小的数据块。页可以包含不同类型的数据（元组、索引等）。大多数系统不会在页内混合使用这些类型。某些系统要求每个页都是自包含的，意味着读取每个页所需的所有信息都在页本身上。</p><p>每个页面都被赋予了一个唯一的标识符。如果数据库是一个单独的文件，那么页面ID可以直接是文件的偏移量。大多数数据库管理系统都有一个间接层，它将页面ID映射到文件路径和偏移量上。系统的上层将请求一个特定的页面编号。然后，存储管理器将把该页面编号转换成文件和偏移量以找到该页面。</p><p>大多数数据库管理系统使用固定大小的页面，以避免支持可变大小页面所需的工程开销。例如，对于可变大小的页面，删除一个页面可能会在数据库管理系统无法轻松填充新页面的文件中创建一个空洞。数据库管理系统中有三个页面的概念：</p><ol><li>硬件页面（通常为4 KB）。</li><li>操作系统页面（4 KB）。</li><li>数据库页面（1-16 KB）。</li></ol><p>存储设备保证以硬件页面大小的原子写入。如果硬件页面是4 KB，并且系统尝试将4 KB写入磁盘，要么全部写入4 KB，要么全部不写入。这意味着如果我们的数据库页面大于硬件页面，数据库管理系统将必须采取额外措施确保数据被安全地写出，因为在系统崩溃时，程序可能正在写入数据库页面的一部分到磁盘。</p><h2 id="6-数据库堆"><a class="markdownIt-Anchor" href="#6-数据库堆"></a> 6 数据库堆</h2><hr /><p>有几种方法可以找到DBMS希望在磁盘上找到的页面位置，堆文件组织就是其中一种方法。堆文件是一个无序的页面集合，其中元组以随机顺序存储。DBMS可以通过使用页面链表或页面目录来根据页面ID在磁盘上定位一个页面。</p><ol><li>页面链表：头页面保存了指向空闲页列表和数据页列表的指针。然而，如果DBMS正在寻找特定的页面，它必须在数据页列表上进行顺序扫描，直到找到所需的页面为止。</li><li>页面目录：DBMS维护特殊页面，跟踪数据页面的位置以及每个页面上的空闲空间量。</li></ol><h2 id="7-页面布局"><a class="markdownIt-Anchor" href="#7-页面布局"></a> 7 页面布局</h2><hr /><p>每个页面都包含一个头，记录页面内容的元数据信息：</p><ul><li>页面大小</li><li>校验数</li><li>DBMS版本</li><li>事务可见度</li><li>自包含性。（一些系统如Oracle需要这个特性。）</li></ul><p>一种针对数据布局的稻草人方法是跟踪DBMS存储的元组数量，并在每次添加新元组时将其追加到末尾。然而，当元组被删除或者元组具有可变长度的属性时，问题就会出现。</p><p>有两种主要的数据布局方法：（1）使用插槽页面和（2）日志结构。</p><p>插槽页面：页面将插槽映射到偏移量上。</p><ul><li>是目前在DBMS中最常用的方法。</li><li>页眉保存了已使用插槽的数量、最后一个已使用插槽的起始位置的偏移量以及插槽数组，用于跟踪每个元组的起始位置。</li><li>要添加一个元组，插槽数组将从开始位置增长到结束位置，元组的数据将从结束位置增长到开始位置。当插槽数组和元组数据相遇时，页面被视为已满。</li></ul><p>日志结构：在下一节讲述。</p><h2 id="8-元组布局"><a class="markdownIt-Anchor" href="#8-元组布局"></a> 8 元组布局</h2><hr /><p>元组实质上是一系列字节的序列。DBMS的工作是将这些字节解释为属性类型和值。</p><p>元组头：包含关于元组的元数据。</p><ul><li>DBMS并发控制协议的可见性信息（即，哪个事物创建/修改了该元组的信息）。</li><li>NULL值的位图</li><li>注意，DBMS不需要在这里存储有关数据库模式的元数据。</li></ul><p>元组数据：属性的实际数据</p><ul><li>属性通常按照创建表时指定的顺序存储。</li><li>大多数DBMS不允许元组的大小超过一个页面的大小。</li></ul><p>唯一标识符：</p><ul><li>数据库中的每个元组都被分配一个唯一标识符。</li><li>最常见的是页面Id+（偏移量或插槽）</li><li>应用程序不能依赖这些ID标识任何含义。</li></ul><p>无规范化的元组数据：如果两个表相关，则DBMS可以“预连接”它们，使两个表位于同一页上。这样可以提高读取速度，因为DBMS只需加载一页而不是两个单独的页面。但是这样会增加更新的成本，因为DBMS需要更多的空间来存储每个元组。</p>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>存储设备</tag>
      
      <tag>易失性内存</tag>
      
      <tag>非易失性存储</tag>
      
      <tag>缓冲池</tag>
      
      <tag>页面布局</tag>
      
      <tag>文件存储</tag>
      
      <tag>数据库页</tag>
      
      <tag>元组布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>茶6.3-6.7</title>
    <link href="/2024/06/07/%E8%8C%B66.3-6.7/"/>
    <url>/2024/06/07/%E8%8C%B66.3-6.7/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶63-67"><a class="markdownIt-Anchor" href="#茶63-67"></a> 茶6.3-6.7</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> <strong>Mon</strong></h2><p><a href="https://codeforces.com/problemset/problem/1873/F">Money Trees_898F</a></p><p>输入 T(≤1e3) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤2e5) k(1≤k≤1e9) 和长为 n 的数组 a(1≤a[i]≤1e4)，长为 n 的数组 h(1≤h[i]≤1e9)。</p><p>选一个子区间 [L,R]，对于 [L,R-1] 内的 i，满足 h[i] 是 h[i+1] 的倍数，且 a[L] + a[L+1] + … + a[R] 不超过 k。<br />输出子区间长度 R-L+1 的最大值。<br />如果没有这样的子区间，输出 0。</p><p>输入<br />5<br />5 12<br />3 2 4 1 8<br />4 4 2 4 1<br />4 8<br />5 4 1 2<br />6 2 3 1<br />3 12<br />7 9 10<br />2 2 4<br />1 10<br />11<br />1<br />7 10<br />2 6 3 1 5 10 6<br />72 24 24 12 4 4 2<br />输出<br />3<br />2<br />1<br />0<br />3</p><p><strong>Sol:</strong></p><p>分组循环+不定长滑窗。</p><p>分组循环求满足 h[i] 能被 h[i+1] 整除的组。</p><p>每组内用滑窗求元素和不超过 k 的最长子数组。  <a href="https://leetcode.cn/problems/longest-even-odd-subarray-with-threshold/solution/jiao-ni-yi-ci-xing-ba-dai-ma-xie-dui-on-zuspx/">分组循环</a></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k;<br>    cin &gt;&gt; n &gt;&gt; k;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span>,<span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin &gt;&gt; b[i];<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n;) &#123;<br>        <span class="hljs-type">int</span> st = i;<br>        <span class="hljs-keyword">for</span>(i++; i &lt; n &amp;&amp; b[i - <span class="hljs-number">1</span>] % b[i] == <span class="hljs-number">0</span>; i++) &#123;<br>        &#125;<br>        <span class="hljs-comment">//cout &lt;&lt; &quot;st:&quot;&lt;&lt; st &lt;&lt;&quot; i :&quot;&lt;&lt; i &lt;&lt; endl;</span><br>        <span class="hljs-function">vi <span class="hljs-title">c</span><span class="hljs-params">(a.begin() + st, a.begin() + i)</span></span>;<br>        <span class="hljs-type">int</span> l = <span class="hljs-number">0</span>, s = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> r = <span class="hljs-number">0</span>; r &lt; c.<span class="hljs-built_in">size</span>(); r++) &#123;<br>            s += c[r];<br>            <span class="hljs-keyword">while</span> (s &gt; k) &#123;<br>                s -= c[l];<br>                l++;<br>            &#125;<br>            ans = <span class="hljs-built_in">max</span>(ans, r - l + <span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue"><a class="markdownIt-Anchor" href="#tue"></a> <strong>Tue</strong></h2><p><a href="https://codeforces.com/problemset/problem/985/C">Liebig’s Barrels_985C</a></p><p>输入 n k(1≤n,k≤1e5 且 1≤n<em>k≤1e5) L(0≤L≤1e9) 和长为 n</em>k 的数组 a(1≤a[i]≤1e9)，表示 n*k 条木板的长度。</p><p>你要制作 n 个木桶，每个木桶需要 k 条木板。<br />你可以使用任意 k 条木板来组装一个木桶，每条木板必须恰好属于一个木桶。<br />一个木桶的体积，等于其最短木板的长度。</p><p>要求：任意一对木桶的体积差都不能超过 L。<br />输出所有木桶体积和的最大值。<br />如果无法满足，输出 0。</p><p>输入<br />4 2 1<br />2 2 1 2 3 2 2 3<br />输出 7</p><p>输入<br />2 1 0<br />10 10<br />输出 20</p><p>输入<br />1 2 1<br />5 2<br />输出 2</p><p>输入<br />3 2 1<br />1 2 3 4 5 6<br />输出 0</p><p><strong>Sol:</strong></p><p>贪心，先将木板排序，最小的木桶肯定是a[0]，那么我们最多能选到长度为a[0]+l的木板。如果数量不足n个，则无法满足，若是多余n个，则可以让小的木桶带几个小的木板，以增加最终体积的最大值。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,k,l;<br>    cin&gt;&gt;n&gt;&gt;k&gt;&gt;l;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n*k)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n*k;i++) cin&gt;&gt;a[i];<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-type">int</span> rg = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">upper_bound</span>(a.<span class="hljs-built_in">begin</span>(), a.<span class="hljs-built_in">end</span>(), a[<span class="hljs-number">0</span>] + l) - a.<span class="hljs-built_in">begin</span>());<br>    <span class="hljs-keyword">if</span> (rg &lt; n) &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;0&quot;</span> &lt;&lt; endl;<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> u = <span class="hljs-number">0</span>;<br>    ll ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        ans += a[u++];<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;j &lt; k - <span class="hljs-number">1</span>; j++) &#123;<br>            <span class="hljs-keyword">if</span> (rg - u &gt; n - i - <span class="hljs-number">1</span>) &#123;<br>                u++;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/898/D">Alarm Clock_451D</a></p><p>输入 n(1≤n≤2e5) m(1≤m≤1e6) k(1≤k≤n) 和长为 n 的数组 a(1≤a[i]≤1e6)。</p><p>数轴上有 n 个点，要求任意长为 m-1 的闭区间不能包含 &gt;= k 个点。<br />问：至少要去掉多少个点？</p><p>注：闭区间 [L,R] 的长度为 R-L。</p><p>输入<br />3 3 2<br />3 5 1<br />输出 1</p><p>输入<br />5 10 3<br />12 8 18 25 1<br />输出 0</p><p>输入<br />7 7 2<br />7 3 4 1 6 5 2<br />输出 6</p><p>输入<br />2 2 2<br />1 3<br />输出 0</p><p><strong>Sol:</strong></p><p>首先，我们需要按照时间递增的顺序对所有闹钟进行排序。我们还将使用 queue 来存储闹钟时间。</p><p>我们将从第一个警报开始迭代。设当前闹钟时间等于x。在 set 不为空并且第一个集合元素小于 x - m + 1 之前，我们应该删除第一个集合元素。此后，只有时间不早于相对 x 的 m - 1 分钟的警报才会被设置。如果之后集合大小小于 k - 1，我们应该在集合中插入 x （我们不会关闭此警报）。在另一种情况下，我们应该关闭此警报，因此我们增加一个答案，并且不在集合中插入 x。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m, k;<br>    cin &gt;&gt; n &gt;&gt; m &gt;&gt; k;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    <span class="hljs-built_in">sort</span>(a);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    queue&lt;<span class="hljs-type">int</span>&gt; q;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-type">int</span> now = a[i];<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; q.<span class="hljs-built_in">front</span>() &lt; now - m + <span class="hljs-number">1</span>) &#123;<br>            q.<span class="hljs-built_in">pop</span>();<br>        &#125;<br>        <span class="hljs-keyword">if</span> (q.<span class="hljs-built_in">size</span>() &gt;= k<span class="hljs-number">-1</span>) &#123;<br>            ans++;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            q.<span class="hljs-built_in">push</span>(now);<br>        &#125;<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/problemset/problem/264/C">Choosing Balls_162C</a></p><p>输入 n(1≤n≤1e5) q(1≤q≤500) 和长为 n 的数组 v(-1e5≤v[i]≤1e5)，长为 n 的数组 c(1≤c[i]≤n)。<br />有 n 个球排成一排，第 i 个球的价值为 v[i]，颜色为 c[i]。</p><p>然后输入 q 个询问，每个询问输入 a 和 b，范围 [-1e5,1e5]。<br />对每个询问，计算：<br />从这一排球中，选出一个子序列，子序列的价值和为：</p><ul><li>如果球不在序列开头，且球的颜色与前一个球的颜色相同，则加上球的值 * a。</li><li>否则，加上球的值 * b。<br />输出子序列的价值和的最大值。<br />子序列可以是空的，此时价值和为 0。</li></ul><p>注：子序列不一定连续。</p><p>输入<br />6 3<br />1 -2 3 4 0 -1<br />1 2 1 2 1 1<br />5 1<br />-2 1<br />1 0<br />输出<br />20<br />9<br />4</p><p>输入<br />4 1<br />-3 6 -1 2<br />1 2 3 1<br />1 -1<br />输出<br />5</p><p><strong>Sol:</strong></p><p>每个询问跑一个 O(n) 的子序列 DP。</p><p>提示：想一想，如果只有两种颜色，要如何 DP？</p><p>遍历到第 i 个球时，我们需要维护以颜色 c 结尾的子序列的最大价值和，定义为 f[c]，初始全为 -inf。</p><p>对于每个球，有四种决策：</p><ol><li><p>不选：f[c] 不变。</p></li><li><p>选，且和前一个球颜色一样：f[c] += v*a。</p></li><li><p>选，且和前一个球颜色不一样：我们需要知道颜色不等于 c 的最大 f，记作 f[mxC]。具体分析见下。</p></li><li><p>选，作为子序列第一个数：f[c] = v*b。</p></li></ol><p>对于第三个决策，我们需要维护 f 的最大值 mx1、最大值对应的颜色 mxC，以及 f 的颜色不等于 mxC 的最大值 mx2。 如果 c != mxC，那么 f[c] = mx1 + v * b，否则 f[c] = mx2 + v * b。 最后答案为 mx1。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, q, a, b, mx;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-function">vector&lt;pii&gt; <span class="hljs-title">ps</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; ps[i].first;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin &gt;&gt; ps[i].second;<br>    &#125;<br>    <span class="hljs-function">vi <span class="hljs-title">f</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; q; i++) &#123;<br>        cin &gt;&gt; a &gt;&gt; b;<br>        <span class="hljs-built_in">fill</span>(<span class="hljs-built_in">all</span>(f), <span class="hljs-number">-1e18</span>);<br>        <span class="hljs-type">int</span> mx1 = <span class="hljs-number">0</span>, mx2 = <span class="hljs-number">0</span>, mxC = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>            <span class="hljs-type">int</span> c = ps[j].second;<br>            <span class="hljs-keyword">if</span> (c != mxC) &#123;<br>                mx = mx1;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                mx = mx2;<br>            &#125;<br>            f[c] = <span class="hljs-built_in">max</span>(f[c] + <span class="hljs-built_in">max</span>(ps[j].first * a, <span class="hljs-number">0</span>), mx + ps[j].first * b);<br>            <span class="hljs-keyword">if</span> (f[c] &gt; mx1) &#123;<br>                <span class="hljs-keyword">if</span> (c != mxC) &#123;<br>                    mx2 = mx1;<br>                    mxC = c;<br>                &#125;<br>                mx1 = f[c];<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (c != mxC &amp;&amp; f[c] &gt; mx2) &#123;<br>                mx2 = f[c];<br>            &#125;<br>        &#125;<br>        cout &lt;&lt; mx1 &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/650/D">https://codeforces.com/problemset/problem/650/D</a></p><p>输入 n(1≤n≤4e5) m(1≤m≤4e5) 和长为 n 的数组 a(1≤a[i]≤1e9)，数组下标从 1 开始。<br />然后输入 m 个询问，每个询问输入两个数 i(1≤i≤n) 和 b(1≤b≤1e9)。</p><p>对于每个询问，输出把 a[i] 替换成 b 后，a 的最长严格递增子序列（LIS）的长度。<br />注意每个询问之间彼此独立，比如第一个询问把 a[1] 替换成 6，那么对于第二个询问，a[1] 还是原来的值。</p><p>输入<br />4 4<br />1 2 3 4<br />1 1<br />1 4<br />4 3<br />4 5<br />输出<br />4<br />3<br />3<br />4</p><p>输入<br />4 2<br />1 3 2 6<br />3 5<br />2 4<br />输出<br />4<br />3</p><p><strong>Sol：</strong></p><p>上周五的 CF486E，需要用到这题的结论。</p><p>修改后的 LIS，有两种情况：</p><ol><li>LIS 不包含修改后的 a[i]，那么计算的就是原数组去掉 a[i] 后的 LIS 长度。</li><li>LIS 包含修改后的 a[i]。 这两种情况取 max 即为答案。</li></ol><p>第一种情况的计算方法：</p><p>设原数组的 LIS 长度为 k。</p><p>用上周五（CF486E）的结论，如果原数组的 a[i] 在所有 LIS 中，则去掉 a[i] 后，LIS 长度缩小，即 k-1；否则 LIS 长度不变，仍然为 k。</p><p>注意，为了判断这件事，需要正着计算一遍所有前缀的 LIS 长度，再反着计算所有后缀的 LIS 长度。</p><p>第二种情况的计算方法：</p><p>（先把询问离线，按照修改的下标分组）</p><p>上面说到，我们需要计算所有前缀/后缀的 LIS 长度，这用的是二分算法，会用到一个辅助数组 g，其中 g[i] 等于长为 i 的上升子序列的末尾元素的最小值。</p><p>正序遍历到 a[i] 时，先对所有在 i 处的询问，在 g 数组上二分查找 b，算出 LIS 中小于 b 的元素个数，加到答案中，然后答案再加一（把 b 算进去）。</p><p>倒序遍历到 a[i] 时，先对所有在 i 处的询问，在 g 数组上二分查找 b，算出 LIS 中大于 b 的元素个数，加到答案中。 这样我们就得到了包含 a[i]=b 的 LIS 长度。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, m;<br>    cin &gt;&gt; n &gt;&gt; m;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-built_in">FOR</span>(i, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>) cin &gt;&gt; a[i];<br>    vector&lt;vector&lt;pair&lt;<span class="hljs-type">int</span>, <span class="hljs-type">int</span>&gt; &gt; &gt; <span class="hljs-built_in">qs</span>(n);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; m; i++) &#123;<br>        <span class="hljs-type">int</span> j, v;<br>        cin &gt;&gt; j &gt;&gt; v;<br>        qs[j<span class="hljs-number">-1</span>].<span class="hljs-built_in">push_back</span>(&#123;i, v&#125;);<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">ans</span><span class="hljs-params">(m)</span></span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">pre</span><span class="hljs-params">(n)</span></span>;<br>    vector&lt;<span class="hljs-type">int</span>&gt; g;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : qs[i]) &#123;<br>            ans[p.first] = <span class="hljs-built_in">lower_bound</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>(), p.second) - g.<span class="hljs-built_in">begin</span>() + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">lower_bound</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>(), a[i]) - g.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">if</span> (p &lt; g.<span class="hljs-built_in">size</span>()) &#123;<br>            g[p] = a[i];<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            g.<span class="hljs-built_in">push_back</span>(a[i]);<br>        &#125;<br>        pre[i] = p + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">suf</span><span class="hljs-params">(n)</span></span>;<br>    g.<span class="hljs-built_in">clear</span>();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : qs[i]) &#123;<br>            ans[p.first] += <span class="hljs-built_in">lower_bound</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>(), -p.second) - g.<span class="hljs-built_in">begin</span>();<br>        &#125;<br>        <span class="hljs-type">int</span> v = -a[i];<br>        <span class="hljs-type">int</span> p = <span class="hljs-built_in">lower_bound</span>(g.<span class="hljs-built_in">begin</span>(), g.<span class="hljs-built_in">end</span>(), v) - g.<span class="hljs-built_in">begin</span>();<br>        <span class="hljs-keyword">if</span> (p &lt; g.<span class="hljs-built_in">size</span>()) &#123;<br>            g[p] = v;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            g.<span class="hljs-built_in">push_back</span>(v);<br>        &#125;<br>        suf[i] = p + <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-type">int</span> lis = g.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">cnt</span><span class="hljs-params">(n+<span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (pre[i] + suf[i] - <span class="hljs-number">1</span> == lis) &#123;<br>            cnt[pre[i]]++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> k = lis;<br>        <span class="hljs-keyword">if</span> (pre[i] + suf[i] - <span class="hljs-number">1</span> == lis &amp;&amp; cnt[pre[i]] == <span class="hljs-number">1</span>) &#123;<br>            k--;<br>        &#125;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> p : qs[i]) &#123;<br>            ans[p.first] = <span class="hljs-built_in">max</span>(ans[p.first], k);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v : ans) &#123;<br>        cout &lt;&lt; v &lt;&lt; endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Subsequence</tag>
      
      <tag>Binary Search</tag>
      
      <tag>Sorting</tag>
      
      <tag>Offline Queries</tag>
      
      <tag>Sliding Window</tag>
      
      <tag>Subarray Sum</tag>
      
      <tag>Greedy</tag>
      
      <tag>Array Manipulation</tag>
      
      <tag>Queue</tag>
      
      <tag>Interval Problem</tag>
      
      <tag>Longest Increasing Subsequence (LIS)</tag>
      
      <tag>Data Structures</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture2</title>
    <link href="/2024/06/06/%E7%AC%AC%E4%BA%8C%E8%AF%BE%EF%BC%9A%E7%8E%B0%E4%BB%A3SQL/"/>
    <url>/2024/06/06/%E7%AC%AC%E4%BA%8C%E8%AF%BE%EF%BC%9A%E7%8E%B0%E4%BB%A3SQL/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第二课现代sql"><a class="markdownIt-Anchor" href="#第二课现代sql"></a> 第二课：现代SQL</h1><h2 id="1-关系语言"><a class="markdownIt-Anchor" href="#1-关系语言"></a> 1 关系语言</h2><hr /><p>埃德加·科德在20世纪70年代初发表了一篇关于关系模型的重要论文。起初，他只定义了数据库管理系统（DBMS）如何在关系模型上执行查询的数学表示。用户只需使用声明性语言（即SQL）指定他们想要的结果。DBMS负责确定生成该答案的最有效计划。关系代数基于集合（无序，无重复项）。SQL基于多重集（无序，允许重复项）。</p><h2 id="2-sql历史"><a class="markdownIt-Anchor" href="#2-sql历史"></a> 2 SQL历史</h2><hr /><p>关系数据库的声明式查询语言。它最初在1970年代作为IBM System R项目的一部分进行开发。IBM最初将其命名为“SEQUEL”（结构化英语查询语言）。该名称在1980年代更改为“SQL”（结构化查询语言）。</p><p>该语言由不同类型的命令组成：</p><ol><li>数据操作语言（DML）：SELECT、INSERT、UPDATE和DELETE语句。</li><li>数据定义语言（DDL）：用于定义表、索引、视图和其他对象的模式定义。</li><li>数据控制语言（DCL）：用于安全性和访问控制。</li></ol><p>SQL并不是一门死语言，它每隔几年都会更新新的功能。SQL-92是一个DBMS必须支持的最低标准，以便声称支持SQL。每个供应商在一定程度上遵循这个标准，但也存在许多专有扩展。</p><p>每个SQL标准新版发布时都会带来一些重大的更新，一些主要的更新如下所示：</p><ul><li>SQL:1999 正则表达式、触发器</li><li>SQL:2003 XML、Windows、序列</li><li>SQL:2008 截断、高级排序</li><li>SQL:2011 时态数据库、通道化DML</li><li>SQL:2016 JSON、多态表</li></ul><h2 id="3-joins"><a class="markdownIt-Anchor" href="#3-joins"></a> 3 Joins</h2><hr /><p>合并一个或多个表的列，生成一个新的表。用于表示涉及跨多个表的数据的查询。</p><p>例如：哪些学生在15-721课程中得到了A？</p><p>示例数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> student ( <br>sid <span class="hljs-type">INT</span> <span class="hljs-keyword">PRIMARY</span> KEY, <br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">16</span>), <br>login <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">UNIQUE</span>, <br>age <span class="hljs-type">SMALLINT</span>, <br>gpa <span class="hljs-type">FLOAT</span> <br>); <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> course ( <br>cid <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">PRIMARY</span> KEY, <br>name <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">NULL</span> <br>); <br><span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TABLE</span> enrolled ( <br>sid <span class="hljs-type">INT</span> <span class="hljs-keyword">REFERENCES</span> student (sid), <br>cid <span class="hljs-type">VARCHAR</span>(<span class="hljs-number">32</span>) <span class="hljs-keyword">REFERENCES</span> course (cid), <br>grade <span class="hljs-type">CHAR</span>(<span class="hljs-number">1</span>) <br>); <br></code></pre></td></tr></table></figure><p>查询：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> s.name<br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> e, student <span class="hljs-keyword">AS</span> s<br><span class="hljs-keyword">WHERE</span> e.grade <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;A&#x27;</span> <span class="hljs-keyword">AND</span> e.cid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;15-721&#x27;</span><br><span class="hljs-keyword">AND</span> e.sid <span class="hljs-operator">=</span> s.sid;<br></code></pre></td></tr></table></figure><h2 id="4-聚合"><a class="markdownIt-Anchor" href="#4-聚合"></a> 4 聚合</h2><hr /><p>聚合函数以元组的包作为输入，然后产生一个标量值作为输出。聚合函数几乎只能在SELECT输出列表中使用。</p><ul><li>AVG（COL）：COL中值的平均值</li><li>MIN（COL）：COL中的最小值</li><li>MAX（COL）：COL中的最大值</li><li>COUNT（COL）：关系中元组的数量</li></ul><p>示例：获取以‘@cs’登录名的学生人数。</p><p>以下三个查询是等价的：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-operator">*</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> login <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(login) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> login <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>; <br><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-number">1</span>) <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> login <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>; <br></code></pre></td></tr></table></figure><p>单个 SELECT 语句可以包含多个聚合：</p><p>示例：使用“@cs”登录获取学生数量及其平均 GPA。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(gpa), <span class="hljs-built_in">COUNT</span>(sid) <br><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> login <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>; <br></code></pre></td></tr></table></figure><p>一些聚合函数（例如COUNT,SUM,AVG）支持DISTINCT关键字：</p><p>示例：通过’@cs’登录获取独特学生数量和他们的平均GPA。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">COUNT</span>(<span class="hljs-keyword">DISTINCT</span> login) <br><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> login <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span>; <br></code></pre></td></tr></table></figure><p>聚合操作之外的其他列输出未定义（在下面的示例中e.cid未定义）。</p><p>示例：获取每门课程中学生的平均GPA。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa), e.cid <br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> e, student <span class="hljs-keyword">AS</span> s <br><span class="hljs-keyword">WHERE</span> e.sid <span class="hljs-operator">=</span> s.sid; <br></code></pre></td></tr></table></figure><p>在SELECT输出子句中的非聚合值必须出现在GROUP BY子句中。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa), e.cid <br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> e, student <span class="hljs-keyword">AS</span> s <br><span class="hljs-keyword">WHERE</span> e.sid <span class="hljs-operator">=</span> s.sid <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.cid; <br></code></pre></td></tr></table></figure><p>HAVING子句根据聚合计算结果对输出结果进行过滤。这使得HAVING的行为类似于GROUP BY的WHERE子句。示例：获取平均学生GPA大于3.9的课程集合。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa) <span class="hljs-keyword">AS</span> avg_gpa, e.cid <br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> e, student <span class="hljs-keyword">AS</span> s <br><span class="hljs-keyword">WHERE</span> e.sid <span class="hljs-operator">=</span> s.sid <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.cid <br><span class="hljs-keyword">HAVING</span> avg_gpa <span class="hljs-operator">&gt;</span> <span class="hljs-number">3.9</span>; <br></code></pre></td></tr></table></figure><p>上述查询语法被许多主要的数据库系统支持，但不符合SQL标准。要使查询符合标准，我们必须在HAVING子句的主体中重复使用AVG(S.GPA)。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">AVG</span>(s.gpa), e.cid <br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">AS</span> e, student <span class="hljs-keyword">AS</span> s <br><span class="hljs-keyword">WHERE</span> e.sid <span class="hljs-operator">=</span> s.sid <br><span class="hljs-keyword">GROUP</span> <span class="hljs-keyword">BY</span> e.cid <br><span class="hljs-keyword">HAVING</span> <span class="hljs-built_in">AVG</span>(s.gpa) <span class="hljs-operator">&gt;</span> <span class="hljs-number">3.9</span>; <br></code></pre></td></tr></table></figure><h2 id="5-字符串操作"><a class="markdownIt-Anchor" href="#5-字符串操作"></a> 5 字符串操作</h2><hr /><p>SQL标准规定字符串是区分大小写且只能用单引号括起来。在查询的任何部分中可以使用用于操作字符串的函数。模式匹配：LIKE关键字用于谓词中的字符串匹配。</p><ul><li>“%”匹配任何子字符串（包括空字符串）。</li><li>“_”匹配任何一个字符。</li></ul><p><strong>字符串函数</strong> SQL-92定义了字符串函数。许多数据库系统除了标准函数外还实现了其他函数。标准字符串函数的例子包括SUBSTRING(S, B, E)和UPPER(S)。</p><p>**连接：**两个竖杠（“||”）将两个或多个字符串连接成一个字符串。</p><h2 id="6-日期和时间"><a class="markdownIt-Anchor" href="#6-日期和时间"></a> 6 日期和时间</h2><hr /><p>操作日期和时间属性的操作。可用于输出或谓词。关于日期和时间操作的具体语法在不同的系统之间差异很大。</p><h2 id="7-输出重定向"><a class="markdownIt-Anchor" href="#7-输出重定向"></a> 7 输出重定向</h2><hr /><p>可以让数据库管理系统将查询结果存储到另一个表中，而不是将结果返回给客户端（例如终端）。然后，您可以在后续查询中访问这些数据。</p><ul><li>**新表：**将查询的输出存入一个新表中</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> cid <span class="hljs-keyword">INTO</span> CourseIds <span class="hljs-keyword">FROM</span> enrolled; <br></code></pre></td></tr></table></figure><ul><li>**已存在的表：**将查询的输出存储到数据库中已存在的表中。目标表必须与目标表具有相同数量的列和相同的数据类型，但是输出查询中的列名不必匹配。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">INTO</span> CourseIds (<span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">DISTINCT</span> cid <span class="hljs-keyword">FROM</span> enrolled); <br></code></pre></td></tr></table></figure><h2 id="8-输出控制"><a class="markdownIt-Anchor" href="#8-输出控制"></a> 8 输出控制</h2><hr /><p>由于结果集中的SQL是无序的，我们必须使用ORDER BY子句来对元组进行排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sid, grade <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">WHERE</span> cid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;15-721&#x27;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade; <br></code></pre></td></tr></table></figure><p>默认的排序顺序是升序（ASC）。我们可以手动指定DESC来反转顺序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sid, grade <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">WHERE</span> cid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;15-721&#x27;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>; <br></code></pre></td></tr></table></figure><p>我们可以使用多个ORDER BY子句来打破平局或进行更复杂的排序：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sid, grade <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">WHERE</span> cid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;15-721&#x27;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">DESC</span>, sid <span class="hljs-keyword">ASC</span>; <br></code></pre></td></tr></table></figure><p>在ORDER BY子句中，我们还可以使用任意的表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sid <span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">WHERE</span> cid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;15-721&#x27;</span> <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> <span class="hljs-built_in">UPPER</span>(grade) <span class="hljs-keyword">DESC</span>, sid <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">ASC</span>; <br></code></pre></td></tr></table></figure><p>默认情况下，DBMS 将返回查询生成的所有元组。我们可以使用 LIMIT 子句来限制结果元组的数量：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sid, name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> login <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span> <br>LIMIT <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><p>我们还可以提供一个偏移量来返回结果中的一段范围：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> sid, name <span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">WHERE</span> login <span class="hljs-keyword">LIKE</span> <span class="hljs-string">&#x27;%@cs&#x27;</span> <br>LIMIT <span class="hljs-number">20</span> <span class="hljs-keyword">OFFSET</span> <span class="hljs-number">10</span>; <br></code></pre></td></tr></table></figure><p>除非我们在LIMIT中使用ORDER BY子句，否则数据库管理系统在每次调用查询时可能会产生不同的结果元组，因为关系模型不强制排序。</p><h2 id="9-嵌套查询"><a class="markdownIt-Anchor" href="#9-嵌套查询"></a> 9 嵌套查询</h2><hr /><p>在单个查询中调用其他查询来执行更复杂的逻辑。嵌套查询通常很难优化。</p><p>外部查询的范围包括内部查询（即内部查询可以访问外部查询的属性），但反过来则不行。</p><p>内部查询可以出现在查询的几乎任何部分中：</p><ol><li><p>选择输出目标</p><figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs n1ql"><span class="hljs-keyword">SELECT</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>) <span class="hljs-keyword">AS</span> one <span class="hljs-keyword">FROM</span> student; <br></code></pre></td></tr></table></figure></li><li><p>FROM从句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <br><span class="hljs-keyword">FROM</span> student <span class="hljs-keyword">AS</span> s, (<span class="hljs-keyword">SELECT</span> sid <span class="hljs-keyword">FROM</span> enrolled) <span class="hljs-keyword">AS</span> e <br><span class="hljs-keyword">WHERE</span> s.sid <span class="hljs-operator">=</span> e.sid; <br></code></pre></td></tr></table></figure></li><li><p>WHERE从句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> student <br><span class="hljs-keyword">WHERE</span> sid <span class="hljs-keyword">IN</span> ( <span class="hljs-keyword">SELECT</span> sid <span class="hljs-keyword">FROM</span> enrolled ); <br></code></pre></td></tr></table></figure></li></ol><p>在“15-445”课程中注册的学生的姓名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> name <span class="hljs-keyword">FROM</span> student <br><span class="hljs-keyword">WHERE</span> sid <span class="hljs-keyword">IN</span> ( <br><span class="hljs-keyword">SELECT</span> sid <span class="hljs-keyword">FROM</span> enrolled <br><span class="hljs-keyword">WHERE</span> cid <span class="hljs-operator">=</span> <span class="hljs-string">&#x27;15-445&#x27;</span> <br>);<br></code></pre></td></tr></table></figure><p>注意，依据查询的位置不同，sid的范围也会有所不同。</p><p>例如：找到已经至少选修了一门课程的学生记录中id最高的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> student.sid, name <br><span class="hljs-keyword">FROM</span> student <br><span class="hljs-keyword">JOIN</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-built_in">MAX</span>(sid) <span class="hljs-keyword">AS</span> sid <br><span class="hljs-keyword">FROM</span> enrolled) <span class="hljs-keyword">AS</span> max_e <br>    <span class="hljs-keyword">ON</span> student.sid <span class="hljs-operator">=</span> max_e.sid;<br></code></pre></td></tr></table></figure><p>嵌套查询结果表达式：</p><ul><li>ALL（全部）：必须满足子查询中所有行的表达式。</li><li>ANY（任意）：必须至少满足子查询中的一行的表达式。</li><li>IN（在范围内）：等同于=ANY()。</li><li>EXISTS（存在）：至少返回一行。</li></ul><p>例子：找出所有没有学生注册的课程。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> course <br><span class="hljs-keyword">WHERE</span> <span class="hljs-keyword">NOT</span> <span class="hljs-keyword">EXISTS</span>( <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> enrolled <br><span class="hljs-keyword">WHERE</span> course.cid <span class="hljs-operator">=</span> enrolled.cid <br>); <br></code></pre></td></tr></table></figure><h2 id="10-窗口函数"><a class="markdownIt-Anchor" href="#10-窗口函数"></a> 10 窗口函数</h2><hr /><p>一个窗口函数在一组相关的元组上执行“滑动”计算，类似于聚合，但是元组并不被分组为单个输出元组。</p><p>函数：窗口函数可以是我们上面讨论过的任何聚合函数。还有一些特殊的窗口函数：</p><ol><li>ROW NUMBER：当前行的编号。</li><li>RANK：当前行的顺序位置。</li></ol><p>分组：通过OVER子句指定在计算窗口函数时如何将元组分组在一起。使用PARTITION BY来指定分组。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> cid, sid, <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cid) <br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cid; <br></code></pre></td></tr></table></figure><p>即使数据库在内部进行更改，我们也可以在OVER函数中添加ORDER BY来确保结果的确定性排序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, <span class="hljs-built_in">ROW_NUMBER</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cid) <br><span class="hljs-keyword">FROM</span> enrolled <span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> cid; <br></code></pre></td></tr></table></figure><p>重要提示：在窗口函数排序之后，DBMS会计算排名（RANK），而在排序之前，它会计算行号（ROW NUMBER）。</p><p>例如：找到每门课程中成绩第二高的学生。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> ( <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span>, <span class="hljs-built_in">RANK</span>() <span class="hljs-keyword">OVER</span> (<span class="hljs-keyword">PARTITION</span> <span class="hljs-keyword">BY</span> cid <br><span class="hljs-keyword">ORDER</span> <span class="hljs-keyword">BY</span> grade <span class="hljs-keyword">ASC</span>) <span class="hljs-keyword">AS</span> rank <br>    <span class="hljs-keyword">FROM</span> enrolled) <span class="hljs-keyword">AS</span> ranking <br><span class="hljs-keyword">WHERE</span> ranking.rank <span class="hljs-operator">=</span> <span class="hljs-number">2</span>; <br></code></pre></td></tr></table></figure><h2 id="11-通用表表达式"><a class="markdownIt-Anchor" href="#11-通用表表达式"></a> 11 通用表表达式</h2><p>在编写更复杂的查询时，通用表表达式 （CTE） 是窗口或嵌套查询的替代方法。它们提供了一种在更大的查询中为用户编写辅助语句的方法。CTE 可以被视为范围限定为单个查询的临时表。</p><p>WITH 子句将内部查询的输出绑定到具有该名称的临时结果。</p><p>示例：生成一个名为 cteName 的 CTE，其中包含单个元组，且单个属性设置为“1”。选择此 CTE 中的所有属性。 cteName。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cteName <span class="hljs-keyword">AS</span> ( <br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> <br>) <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cteName; <br></code></pre></td></tr></table></figure><p>我们可以在AS之前将输出列绑定到名称上。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cteName (col1, col2) <span class="hljs-keyword">AS</span> ( <br><span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span> <br>) <br><span class="hljs-keyword">SELECT</span> col1 <span class="hljs-operator">+</span> col2 <span class="hljs-keyword">FROM</span> cteName; <br></code></pre></td></tr></table></figure><p>一个查询可以包含多个CTE声明：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> cte1 (col1) <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span>), cte2 (col2) <span class="hljs-keyword">AS</span> (<span class="hljs-keyword">SELECT</span> <span class="hljs-number">2</span>) <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cte1, cte2; <br></code></pre></td></tr></table></figure><p>在WITH关键字后加上RECURSIVE关键字使得CTE能够引用其自身。这样可以在SQL查询中实现递归。通过递归CTE，SQL可以被证明是图灵完备的，这意味着它在计算表达能力上与更通用的编程语言一样强大（虽然可能稍微复杂一些）。</p><p>例如：打印从1到10的数字序列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">WITH</span> <span class="hljs-keyword">RECURSIVE</span> cteSource (counter) <span class="hljs-keyword">AS</span> ( <br>( <span class="hljs-keyword">SELECT</span> <span class="hljs-number">1</span> ) <br><span class="hljs-keyword">UNION</span> <br>( <span class="hljs-keyword">SELECT</span> counter <span class="hljs-operator">+</span> <span class="hljs-number">1</span> <span class="hljs-keyword">FROM</span> cteSource <br><span class="hljs-keyword">WHERE</span> counter <span class="hljs-operator">&lt;</span> <span class="hljs-number">10</span> ) <br>) <br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> cteSource; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据操作语言</tag>
      
      <tag>SQL</tag>
      
      <tag>数据定义语言</tag>
      
      <tag>数据控制语言</tag>
      
      <tag>Joins</tag>
      
      <tag>聚合函数</tag>
      
      <tag>字符串操作</tag>
      
      <tag>日期和时间</tag>
      
      <tag>嵌套查询</tag>
      
      <tag>窗口函数</tag>
      
      <tag>通用表表达式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMU15445-lecture1</title>
    <link href="/2024/06/05/%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BB%A3%E6%95%B0/"/>
    <url>/2024/06/05/%E7%AC%AC%E4%B8%80%E8%AF%BE%EF%BC%9A%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E4%B8%8E%E4%BB%A3%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="第一课关系模型与代数"><a class="markdownIt-Anchor" href="#第一课关系模型与代数"></a> 第一课：关系模型与代数</h1><h2 id="1-数据库"><a class="markdownIt-Anchor" href="#1-数据库"></a> 1 数据库</h2><hr /><p>数据库是相互关联的数据的有组织的集合，它对现实世界的某些方面进行建模（例如，在课堂或数字音乐商店中为学生建模）。人们经常将“数据库”与“数据库管理系统”（例如 MySQL、Oracle、MongoDB、Snowflake）混淆。数据库管理系统（DBMS）是管理数据库的软件。</p><p>考虑一个对数字音乐商店（例如 Spotify）进行建模的数据库。让数据库保存有关艺术家以及这些艺术家发行的专辑的信息。</p><h2 id="2-平面文件实例"><a class="markdownIt-Anchor" href="#2-平面文件实例"></a> 2 平面文件实例</h2><hr /><p>数据库存储为 DBMS 管理的逗号分隔值 (CSV) 文件。每个实体将存储在其自己的文件中。应用程序每次想要读取或更新记录时都必须解析文件。</p><p>按照数字音乐商店的示例，将有两个文件：一个用于艺术家，另一个用于专辑。</p><p>每个实体都有自己的一组属性，因此在每个文件中，不同的记录由换行符分隔，而记录中的每个相应属性由逗号分隔。</p><p>示例：艺术家可以具有姓名、年份和国家/地区属性，而专辑则具有姓名、艺术家和年份属性。</p><p>以下是一个 CSV 文件示例，其中包含有关具有架构（姓名、年份、国家/地区）的艺术家的信息：</p><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;Wu-Tang Clan&quot;</span>, <span class="hljs-number">1992</span>, <span class="hljs-string">&quot;USA&quot;</span> <br><span class="hljs-string">&quot;Notorious BIG&quot;</span>, <span class="hljs-number">1992</span>, <span class="hljs-string">&quot;USA&quot;</span> <br><span class="hljs-string">&quot;GZA&quot;</span>, <span class="hljs-number">1990</span>, <span class="hljs-string">&quot;USA&quot;</span> <br></code></pre></td></tr></table></figure><p>平面文件的问题：</p><ul><li><strong>效率</strong> 需要扫描整个文件并存储在内存中才能找到特定的记录。</li><li><strong>灵活性</strong> 很难进行架构更改，即添加新字段。需要重写整个文件。</li><li><strong>数据完整性</strong> 很难强制执行约束条件，例如年份必须为数字。同时，在专辑文件中可能引用不存在的艺术家。</li><li><strong>持久性</strong> 如果我们的程序正在更新记录时，机器崩溃了，会怎么样？</li><li><strong>并发</strong> 如果两个线程同时尝试更新同一条记录会怎么样？</li><li><strong>抽象</strong> 这个程序与物理存储（CSV文件）紧密耦合。</li></ul><h2 id="3-数据库管理系统"><a class="markdownIt-Anchor" href="#3-数据库管理系统"></a> 3 数据库管理系统</h2><hr /><p>一个数据库管理系统（DBMS）是一种允许应用程序在数据库中存储和分析信息的软件。</p><p>通用的DBMS旨在根据某种数据模型，允许数据库的定义、创建、查询、更新和管理。</p><p>数据模型是用于描述数据库中数据的一组概念。</p><p>例如：例如：关系型（最常见的）、NoSQL（键/值、文档、图形）、数组/矩阵/向量（用于机器学习）。</p><p>模式是基于数据模型的特定数据集合的描述。</p><h3 id="早期dbms"><a class="markdownIt-Anchor" href="#早期dbms"></a> 早期DBMS</h3><p>早期的数据库管理系统（DBMS）由于逻辑和物理层之间的紧密耦合，所以构建和维护都很困难。</p><p>逻辑层描述了数据库中有哪些实体和属性，而物理层描述了这些实体和属性是如何存储的。在早期，物理层是在应用程序代码中定义的，所以如果我们想要更改应用程序正在使用的物理层，我们必须改变所有的代码以适应新的物理层。</p><h2 id="4-关系模型"><a class="markdownIt-Anchor" href="#4-关系模型"></a> 4 关系模型</h2><hr /><p>特德·科德（Ted Codd）注意到每当人们想要改变物理层时，就需要重新编写数据库管理系统（DBMS），因此他在1969年提出了关系模型以避免这种情况发生。</p><p>关系模型基于关系定义了一个数据库抽象，以避免维护开销。它有三个关键点：</p><ul><li>将数据库存储在简单的数据结构（关系）中。</li><li>通过高级语言访问数据，数据库管理系统找出最佳的执行策略。</li><li>物理存储由DBMS实现处理。</li></ul><p>关系数据模型定义了三个概念：</p><ul><li>**结构：**关系及其内容的定义。这是关系具有的属性和这些属性可以容纳的值。</li><li>**完整性：**确保数据库的内容满足约束条件。一个例子是：年份属性的任何值都必须是一个数字。</li><li>**操作：**如何访问和修改数据库内容。</li></ul><p>一个关系是一个无序集合，其中包含表示实体关系的属性。由于关系是无序的，数据库管理系统可以以任何方式存储它们，以实现优化。关系中可能存在重复的元素。</p><p>一个元组是关系中属性值(也称为其域)的集合。起初，值必须是原子式的或者标量的，但现在值也可以是列表或嵌套数据结构。每个属性都可以是特殊值NULL，它表示对于给定的元组，属性是未定义的。</p><p>具有n个属性的关系被称为n元关系。在本课程中，我们会交替使用关系和表。一个n元关系等同于具有n列的表。</p><h3 id="键"><a class="markdownIt-Anchor" href="#键"></a> 键</h3><p>关系的主键唯一标识一个元组。如果您没有定义主键，一些数据库管理系统会自动创建一个内部主键。许多数据库管理系统支持自动生成的键，因此应用程序不必手动递增键，但某些数据库管理系统仍然需要主键。</p><p>外键指定一个关系中的属性必须映射到另一个关系中的元组。例如，我们可以在专辑表中包含艺术家ID（引用艺术家表的外键）。</p><h3 id="约束"><a class="markdownIt-Anchor" href="#约束"></a> 约束</h3><p>约束是用户定义的必须满足数据库任何实例的条件</p><h2 id="5-数据操作语言dmls"><a class="markdownIt-Anchor" href="#5-数据操作语言dmls"></a> 5 数据操作语言（DMLs）</h2><hr /><p>存储和检索数据库中的信息的方法。对此有两类语言：</p><ul><li>过程性语言：查询指定了DBMS应使用哪种（高级）策略基于集合/包找到所需结果。例如，使用for循环扫描所有记录并计算记录数以检索表中的记录数。</li><li>非过程性语言（声明性语言）：查询仅指定所需的数据而不指定如何查找它。例如，使用SQL select count(*) from artist来计算表中有多少条记录。</li></ul><h2 id="6-关系代数"><a class="markdownIt-Anchor" href="#6-关系代数"></a> 6 关系代数</h2><hr /><p>关系代数是一组检索和操作关系中元组的基本操作。每个操作符都接受一个或多个关系作为输入，并输出一个新的关系。为了编写查询，我们可以“链接”这些操作符以创建更复杂的操作。</p><h3 id="select"><a class="markdownIt-Anchor" href="#select"></a> Select</h3><p>Select接受一个关系，并输出满足选择谓词的关系中的一部分元组。谓词的作用类似于过滤器，并且我们可以使用合取和析取来组合多个谓词。</p><p>语法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>p</mi><mi>r</mi><mi>e</mi><mi>d</mi><mi>i</mi><mi>c</mi><mi>a</mi><mi>t</mi><mi>e</mi></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{predicate}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span><span class="mord mathnormal mtight" style="margin-right:0.02778em;">r</span><span class="mord mathnormal mtight">e</span><span class="mord mathnormal mtight">d</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">c</span><span class="mord mathnormal mtight">a</span><span class="mord mathnormal mtight">t</span><span class="mord mathnormal mtight">e</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>.</p><p>例子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><msup><mo>=</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>a</mi><msup><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{a.id=&#x27;a2&#x27;}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mrel mtight"><span class="mrel mtight">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal mtight">a</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span></p><p>SQL:SELECT * FROM R WHERE a_id = ‘a2’.</p><h3 id="projection"><a class="markdownIt-Anchor" href="#projection"></a> Projection</h3><p>投影会接收一个关系，并输出一个只包含指定属性的关系。您可以重新安排输入关系中属性的顺序，并操纵其值。</p><p>语法:<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>A</mi><mn>1</mn><mo separator="true">,</mo><mi>A</mi><mn>2</mn><mo separator="true">,</mo><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mi mathvariant="normal">.</mi><mo separator="true">,</mo><mi>A</mi><mi>n</mi></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{A1,A2,...,An}(R)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.328331em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">A</span><span class="mord mtight">1</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">A</span><span class="mord mtight">2</span><span class="mpunct mtight">,</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mord mtight">.</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">A</span><span class="mord mathnormal mtight">n</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span></span></span></span>.</p><p>例子：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>π</mi><mrow><mi>b</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>−</mo><mn>100</mn><mo separator="true">,</mo><mi>a</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi></mrow></msub><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>a</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><msup><mo>=</mo><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup><mi>a</mi><msup><mn>2</mn><mo mathvariant="normal" lspace="0em" rspace="0em">′</mo></msup></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\pi_{b.id-100,a.id}(\sigma_{a.id=&#x27;a2&#x27;}(R))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.036108em;vertical-align:-0.286108em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">π</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361079999999999em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mbin mtight">−</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">0</span><span class="mpunct mtight">,</span><span class="mord mathnormal mtight">a</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.286108em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">a</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mrel mtight"><span class="mrel mtight">=</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span><span class="mord mathnormal mtight">a</span><span class="mord mtight"><span class="mord mtight">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.6828285714285715em;"><span style="top:-2.786em;margin-right:0.07142857142857144em;"><span class="pstrut" style="height:2.5em;"></span><span class="sizing reset-size3 size1 mtight"><span class="mord mtight"><span class="mord mtight">′</span></span></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>.</p><p>SQL:SELECT b.id-100, <a href="http://a.id">a.id</a> FROM R WHERE <a href="http://a.id">a.id</a> = ‘a2’.</p><h3 id="union"><a class="markdownIt-Anchor" href="#union"></a> Union</h3><p>Union接收两个关系，并输出一个包含所有出现在至少一个输入关系中的元组的关系。注意：两个输入必须具有完全相同的属性。</p><p>语法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>∪</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R \cup S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∪</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>.</p><p>SQL:(SELECT * FROM R) UNION ALL (SELECT * FROM S).</p><h3 id="intersection"><a class="markdownIt-Anchor" href="#intersection"></a> Intersection</h3><p>交集操作接收两个关系，并输出包含出现在两个输入关系中的所有元组的关系。注意：两个输入关系必须具有完全相同的属性。</p><p>语法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>∩</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R \cap S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">∩</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>.</p><p>SQL:(SELECT * FROM R) INTERSECT (SELECT * FROM S).</p><h3 id="difference"><a class="markdownIt-Anchor" href="#difference"></a> Difference</h3><p>差异操作接受两个关系，输出一个包含在第一个关系中出现但不在第二个关系中出现的所有元组的关系。注意：两个输入关系必须具有完全相同的属性。</p><p>语法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>−</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R - S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>.</p><p>SQL:(SELECT * FROM R) EXCEPT (SELECT * FROM S).</p><h3 id="product"><a class="markdownIt-Anchor" href="#product"></a> Product</h3><p>Product接收两个关系作为输入，并输出一个包含来自输入关系的所有可能组合的关系。</p><p>语法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>×</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R \times S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>.</p><p>SQL:(SELECT * FROM R) CROSS JOIN (SELECT * FROM S),或者简单的 SELECT * FROM R, S.</p><h3 id="join"><a class="markdownIt-Anchor" href="#join"></a> Join</h3><p>Join操作接收两个关系，并输出包含所有元组的关系，这些元组是来自于两个元组的组合，其中对于两个关系共享的每个属性，两个元组在该属性上的值相同。</p><p>语法：<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>⋈</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R \Join S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>.</p><p>SQL: SELECT * FROM R JOIN S USING (ATTRIBUTE1, ATTRIBUTE2…).</p><h3 id="observation"><a class="markdownIt-Anchor" href="#observation"></a> Observation</h3><p>关系代数是一种过程性语言，因为它定义了计算查询的高级步骤。例如，<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>b</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>102</mn></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo>⋈</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{b.id=102}(R \Join S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>表示首先进行R和S的连接，然后进行选择操作，而<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>⋈</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>b</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>102</mn></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R \Join (\sigma_{b.id=102}(S)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>将首先在S上进行选择操作，然后进行连接。这两个语句实际上会产生相同的答案，但是如果在十亿个元组中只有一个具有b.id=102的元组，则<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>R</mi><mo>⋈</mo><mo stretchy="false">(</mo><msub><mi>σ</mi><mrow><mi>b</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>102</mn></mrow></msub><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(R \Join (\sigma_{b.id=102}(S)))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mclose">)</span><span class="mclose">)</span></span></span></span>的速度将显著快于<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><msub><mi>σ</mi><mrow><mi>b</mi><mi mathvariant="normal">.</mi><mi>i</mi><mi>d</mi><mo>=</mo><mn>102</mn></mrow></msub><mo stretchy="false">(</mo><mi>R</mi><mo>⋈</mo><mi>S</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\sigma_{b.id=102}(R \Join S)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.03588em;">σ</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.33610799999999996em;"><span style="top:-2.5500000000000003em;margin-left:-0.03588em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">b</span><span class="mord mtight">.</span><span class="mord mathnormal mtight">i</span><span class="mord mathnormal mtight">d</span><span class="mrel mtight">=</span><span class="mord mtight">1</span><span class="mord mtight">0</span><span class="mord mtight">2</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⋈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span></span></span></span>。</p><p>更好的方法是说出你想要的结果（从R和S中检索到bid等于102的连接元组），然后让数据库管理系统决定计算查询所需的步骤。SQL会完全做到这点，它是在关系模型数据库上编写查询的事实标准。</p><h2 id="7-数据模型"><a class="markdownIt-Anchor" href="#7-数据模型"></a> 7 数据模型</h2><hr /><ul><li>文档模型：包含命名字段/值对的记录文档的集合.</li><li>向量模型：是用于最近邻搜索（精确或近似）的一维数组.</li></ul>]]></content>
    
    
    <categories>
      
      <category>cmu15445</category>
      
    </categories>
    
    
    <tags>
      
      <tag>关系模型</tag>
      
      <tag>数据库管理系统</tag>
      
      <tag>关系代数</tag>
      
      <tag>数据操作语言</tag>
      
      <tag>SQL</tag>
      
      <tag>数据模型</tag>
      
      <tag>数据完整性</tag>
      
      <tag>查询优化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scene-question-3</title>
    <link href="/2024/05/31/scene-question-3/"/>
    <url>/2024/05/31/scene-question-3/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="如果你的业务量突然提升100倍qps你会怎么做"><a class="markdownIt-Anchor" href="#如果你的业务量突然提升100倍qps你会怎么做"></a> 如果你的业务量突然提升100倍QPS你会怎么做？</h1><h2 id="典型回答"><a class="markdownIt-Anchor" href="#典型回答"></a> <strong>典型回答</strong></h2><p>首先看下这个业务量的提升的原因和特点是什么？</p><p>那么就有很多种情况了：</p><ol><li>业务有好转有起色了，或者刚好蹭到某个热点</li><li>被DDOS了</li></ol><p>如果是被DDOS攻击了，也会导致流量提升，那么这种就通过防止DDOS攻击的手段来解决。</p><p><a href="#%E4%BB%80%E4%B9%88%E6%98%AFDDoS%E6%94%BB%E5%87%BB%EF%BC%9F%E5%A6%82%E4%BD%95%E9%98%B2%E6%AD%A2%E8%A2%AB%E6%94%BB%E5%87%BB%EF%BC%9F">什么是DDoS攻击？如何防止被攻击？</a></p><p>如果是蹭到了某个热点，那么久可以通过临时方案来解决，不需要考虑的太久，那么最简单的就是扩容，增加集群的服务器数量，提升机器的硬件资源配置，让整体的吞吐量提升。</p><p>那么，如果是长期方案，想让系统真的可以提升并发性，提升到可以抗100倍QPS，那么可以做的事情其实就是另外一个问题：<a href="#%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E4%B8%80%E4%B8%AA%E8%83%BD%E5%A4%9F%E6%94%AF%E6%8C%81%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E7%B3%BB%E7%BB%9F%EF%BC%9F">如何设计一个高并发系统</a></p><h2 id="如何设计一个能够支持高并发的系统"><a class="markdownIt-Anchor" href="#如何设计一个能够支持高并发的系统"></a> 如何设计一个能够支持高并发的系统？</h2><ol><li>**分布式架构：**将系统分解成多个模块，采用分布式架构来降低单点故障的风险，并提高系统的可伸缩性和性能。</li><li>**集群部署：**将一个服务通过集群进行部署，来提升系统整体的吞吐量及响应速度，并使用负载均衡技术将请求均衡分配给多个服务器，以提高系统的性能和可用性。</li><li>**利用缓存：**使用缓存、NoSQL等技术，以提高数据读写的性能和可靠性。</li><li>**异步处理：**采用异步处理机制，如使用消息队列、事件驱动等技术，以降低请求响应时间和提高系统吞吐量。</li><li>**预加载：**使用预加载技术来提前加载需要的资源，以减少用户等待时间。</li><li>**代码优化和调优：**对系统代码进行优化和调优，如采用异步IO、避免锁（减小锁的粒度）、减少循环和递归、避免长事务等，以提高系统性能。</li><li>**数据库优化：**合理的数据库设计和优化，包括合理的索引设计、分库分表、读写分离、缓存优化等，可以有效提高系统的并发度和响应速度。</li><li>**分库分表：**将一个大型的数据库拆分成多个小型的数据库（分库），然后将每个小型数据库中的表再进行拆分（分表），从而减轻单个数据库或表的读写压力，通过分库分表，可以将大量的读写操作分散到多个数据库或表中，从而提高系统的并发度和响应速度。</li><li>**读写分离：**读写分离是一种常用的数据库优化技术，它将读操作和写操作分配到不同的数据库实例上处理。通过读写分离，主库主要负责写操作，从库则负责读操作，从而提高了系统的并发度和可扩展性。同时，读写分离还可以提高系统的可用性和容错能力，因为即使主库出现故障，从库仍然可以提供读服务。</li><li>**防止雪崩：**通过限流、熔断、降级等技术，可以防止系统因为某个组件出现故障而导致整个系统崩溃的雪崩效应。</li><li>**容错和监控：**实现容错机制，如备份、容灾、负载降级等，以保障系统的可用性。同时，使用监控工具来实时检测系统的运行状况和性能瓶颈，及时做出调整和优化。</li><li>**测试和评估：**进行全面的性能测试和评估，包括压力测试、负载测试、安全测试等，以发现并解决系统的性能瓶颈和安全隐患。</li></ol><p>综上所述，设计高并发系统需要从多个方面考虑，需要综合运用各种技术和工具，进行全面的测试和评估，以实现系统的高可用、高性能和高安全性。</p><h2 id="什么是ddos攻击如何防止被攻击"><a class="markdownIt-Anchor" href="#什么是ddos攻击如何防止被攻击"></a> <strong>什么是DDoS攻击？如何防止被攻击？</strong></h2><p>分布式拒绝服务（DDoS：Distributed Denial of Service)攻击，是指攻击者利用大量“肉鸡”对攻击目标发动大量的正式或非正式请求、耗尽目标主机资源或网络资源，从而使被攻击的主机不能为正常用户提供服务。</p><h3 id="dos"><a class="markdownIt-Anchor" href="#dos"></a> DoS：</h3><p>DoS(拒绝服务，Denial of Service)就是利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应。这是早期非常基本的网络攻击方式。</p><p>举个🌰，小王开了一家商店，店面不大，加上小王一共有三个服务员。由于他们这里物美价廉，工作人员的态度又比较友善，所以慢慢的生意越来越好。</p><p>但是，这家店所在的小镇上有一个恶霸，恶霸看到小王的店很赚钱，于是想要通过一些下作的手段谋取私利。于是他装扮成普通的顾客，在小王的店里有一搭无一搭的总和店员攀谈，问问这个多少钱，问问那个怎么卖，还时不时的给店员提供一些虚假信息，比如哪里缺货了之类的信息。使店员们都被他搞的团团转。</p><p>由于恶霸是装作普通顾客的，小王和店员们又不能彻底不理他，所以就要分出一些精力来服务他，但是由于店内的服务员有限。这样一来，很多其他的顾客就可能受到了冷落。</p><p>虽然恶霸的行为是恶意的，但是他在店内的是一个普通顾客，他的咨询价格之类的行为也都是合理的。但是由于他频繁询问，长时间霸占服务员的时间。这就导致店铺的其他用户体验有所下降。</p><p>对于网站来说，其实也是一样的，网站就像是小王的商店一样。对于一个网站来说，他是要搭建在服务器上面的，而由于硬件资源有限，所以服务能力也是有限的。如果有人频繁访问或者长时间占用资源，就会导致其他用户的体验有所下降。</p><p>这种，利用合理的服务请求来占用过多的服务资源，从而使合法用户无法得到服务的响应的行为，就是DoS攻击。</p><p>在信息安全的三要素–保密性、完整性和可用性中，DoS针对的目标正是可用性。该攻击方式利用目标系统网络服务功能缺陷或者直接消耗其系统资源，使得该目标系统无法提供正常的服务。</p><h3 id="ddos"><a class="markdownIt-Anchor" href="#ddos"></a> DDoS：</h3><p>如果只是一个恶霸的话，只要能够识别出来，然后阻止他进入店铺就行了。</p><p>随着恶霸被发现之后，他也想了一个办法，这次他不再自己一个人跑去店铺了，而是纠集了一群无赖，而这些无赖每天都换，店铺里面的服务员根本识别不出来到底谁是捣乱的。</p><p>无赖们扮作普通客户一直拥挤在商场，赖着不走，真正的购物者却无法进入；或者总是和营业员有一搭没一搭的东扯西扯，让工作人员不能正常服务客户；也可以为商铺的经营者提供虚假信息，商铺的上上下下忙成一团之后却发现都是一场空，最终跑了真正的大客户，损失惨重。一个无赖去胡闹，就是 DoS攻击，而一群无赖去胡闹，就是 DDoS攻击。</p><p>一般来说，DDoS攻击可以具体分成两种形式：带宽消耗型和资源消耗型。他们都是透过大量合法或伪造的请求占用大量网络以及器材资源，以达到瘫痪网络以及系统的目的。</p><h3 id="ddos的危害"><a class="markdownIt-Anchor" href="#ddos的危害"></a> DDoS的危害：</h3><p>当服务器被DDoS攻击时，一般会出现一下现象：</p><p>被攻击主机上有大量等待的TCP连接；网络中充斥着大量的无用的数据包；受害主机无法正常和外界通讯；受害主机无法处理所有正常请求；严重时会造成系统死机。对于用户来说，在常见的现象就是网站无法访问。</p><h3 id="ddos的防范"><a class="markdownIt-Anchor" href="#ddos的防范"></a> DDoS的防范</h3><p>为了对抗DDoS攻击，你需要对攻击时发生了什么有一个清楚的理解。简单来讲，DDoS攻击可以通过利用服务器上的漏洞，或者消耗服务器上的资源（如内存、硬盘等）来达到目的。</p><p>一般来说，可以用以下办法防范：</p><ol><li>如果可以识别出攻击源，如机器IP等，可以在防火墙服务器上放置一份ACL（访问控制列表）来阻断这些来自这些IP的访问。</li><li>对于带宽消耗型攻击，最有效的办法就是增加带宽。</li><li>提高服务器的服务能力，增加负载均衡、多地部署等。</li><li>优化资源使用提高web server的负载能力。例如，使用apache可以安装apachebooster插件，该插件与varnish和nginx集成，可以应对突增的流量和内存占用。</li><li>使用高可扩展性的DNS设备来保护针对DNS的DDOS攻击。</li><li>启用路由器或防火墙的反IP欺骗功能。</li><li>付费，使用第三方的服务来保护你的网站。</li><li>监控网络和web的流量。时刻观察流量变化</li><li>保护好DNS避免DNS放大攻击</li></ol><p>对于网络攻击，没有任何办法彻底阻止和避免，只能尽最大努力不断提高黑客攻击成本。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>High QPS</tag>
      
      <tag>DDoS</tag>
      
      <tag>Performance Tuning</tag>
      
      <tag>Scalability</tag>
      
      <tag>Distributed Systems</tag>
      
      <tag>System Design</tag>
      
      <tag>Load Balancing</tag>
      
      <tag>Caching</tag>
      
      <tag>Asynchronous Processing</tag>
      
      <tag>Database Optimization</tag>
      
      <tag>System Monitoring</tag>
      
      <tag>Fault Tolerance</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scene-question-2</title>
    <link href="/2024/05/31/scene-question-2/"/>
    <url>/2024/05/31/scene-question-2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="每天100w次登陆请求4c8g机器如何做jvm调优"><a class="markdownIt-Anchor" href="#每天100w次登陆请求4c8g机器如何做jvm调优"></a> 每天100w次登陆请求，4C8G机器如何做JVM调优？</h1><h2 id="典型回答"><a class="markdownIt-Anchor" href="#典型回答"></a> 典型回答</h2><p>首先，我们需要问清楚，一天100w次的登陆，在一天内有没有某个时段是高峰的？高峰期的QPS大概可以达到多少。</p><p>如果没有高峰期，100w平均下来QPS只有10，这个量不需要做JVM优化。</p><p>一般业务场景中，都是有自己的业务高峰期的，比如电商业务基本上上午十点和下午两点是业务高峰期，基本上这时候的QPS是平时的20倍都不止。</p><p>我们假设登陆业务存在高峰期，峰值时长大概持续1h，峰值的QPS可以达到200。那么需要做哪些优化？</p><blockquote><p>作为一个登陆服务，一般来说我们在接收到请求之后，只需要给用户进行鉴权并把结果返回给前端就可以了。在这个过程中一般不太会去查询太多的数据，比如权限什么的也都是在后面访问页面再查询的。所以，峰值200左右的QPS，对于JVM的内存来说，最主要的就是会因为远程调用，而创建出很多请求参数和请求的响应。而这些对象基本都是朝生暮死的，接口调用结束之后就会被回收掉。并且通常来说这些对象也不会很大，因为登录并不是注册，其实并不携带特别多的信息，那么也就是说，会产生大量的小对象，即新生代会不断的创建对象，并被回收掉。</p></blockquote><h3 id="堆内存设置"><a class="markdownIt-Anchor" href="#堆内存设置"></a> 堆内存设置</h3><p>首先是堆内存大小的设置。当我们的机器只有4核8G的时候，堆内存的大小肯定不能太大，一般不建议设置的太大，因为我们需要给机器上的其他应用预留出一部分内容。所以我们一般建议都是把JVM的堆内存设置成操作系统内存的一半，也就是4G。至于初始内存和最大内存，我们这场景中建议设置成一样的。这样可以避免JVM在运行过程中频繁进行内存扩容和收缩操作，提高应用程序的性能和稳定性。即</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-Xms4G -Xmx4G</span><br></code></pre></td></tr></table></figure><h3 id="垃圾收集器选择"><a class="markdownIt-Anchor" href="#垃圾收集器选择"></a> 垃圾收集器选择</h3><p>在设置了堆空间的总大小之后，我们需要考虑用那种垃圾收集器。另外，我们前面分析过，这个业务中会频繁在新生代创建并销毁对象，那么，就意味着新生代的GC会比较频繁。所以我们需要选择一种在GC过程中STW时间短的，并且在年轻代的回收中也能发挥效果的。</p><p>在新生代的垃圾收集器中，主要以Serial、ParNew、Parallel Scavenge以及支持整堆回收的G1了。</p><p>因为新生代采用的都是复制算法，所以不太需要考虑碎片的问题，我们主要考虑吞吐量和STW的时长就行了。</p><p>首先排除单线程的Serial，剩下ParNew是一个并发的收集器，Parallel Scavenge更加关注吞吐量，而G1作为JDK 9中默认垃圾收集器，他不仅同时具有低暂停时间和高吞吐量的优点，但是他对内存有要求，最小要4G，</p><p>从使用门槛上来说，G1是可以用的，因为一般来说，内存要大于等于4G的话，才适合使用G1进行GC。</p><p>所以，我们采用G1作为垃圾收集器：</p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs diff"><span class="hljs-deletion">-XX: +UseG1GC</span><br></code></pre></td></tr></table></figure><p>在使用了G1之后，其实他自己是有一套自动的预测和调优机制的。我们只需要通过-XX:MaxGCPauseMillis参数来设置最大停顿时间就行了。一般建议设置到100-200之间，一般这个时长对用户来说基本无感知</p><p>其次，我们还可以自己调节一些G1的配置，比如设置GC线程数</p><h3 id="各区大小设置"><a class="markdownIt-Anchor" href="#各区大小设置"></a> 各区大小设置</h3><p>G1的内存划分是自适应的，它会根据堆的大小和使用情况来动态调整各个区域的大小和比例。但是，我们也可以通过一些JVM参数来手动设置G1的各个分代内存配置。</p><p>G1 中的分代和其他垃圾回收器不太一样，它不是严格按照年轻代和老年代划分的，而是通过划分各个区域的存活对象数量来实现垃圾回收的。因此，G1 中不需要像其他垃圾回收器那样设置新生代和老年代的大小比例，而是需要设置一些区域的内存配置。</p><p>-XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent分别用于设置年轻代的初始大小和最大大小，它们的默认值分别为 5% 和 60%。针对我们的业务场景，我们其实可以适当的调高一下年轻代的初始大小，5%的比例太小了，我们可以调整到30%。</p><h3 id="添加必要的日志"><a class="markdownIt-Anchor" href="#添加必要的日志"></a> 添加必要的日志</h3><p>因为以上配置都是根据业务大致分析出来的初始配置，所以我们一定是需要不断地调优的，那么必要的日志相关参数就要添加。如：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs ruby">-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:MaxGCPauseMillis=</span><span class="hljs-number">100</span>：最大 <span class="hljs-variable constant_">GC</span> 暂停时间为 <span class="hljs-number">100</span> 毫秒，可以根据实际情况调整；<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+HeapDumpOnOutOfMemoryError</span>：当出现内存溢出时，自动生成堆内存快照文件；<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:HeapDumpPath=/path/to/heap/dump/file</span>.hprof：堆内存快照文件的存储路径；<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGC</span>：输出 <span class="hljs-variable constant_">GC</span> 信息；<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDateStamps</span>：输出 <span class="hljs-variable constant_">GC</span> 发生时间；<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCTimeStamps</span>：输出 <span class="hljs-variable constant_">GC</span> 发生时 <span class="hljs-variable constant_">JVM</span> 的运行时间；<br>-<span class="hljs-variable constant_">XX</span><span class="hljs-symbol">:+PrintGCDetails</span>：输出 <span class="hljs-variable constant_">GC</span> 的详细信息；<br>-<span class="hljs-title class_">Xlog</span><span class="hljs-symbol">:gc*</span><span class="hljs-symbol">:file=/path/to/gc</span>.<span class="hljs-symbol">log:</span>time,<span class="hljs-symbol">uptime:</span>filecount=<span class="hljs-number">10</span>,filesize=100M：将 <span class="hljs-variable constant_">GC</span> 日志输出到指定文件中，可以根据需要调整日志文件路径、数量和大小<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>High QPS</tag>
      
      <tag>Performance Tuning</tag>
      
      <tag>JVM</tag>
      
      <tag>Garbage Collection</tag>
      
      <tag>G1GC</tag>
      
      <tag>Memory Management</tag>
      
      <tag>System Optimization</tag>
      
      <tag>Java</tag>
      
      <tag>Application Performance</tag>
      
      <tag>Server Configuration</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tea-5.27-5.31</title>
    <link href="/2024/05/31/tea-5-27-5-31/"/>
    <url>/2024/05/31/tea-5-27-5-31/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶527-531"><a class="markdownIt-Anchor" href="#茶527-531"></a> 茶5.27-5.31</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/problemset/problem/1343/C">Alternating Subsequence</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤2e5) 和长为 n 的数组 a(-1e9≤a[i]≤1e9 且 a[i]≠0)。</p><p>选一个 a 的子序列，要求：</p><ol><li>子序列是交替的（相邻元素一正一负）。</li><li>在满足 1 的前提下，子序列尽量长。</li><li>在满足 2 的前提下，子序列元素和尽量大。<br />输出元素和的最大值。</li></ol><p>注：子序列不一定连续。</p><p>输入<br />4<br />5<br />1 2 3 -1 -2<br />4<br />-1 -2 -1 -3<br />10<br />-2 8 3 8 -4 -15 5 -2 -3 1<br />6<br />1 -1000000000 1 -1000000000 1 -1000000000<br />输出<br />2<br />-1<br />6<br />-2999999997</p><p><strong>Sol:</strong></p><p>首先，让我们通过包含由具有相同符号的数字组成的数组的包含段来提取最大值。例如，如果数组是 [1,1,2，−1，−5,2,1，−3]，则这些段是 [1,1,2]、[−1，−5]、[2,1] 和 [−3]。我们可以使用任何类似“双指针”的算法来做到这一点。这些段的数量是交替子序列的最大可能长度，因为我们只能从每个块中获取一个元素。当我们想最大化总和时，我们需要从每个块中获取最大元素。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> &amp;it : a) cin &gt;&gt; it;<br>    ll sum = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">auto</span> sgn = [&amp;](<span class="hljs-type">int</span> x) &#123;<br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> cur = a[i];<br>        <span class="hljs-type">int</span> j = i;<br>        <span class="hljs-keyword">while</span> (j &lt; n &amp;&amp; <span class="hljs-built_in">sgn</span>(a[i]) == <span class="hljs-built_in">sgn</span>(a[j])) &#123;<br>            cur = <span class="hljs-built_in">max</span>(cur, a[j]);<br>            j++;<br>        &#125;<br>        sum += cur;<br>        i = j - <span class="hljs-number">1</span>;<br>    &#125;<br>    cout &lt;&lt; sum &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="feb"><a class="markdownIt-Anchor" href="#feb"></a> Feb</h2><p><a href="https://codeforces.com/problemset/problem/608/B">https://codeforces.com/problemset/problem/608/B</a></p><p>输入长度均 ≤2e5 的字符串 s 和 t，只包含 ‘0’ 和 ‘1’。并且 t 的长度大于等于 s 的长度。</p><p>定义 D(a,b) = |a[0]-b[0]| + |a[1]-b[1]| + … + |a[n-1]-b[n-1]|。<br />例如 D(“0011”, “0110”) = |0-0| + |0-1| + |1-1| + |1-0| = 0 + 1 + 0 + 1 = 2。</p><p>设 s 的长度为 n，对于 t 的所有长为 n 的连续子串 t’，计算 D(s,t’)。<br />输出所有 D(s,t’) 的和。</p><p>输入<br />01<br />00111<br />输出 3<br />解释 要计算的是 D(“01”, “00”) + D(“01”, “01”) + D(“01”, “11”) + D(“01”, “11”)</p><p>输入<br />0011<br />0110<br />输出 2</p><p><strong>Sol:</strong></p><p>s[0] 对答案的贡献是多少？</p><p>s[1] 对答案的贡献是多少？</p><p>…</p><p>s[n-1] 对答案的贡献是多少？</p><p>设 d = m - n + 1，其中 n 和 m 分别为 s 和 t 的长度。</p><p>对于 s[0] 来说，它会与 t[0],t[1],…,t[d-1] 计算 D 值。</p><p>也就是 t[0],t[1],…,t[d-1] 中的不等于 s[0] 的字符个数。</p><p>对于 s[1] 来说，它会与 t[1],t[2],…,t[d] 计算 D 值。</p><p>依此类推，问题变成一个长为 d 的定长滑窗。要统计的是窗口内的 ‘1’ 的个数（‘0’ 的个数等于 d 减去 ‘1’ 的个数）。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s,t;<br>    cin&gt;&gt;s&gt;&gt;t;<br>    <span class="hljs-type">int</span> d = t.<span class="hljs-built_in">size</span>() - s.<span class="hljs-built_in">size</span>() + <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> c1 = <span class="hljs-built_in">count</span>(t.<span class="hljs-built_in">begin</span>(), t.<span class="hljs-built_in">begin</span>() + d - <span class="hljs-number">1</span>, <span class="hljs-string">&#x27;1&#x27;</span>);<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; s.<span class="hljs-built_in">size</span>(); i++) &#123;<br>        c1 += t[i + d - <span class="hljs-number">1</span>] &amp; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (s[i] == <span class="hljs-string">&#x27;0&#x27;</span>) &#123;<br>            ans += c1;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ans += d - c1;<br>        &#125;<br>        c1 -= t[i] &amp; <span class="hljs-number">1</span>;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1843/E">Tracking Segments_881E</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤1e5。<br />对于每组数据：<br />一开始，有一个长为 n 的全 0 数组 a，下标从 1 开始。<br />输入 n m(1≤m≤n≤1e5) 以及 m 个非空连续子数组的左右端点 L R。<br />然后输入 q(1≤q≤n) 和 q 个操作，每个操作输入一个下标 p，表示把 a[p] 变成 1。保证所有 p 互不相同。</p><p>如果一个子数组中的 1 的个数比 0 多，则称这个子数组是优美的。<br />输入的 q 个操作，按照输入顺序一个一个地执行。<br />至少执行多少个操作，可以使 m 个子数组中有优美子数组？<br />如果执行完了也没有优美子数组，输出 -1。</p><p><strong>Sol:</strong></p><p>二分答案，执行前 mid 个操作，用前缀和计算子数组和。</p><p>如果 1 的个数比 0 多，也就是 1 的个数比子数组长度减去 1 的个数多，即子数组元素和 * 2 &gt; 子数组长度，则说明子数组是优美的。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;n, &amp;m);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d%d&quot;</span>, &amp;l[i], &amp;r[i]);<br>&#125;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;q);<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= q; ++ i) &#123;<br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;pos[i]);<br>&#125;<br><span class="hljs-type">int</span> ql = <span class="hljs-number">1</span>, qr = q, ans = <span class="hljs-number">-1</span>;<br><span class="hljs-keyword">while</span>(ql &lt;= qr) &#123;<br><span class="hljs-type">int</span> mid = (ql + qr) &gt;&gt; <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>sum[i] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= mid; ++ i)<br>++ sum[pos[i]];<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++ i)<br>sum[i] += sum[i - <span class="hljs-number">1</span>];<br><span class="hljs-type">int</span> f = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= m; ++ i) &#123;<br><span class="hljs-keyword">if</span>(sum[r[i]] - sum[l[i] - <span class="hljs-number">1</span>] &gt;= (r[i] - l[i] + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span> + <span class="hljs-number">1</span>) &#123;<br>f = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">if</span>(f)<br>ans = mid, qr = mid - <span class="hljs-number">1</span>;<br><span class="hljs-keyword">else</span><br>ql = mid + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, ans);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/problemset/problem/1796/D">Maximum Subarray_144A</a></p><p>输入 T(≤1e4) 表示 T 组数据。所有数据的 n 之和 ≤2e5。<br />每组数据输入 n(1≤n≤2e5) k(0≤k≤min(20,n)) x(-1e9≤x≤1e9) 和长为 n 的数组 a(-1e9≤a[i]≤1e9)。</p><p>你需要把 a 中恰好 k 个数增加 x，其余数减少 x。<br />该操作必须恰好执行一次。<br />输出操作后，a 的最大连续子数组和。子数组可以是空的，元素和为 0。</p><p>输入<br />4<br />4 1 2<br />2 -1 2 3<br />2 2 3<br />-1 2<br />3 0 5<br />3 2 4<br />6 2 -8<br />4 -1 9 -3 7 -8<br />输出<br />5<br />7<br />0<br />44</p><p><strong>Sol:</strong></p><p>O(n) 做法。</p><p>如果 x&lt;0，那么可以把 x 变成 -x，同时 k 变成 n-k。 下面的讨论满足 x&gt;=0。</p><p>为方便计算，先把所有数都减去 x，于是操作变成把 k 个数增加 2x。</p><p>分类讨论：</p><ol><li>如果子数组长度超过 k，那么子数组内有 k 个数可以增加 2x，总和增加 2kx。我们计算的是长度有下限的最大子数组和。 用前缀和思考，s[right]-s[left] 最大，那么 s[left] 尽量小，且 right-left &gt; k，所以枚举 right 的同时，要维护 s[0] 到 s[right-k-1] 的最小值。 可以先看<a href="https://leetcode.cn/problems/maximum-subarray/solutions/2533977/qian-zhui-he-zuo-fa-ben-zhi-shi-mai-mai-abu71/">【题解】最大子数组和的前缀和做法</a></li><li>如果子数组长度不超过 k，那么子数组内所有数都可以增加 2x。我们计算的是长度有上限的最大子数组和，这可以用前缀和+单调队列解决。关于单调队列，可以看 <a href="https://www.bilibili.com/video/BV1bM411X72E/">【视频】单调队列</a></li></ol><p>总的来说，这题同时考察了最大子数组和的长度下限变体和长度上限变体，是一道不错的综合题目。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n, k, x;<br>    cin &gt;&gt; n &gt;&gt; k &gt;&gt; x;<br>    <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) &#123;<br>        x = -x;<br>        k = n - k;<br>    &#125;<br>    <span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>, pre = <span class="hljs-number">0</span>, pre2 = <span class="hljs-number">0</span>, minS = <span class="hljs-number">0</span>;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        cin &gt;&gt; a[i];<br>        pre += a[i] - x;<br>        <span class="hljs-keyword">if</span> (i &gt;= k) &#123;<br>            ans = <span class="hljs-built_in">max</span>(ans, pre - minS + k * x * <span class="hljs-number">2</span>);<br>            pre2 += a[i - k] - x;<br>            minS = <span class="hljs-built_in">min</span>(minS, pre2);<br>        &#125;<br>    &#125;<br>    <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">sum</span><span class="hljs-params">(n + <span class="hljs-number">1</span>)</span></span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>        sum[i + <span class="hljs-number">1</span>] = sum[i] + a[i] + x;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; q;<br>    q.<span class="hljs-built_in">push_back</span>(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        <span class="hljs-keyword">if</span> (q[<span class="hljs-number">0</span>] &lt; i - k) &#123;<br>            q.<span class="hljs-built_in">erase</span>(q.<span class="hljs-built_in">begin</span>());<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>() &amp;&amp; sum[i] &lt;= sum[q.<span class="hljs-built_in">back</span>()]) &#123;<br>            q.<span class="hljs-built_in">pop_back</span>();<br>        &#125;<br>        q.<span class="hljs-built_in">push_back</span>(i);<br>        ans = <span class="hljs-built_in">max</span>(ans, sum[i] - sum[q[<span class="hljs-number">0</span>]]);<br>    &#125;<br>    cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p><a href="https://codeforces.com/problemset/problem/486/E">LIS of Sequence_277E</a></p><p><a href="https://blog.csdn.net/lxt_Lucia/article/details/81206439">LIS相关知识例题</a></p><p>输入 n(1≤n≤1e5) 和长为 n 的数组 a(1≤a[i]≤1e5)。</p><p>定义 LIS 为 a 的最长严格递增子序列。<br />对于每个 i：<br />如果 a[i] 不在任何 a 的 LIS 中，输出 1。<br />如果 a[i] 在 a 的一个 LIS，但不在所有 LIS 中，输出 2。<br />如果 a[i] 在 a 的所有 LIS 中，输出 3。<br />输出在同一行，不要加空格。</p><p>注意，a=[1,2,2,3] 有两个相同的 LIS [1,2,3]，其中 1 和 3 都在这两个 LIS 中，但 2 只在其中一个 LIS 不在另一个 LIS 中，所以输出 3223。</p><p>输入<br />1<br />4<br />输出 3</p><p>输入<br />4<br />1 3 2 5<br />输出 3223</p><p>输入<br />4<br />1 5 2 3<br />输出 3133</p><p><strong>Sol:</strong></p><p>计算 a[0] 到 a[i] 的，以 a[i] 结尾的 LIS 长度，记作 pre[i]。</p><p>计算 a[i] 到 a[n-1] 的，以 a[i] 开头的 LIS 长度，记作 suf[i]。</p><p>如果 pre[i] + suf[i] - 1 ≠ 整个数组的 LIS 长度，那么 a[i] 一定不在任何 LIS 中。（减一是因为 a[i] 算重复了） 否则，a[i] 是否一定在所有 LIS 中呢？</p><p>例如 a=[1,2,2,3]，这里的两个 2 对应的 pre[i] 是一样的，a[2]=2 虽然在 LIS 中，但不在所有 LIS 中。</p><p>（在 pre[i] + suf[i] - 1 = 整个数组的 LIS 长度的前提下）统计 pre[i] 的出现次数，如果只出现一次，那么 a[i] 一定在所有 LIS 中，否则 a[i] 不在所有 LIS 中。<a href="https://www.luogu.com.cn/article/m4267u8v">详细证明</a></p><p>关于 LIS 的二分做法，见 <a href="https://www.bilibili.com/video/BV1ub411Q7sB/">视频讲解</a></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-type">int</span> lis, a[N], lst[N], dp[N], dp2[N], cnt[N], tag[N];<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">binary_search</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span> </span>&#123;<br>    <span class="hljs-type">int</span> l = <span class="hljs-number">1</span>, r = lis, mid, ans = lis + <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (l &lt;= r) &#123;<br>        mid = (l + r) &gt;&gt; <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">if</span> (lst[mid] &gt;= x) &#123;<br>            ans = mid;<br>            r = mid - <span class="hljs-number">1</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            l = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> ans;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) cin &gt;&gt; a[i];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br>        dp[i] = <span class="hljs-built_in">binary_search</span>(a[i]);<br>        <span class="hljs-keyword">if</span> (dp[i] &gt; lis) <br>            lst[++lis] = a[i];<br>        <span class="hljs-keyword">else</span><br>            lst[dp[i]] = a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        dp2[i] = dp[i];<br>        a[i] = -a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n; i &gt;= <span class="hljs-number">1</span>; --i) &#123;<br>        dp[i] = <span class="hljs-built_in">binary_search</span>(a[i]);<br>        <span class="hljs-keyword">if</span> (dp[i] &gt; lis)<br>            lst[++lis] = a[i];<br>        <span class="hljs-keyword">else</span><br>            lst[dp[i]] = a[i];<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (dp[i] + dp2[i] - <span class="hljs-number">1</span> == lis)<br>++cnt[dp[i]];<br><span class="hljs-keyword">else</span><br>tag[i] = <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i) &#123;<br><span class="hljs-keyword">if</span> (tag[i])<br><span class="hljs-keyword">continue</span>;<br><span class="hljs-keyword">if</span> (cnt[dp[i]] == <span class="hljs-number">1</span>)<br>tag[i] = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">else</span><br>tag[i] = <span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; ++i)<br>cout &lt;&lt; tag[i];<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Algorithm</tag>
      
      <tag>Data Structure</tag>
      
      <tag>Dynamic Programming</tag>
      
      <tag>Greedy Algorithm</tag>
      
      <tag>Code Implementation</tag>
      
      <tag>Subsequence</tag>
      
      <tag>Prefix Sum</tag>
      
      <tag>Binary Search</tag>
      
      <tag>Segment Tree</tag>
      
      <tag>Competitive Programming</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>An Optimized Conflict-free Replicated Set</title>
    <link href="/2024/05/31/OR-Set/"/>
    <url>/2024/05/31/OR-Set/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="优化的无冲突复制集"><a class="markdownIt-Anchor" href="#优化的无冲突复制集"></a> <a href="https://arxiv.org/pdf/1210.3368">优化的无冲突复制集</a></h1><p><strong>补充：</strong><a href="https://developer.aliyun.com/article/635632">CRDT 解决最终一致问题的利器</a></p><p><strong>摘要：</strong></p><p>复制数据的最终一致性支持并发更新，减少延迟并提高容错能力，但放弃了强一致性。因此，一些云计算平台实现了最终一致的数据类型。</p><p>该集合是一种广泛且有用的抽象，并且已经提出了许多复制集设计。我们提出了一种推理抽象，即排列等价，它系统化了并发类型的预期并发语义的表征。在此框架下，我们提出了现有的无冲突复制数据类型之一：Observed-Remove Set(OR Set)。</p><p>此外，为了减少元数据的大小，我们提出了一种新的优化来避免墓碑。这种方法可以转换为其他数据类型，例如地图、图形或序列。</p><p>**关键词：**数据复制、乐观复制、交换操作</p><h2 id="1介绍"><a class="markdownIt-Anchor" href="#1介绍"></a> 1.介绍</h2><p>复制数据的最终一致性支持并发更新，减少延迟并提高容错能力，但放弃了强一致性（例如，线性化）。因此，一些云计算平台实现了最终一致的复制集。最终一致性，允许在不同的副本上并发更新，并期望副本最终会收敛。然而，解决并发更新的解决方案往往要么有限，要么非常复杂且容易出错。</p><p>我们遵循不同的方法：强最终一致性（SEC）要求任何一对并发更新都有确定的结果。因此，不同的副本可以并行更新，并发更新在本地解决，无需达成共识。一些简单的条件（例如，并发更新相互交换）足以确保 SEC。满足这些条件的数据类型称为无冲突复制数据类型 (CRDT)。CRDT 对象的副本可以在不同步的情况下进行更新，并且保证收敛。这种方法已在多个工作中采用。</p><p>该集是一种普遍的数据类型，可直接使用，也可以作为更复杂的数据类型（如地图或图形）的组件使用。本文重点介绍了最终一致性下集合的语义，并介绍了优化的集合实现，即优化的观察删除集。</p><h2 id="2排列等价原理"><a class="markdownIt-Anchor" href="#2排列等价原理"></a> 2.排列等价原理</h2><p>集合的顺序语义是众所周知的，并且由单独的更新定义，比如，{true}add(e){e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> S} (in “{pre-condition} computation {post-condition}” notation),其中S表示其抽象状态。然而，并发修改的语义尚未明确或由实现驱动。我们提出以下置换等价原理[2]来表达并发行为符合顺序规范：“<em>如果更新的所有顺序排列都会导致等效状态，那么还应该认为更新的并发执行会导致等效状态。</em>“对于某些更新 u 和 u<sup>'</sup> ，它意味着以下行为：</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mrow><mo fence="true">{</mo><mi>P</mi><mo fence="true">}</mo></mrow><mi>u</mi><mo separator="true">;</mo><msup><mi>u</mi><mi mathvariant="normal">‘</mi></msup><mrow><mo fence="true">{</mo><mi>Q</mi><mo fence="true">}</mo></mrow><mo>⋀</mo><mrow><mo fence="true">{</mo><mi>P</mi><mo fence="true">}</mo></mrow><mo separator="true">;</mo><mi>u</mi><mrow><mo fence="true">{</mo><msup><mi>Q</mi><mi mathvariant="normal">‘</mi></msup><mo fence="true">}</mo></mrow><mo>⋀</mo><mrow><mo fence="true">{</mo><mi>Q</mi><mo fence="true">}</mo></mrow><mo>⇔</mo><msup><mi>Q</mi><mi mathvariant="normal">‘</mi></msup><mo>⇒</mo><mrow><mo fence="true">{</mo><mi>P</mi><mo fence="true">}</mo></mrow><mi>u</mi><mi mathvariant="normal">∣</mi><mi mathvariant="normal">∣</mi><msup><mi>u</mi><mi mathvariant="normal">‘</mi></msup><mrow><mo fence="true">{</mo><mi>Q</mi><mo fence="true">}</mo></mrow></mrow><annotation encoding="application/x-tex">\left\{ P \right\}u;u^`\left\{ Q \right\}\bigwedge \left\{ P \right\};u\left\{ Q^` \right\}\bigwedge \left\{ Q \right\} \Leftrightarrow Q^` \Rightarrow \left\{ P \right\}u || u^`\left\{ Q \right\}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.6000100000000002em;vertical-align:-0.55001em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">u</span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">‘</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal">Q</span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋀</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mpunct">;</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">u</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;"><span class="delimsizing size1">{</span></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">‘</span></span></span></span></span></span></span></span><span class="mclose delimcenter" style="top:0em;"><span class="delimsizing size1">}</span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋀</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal">Q</span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇔</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.093548em;vertical-align:-0.19444em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">‘</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">⇒</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.149108em;vertical-align:-0.25em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="mclose delimcenter" style="top:0em;">}</span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">u</span><span class="mord">∣</span><span class="mord">∣</span><span class="mord"><span class="mord mathnormal">u</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8991079999999999em;"><span style="top:-3.113em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">‘</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="minner"><span class="mopen delimcenter" style="top:0em;">{</span><span class="mord mathnormal">Q</span><span class="mclose delimcenter" style="top:0em;">}</span></span></span></span></span></span></p><p>特别是对于复制集，置换等价原理要求 {e != f}add(e) || remove(f) {e <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>∈</mo></mrow><annotation encoding="application/x-tex">\in</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.5782em;vertical-align:-0.0391em;"></span><span class="mrel">∈</span></span></span></span> S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋀</mo></mrow><annotation encoding="application/x-tex">\bigwedge</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋀</span></span></span></span> f <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span></span></span></span></span> S},对于不同元素的操作或幂等操作也类似。只有 add(e) || remove(e) 对在原则上未指定，因为 add(e);remove(e) 与 remove(e);add(e) 不同。以下任何后置条件均可确保确定性结果：</p><p><img src="../imgs/OR-Set/image-20240529150255370.png" alt="result" /></p><p><img src="../imgs/OR-Set/image-20240529150326490.png" alt="图一：异常和正确设计的示例" /></p><p>其中 &lt;CLK 比较与操作相关的唯一时钟。请注意，并非所有并发语义都可以解释为顺序排列；例如，任何顺序执行都不会导致错误标记。</p><h2 id="3现有复制集设计的回顾"><a class="markdownIt-Anchor" href="#3现有复制集设计的回顾"></a> 3.现有复制集设计的回顾</h2><p>过去，已经提出了几种用于维护复制集的设计。其中大多数都违反了排列等价原理（图1）。例如，Amazon Dynamo 购物车 [3] 是使用支持读写（分配）操作的寄存器实现的，提供标准的顺序语义。当两个写入同时发生时，下一次读取将返回它们的并集。正如作者自己所指出的，如果并发更新，即使是在不相关的元素上，删除也可能会被撤消（图 1(a)）</p><p>Sovran等人。和Asian等人。提出了一个集合变体，C-Set，其中对于每个元素，关联的添加和删除更新都被计数。如果它们的差异为正，则该元素处于抽象状态。 C-Set 违反了排列等价原理（图 1(b)）。当按照草图将更新传递到两个副本时，添加和删除计数相等，即 e 不在抽象中，即使每个副本的最后更新是 add(e)。</p><h2 id="4add-wins复制集"><a class="markdownIt-Anchor" href="#4add-wins复制集"></a> 4.Add-wins复制集</h2><p>在第 2 节中，我们已经表明，当考虑对同一元素进行并发添加和删除操作时，可以选择多个后置条件之一。考虑到添加获胜语义的情况，我们现在回顾观察删除集或OR集的CRDT设计，然后引入保留OR集行为并大大提高其空间复杂度的优化设计。</p><p><img src="../imgs/OR-Set/image-20240529153647765.png" alt="图2: OR-Set: Add-wins replicated set " /></p><p>这些 CRDT 规范遵循一种新的表示法，具有基于状态和操作的混合更新传播。尽管这种混合模型的形式化以及检查是否符合 CRDT 要求的相关证明义务超出了本报告的范围，但从标准 CRDT 模型中很容易推断出符号。</p><p>**系统模型简介：**我们考虑在给定的一组进程/副本上复制的单个对象。对象的客户端可以在其选择的某个副本上调用操作，该副本称为操作的源。查询完全在源处执行。更新首先将其副作用应用于源副本，然后（最终）应用于该更新下游的所有副本。为此，更新被建模为更新对（p，u），其中包括两个操作，其中p是无副作用的prepare（-update）操作，u是effect（-update）操作；源原子地执行准备和效果；下游副本仅执行效果u。在基于状态和操作的混合建模中，副本状态可以通过应用效果操作或合并来自同一对象的另一个副本的状态来更改。副本状态的单调演化由每个 CRDT 规范提供的比较操作来描述。</p><h3 id="41-observed-remove-set"><a class="markdownIt-Anchor" href="#41-observed-remove-set"></a> 4.1 Observed Remove Set</h3><p>图 2 显示了我们对 add-wins 复制集 CRDT 的规范。其并发规范{P}u<sub>0</sub> || … || u<sub>n−1</sub>{Q} 对于每个元素 e 定义如下：</p><p><img src="../imgs/OR-Set/image-20240529154416539.png" alt="定义" /></p><p>为了实现 add-wins，其想法是通过添加一个隐藏的唯一标记 n 来区分 add(e) 的不同调用，并有效地存储 (e, n) 对。为了实现 add-wins，其想法是通过添加一个隐藏的唯一标记 n 来区分 add(e) 的不同调用，并有效地存储 (e, n) 对。通过将一对 (e, n) 添加到墓碑集来删除它。总是可以再次添加元素，因为新对 (e, n<sup>‘</sup> ) 始终使用新的标记，与旧的标记不同，n<sup>’</sup> != n。如果同时添加和删除相同的元素 e，则删除的更新准备仅涉及观察到的对 (e, n<sub>1</sub>),(e, n<sub>2</sub>), 。 。 。而不是同时添加的唯一对 (e, n<sup>'</sup> )。因此，add操作通过添加新对来获胜。我们将此对象称为“观察移除集”或“OR 集”。如图 1© 所示，OR-Set 不受困扰 C-Set 的异常影响。</p><p>空间复杂度：OR-Set 的有效负载大小在任何时刻都受到所有应用的添加（效果更新）操作的数量的限制。</p><h3 id="42-优化观察移除集"><a class="markdownIt-Anchor" href="#42-优化观察移除集"></a> 4.2 优化观察移除集</h3><p>与其他 CRDT 一样，OR-Set 设计广泛使用唯一标识符和逻辑删除。我们现在展示如何通过最小化所需的元数据来使 CRDT 变得实用。</p><p>立即丢弃逻辑删除：在比较两个有效载荷 P 和 P<sup>‘</sup> 时，分别包含一些元素 e 而另一个不包含元素，重要的是要知道 e 是最近添加到 P 中，还是最近从 P<sup>’</sup> 中删除。所呈现的 add-wins 集使用逻辑删除来明确回答这个问题，即使更新是无序传递的或多次传递的。</p><p>墓碑堆积（由于单调半晶格要求）;如果无法丢弃它们，则内存需求会随着操作次数的增加而增加。为了解决这个问题，Wuu 的 2P-Set 垃圾收集已经到处传递的墓碑，基本上是通过等待每个进程对其他进程的确认。这会增加通信和处理开销，并要求所有进程都正确无误。我们设计了一种新技术来消除没有这些限制的墓碑，并以可承受的成本提供无冲突的语义。我们以add-wins为例介绍我们的解决方案。</p><p>总而言之，在 OR-Set 中，添加元素 e 会为有效负载的 E 部分创建一个新的唯一 （e， n） 对。删除元素会将源中观察到的所有包含 e 的元素对从 E 移动到 T。请注意，在删除同一对 （e， n） 之前，添加一些对 （e， n） 总是会发生。如果仅按因果顺序传递更新，则添加始终在任何相关删除之前执行，并且在执行操作时不需要逻辑删除集 T。但是，我们还需要支持基于状态的合并，它连接了两个可能与 happens-before 无关的副本。合并两个副本时，其中只有一个副本具有某些对 （e， n），我们需要知道该对是否已添加到包含它的副本中，或者它是否在另一个副本中被删除。</p><p><img src="../imgs/OR-Set/image-20240529155544674.png" alt="图3:优化的OR-Set" /></p><p>我们利用这些观察结果提出了一种新颖的删除算法，该算法可以立即丢弃已删除的对，并安全地与合并一起使用。它紧凑地记录了发生前的信息，以总结已删除的元素。图 3 显示了基于此方法的优化 OR-Set （Opt-OR-Set）。</p><p>每个副本 i 都维护一个向量 v [5] 来总结它已经观察到的唯一标识符。副本 i 处的条目 v[j] = n 表示该副本观察到在 j 处生成的 n 个连续标识符：（1， j），（2， j）， . . . ，（n， j）。副本 i 将其本地计数器作为向量 v[i] 中的第 i 个条目，最初是 0。副本通过递增其本地计数器来生成新的唯一标识符 （c， i）。请注意，要汇总向量中的连续标识符，OptORSet 需要因果传递更新。</p><p>调用 add 时，源将其与由下一个本地计数器值和源副本标识符组成的唯一标识符相关联。当添加内容传递到下游副本时，仅当它之前未传递时，它才应该生效;为此，它会检查唯一标识符是否包含在下游副本的向量中。合并有效负载时，只有在以下情况下，元素才应处于合并状态：要么它在两个有效负载中（在图 3 中设置 M），要么它在本地有效负载中并且最近没有从远程有效负载中删除（设置 M<sup>‘</sup>），反之亦然（M<sup>’'</sup>），如果元素不在有效负载中，但其标识符反映在副本的向量中，则该元素已被删除。</p><p>这个方法可以推广到任何添加和删除元素的CRDT中，比如序列或图。</p><p>**合并重复添加：**原始 OR-Set 中内存增长的另一个来源是由于多次添加的元素。与墓碑类似，它们会为每个添加的唯一标识符污染状态。我们观察到，对于元素和源副本的每个组合，保留最新添加的标识符就足够了，该标识符包含以前添加的元素。OptORSet 规范通过丢弃不必要的标识符（集合 O）在添加和合并定义中利用了这一观察结果。</p><p>**空间复杂度：**OptORSet 集的有效载荷大小在任何时刻都以 O（|elements|n+n） 为界，其中 n 是系统中的进程数，|elements|是集合中存在的元素数。第一个分量对应于集合 E 中的最大时间戳数，第二个分量捕获向量 v 的大小。在常见情况下，重复调用添加的进程数可以被视为常量，有效负载大小为 O（|elements|+n）。</p><h2 id="5总结"><a class="markdownIt-Anchor" href="#5总结"></a> 5.总结</h2><p>无冲突复制数据类型 （CRDT） 允许系统维护多个数据副本，这些副本无需同步即可更新，同时保证强最终一致性。例如，这允许云基础设施在分布在较远地理距离的数据中心中维护数据副本，并且通过选择离客户端最近的数据中心仍可提供低访问延迟。</p><p>在本文中，我们回顾了现有的复制集设计，并在排列等效原则下与CRDT OR-Set设计进行了对比。考虑到基础 OR-Set 以牺牲可伸缩性为代价来支持简单性，我们引入了一种新的优化设计，即优化 OR-Set，它大大提高了其可伸缩性，并且应该有利于集和其他共享 OR-Set 设计技术的 CRDT 的高效实现。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据复制</tag>
      
      <tag>最终一致性</tag>
      
      <tag>乐观复制</tag>
      
      <tag>无冲突复制数据类型</tag>
      
      <tag>OR-Set</tag>
      
      <tag>优化</tag>
      
      <tag>并发更新</tag>
      
      <tag>CRDT</tag>
      
      <tag>容错能力</tag>
      
      <tag>云计算平台</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bitcoin</title>
    <link href="/2024/05/31/Bitcoin/"/>
    <url>/2024/05/31/Bitcoin/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="比特币点对点电子现金系统"><a class="markdownIt-Anchor" href="#比特币点对点电子现金系统"></a> 比特币：点对点电子现金系统</h1><h2 id="概要"><a class="markdownIt-Anchor" href="#概要"></a> 概要</h2><p>纯粹的点对点版本的电子现金将允许在线支付直接从一方发送到另一方，而无需通过金融机构。数字签名提供了部分解决方案，但如果仍然需要可信第三方来防止双重支出，那么主要的收益就会丧失。我们剔除了一种使用点对点网络来解决双重支出问题的解决方案。网络通过将交易散列到持续的基于散列的工作量证明链中来为交易添加时间戳，形成一条记录，如果不重做工作量证明就无法更改。最长的链不仅可以证明所见证的事件序列，还可以证明它来自最大的 CPU 算力池。只要大部分 CPU 能力由不合作攻击网络的节点控制，它们就会生成最长的链并超过攻击者。 网络本身需要最少的结构。消息以尽力而为的方式广播，节点可以随意离开和重新加入网络，接受最长的工作量证明链作为它们离开时发生的事情的证明。</p><h2 id="1介绍"><a class="markdownIt-Anchor" href="#1介绍"></a> 1.介绍</h2><p>互联网上的商务几乎完全依赖金融机构作为受信任的第三方来处理电子支付。虽然该系统对于大多数交易来说运行良好，但它仍然存在基于信任的模型的固有弱点。完全不可逆的交易实际上是不可能的，因为金融机构无法避免调解纠纷。调解费用增加了交易成本，限制了最低实际交易规模，切断了小额临时交易的可能性，而且丧失了为不可逆转的服务支付不可逆转付款的能力，其代价更大。 随着逆转的可能性，对信任的需求蔓延开来。商家必须对他们的顾客保持警惕，骚扰他们要求提供比原本需要的更多信息。一定比例的欺诈被认为是不可避免的。这些成本和支付的不确定性可以通过使用实物货币来避免，但不存在在没有可信方的情况下通过通信渠道进行支付的机制。</p><p>我们需要的是一种基于密码证明而不是信任的电子支付系统，允许任何两个愿意的一方直接相互交易，而不需要可信的第三方。在计算上无法逆转的交易将保护卖家免受欺诈，并且可以轻松实施常规托管机制来保护买家。在本文中，我们提出了一种解决双花问题的方案，使用点对点分布式时间戳服务器来生成交易时间顺序的计算证明。只要诚实节点共同控制比任何合作的攻击者节点组更多的 CPU 功率，系统就是安全的。</p><h2 id="2交易"><a class="markdownIt-Anchor" href="#2交易"></a> 2.交易</h2><p>我们将电子硬币定义为数字签名链。每个所有者通过对前一个交易的哈希值和下一个所有者的公钥进行数字签名并将其添加到硬币的末尾，将硬币转移到下一个所有者。收款人可以验证签名以验证所有权链。</p><p><img src="../imgs/Bitcoin/image-20240527164213042-17171632085221.png" alt="transaction verify&amp;sign" /></p><p>当然，问题是收款人无法验证其中一位所有者没有重复使用该货币。一个常见的解决方案是引入一个值得信赖的中央机构或铸币厂，检查每笔交易是否存在双重支出。每次交易后，硬币必须返回造币厂以发行新的硬币，并且只有直接从造币厂发行的硬币才被信任不会被双重花费。这个解决方案的问题在于，整个货币系统的命运取决于运营铸币厂的公司，每笔交易都必须经过他们，就像银行一样。</p><p>我们需要一种方法让收款人知道以前的所有者没有签署任何早期的交易。就我们的目的而言，最早的交易才是最重要的，因此我们不关心后来的双花尝试。确认不存在交易的唯一方法是了解所有交易。 在基于铸币厂的模型中，铸币厂了解所有交易并决定哪些交易先到达。为了在没有可信方的情况下实现这一目标，交易必须公开宣布，并且我们需要一个系统，让参与者就接收顺序的单一历史达成一致。收款人需要证明在每次交易时，大多数节点都同意这是第一个收到的交易。</p><h2 id="3时间戳服务器"><a class="markdownIt-Anchor" href="#3时间戳服务器"></a> 3.时间戳服务器</h2><p>我们提出的解决方案从时间戳服务器开始。时间戳服务器的工作原理是获取要加时间戳的项目块的哈希值并广泛发布该哈希值，例如在报纸或新闻组帖子中。显然，时间戳证明数据当时必须存在，才能进入哈希值。每个时间戳在其散列中都包含前一个时间戳，形成一条链，每个附加时间戳都会增强其之前的时间戳。</p><p><img src="../imgs/Bitcoin/image-20240527165307708.png" alt="哈希链" /></p><h2 id="4工作量证明"><a class="markdownIt-Anchor" href="#4工作量证明"></a> 4.工作量证明</h2><p>为了在点对点的基础上实现分布式时间戳服务器，我们需要使用类似于Adam Back的Hashcash的工作量证明系统，而不是报纸或Usenet帖子。工作量证明涉及扫描一个值，该值在进行哈希处理（例如使用 SHA-256）时，哈希值以多个零位开始。所需的平均工作量与所需的零位数量成指数关系，并且可以通过执行单个哈希来验证。</p><p>对于我们的时间戳网络，我们通过增加块中的随机数来实现工作量证明，直到找到一个值，该值为块的哈希提供所需的零位。一旦花费了 CPU 的努力来满足工作量证明，则在不重做工作的情况下无法更改块。由于后面的块链接在它后面，因此更改块的工作将包括重做它后面的所有块。</p><p><img src="../imgs/Bitcoin/image-20240527165923261.png" alt="pow" /></p><p>工作量证明还解决了确定多数决策中的代表性问题。 如果多数是基于一IP地址一票，那么任何能够分配多个IP的人都可能会颠覆它。工作量证明本质上是一 CPU 一投票。 多数决定由最长的链代表，该链投入了最大的工作量证明努力。如果大部分CPU算力由诚实节点控制，那么诚实链将增长最快并超过任何竞争链。要修改过去的区块，攻击者必须重做该区块及其后所有区块的工作量证明，然后赶上并超越诚实节点的工作量。稍后我们将证明，随着后续块的添加，速度较慢的攻击者追上的可能性呈指数级下降。</p><p>为了补偿不断增加的硬件速度和随着时间的推移对运行节点的兴趣的变化，工作量证明难度由针对每小时平均块数的移动平均值确定。如果它们生成得太快，难度就会增加。</p><h2 id="5网络"><a class="markdownIt-Anchor" href="#5网络"></a> 5.网络</h2><p>运行网络的步骤如下：</p><ol><li>新交易被广播到所有节点</li><li>每个节点将新交易收集到一个块中</li><li>每个节点都致力于为其区块寻找一个困难的工作量证明</li><li>当节点找到工作量证明时，它会将块广播到所有节点</li><li>仅当块中的所有交易均有效且尚未花费时，节点才会接受该块</li><li>节点通过使用已接受块的哈希作为前一个哈希来创建链中的下一个块来表达对块的接受</li></ol><p>节点始终认为最长的链是正确的，并将继续努力扩展它。如果两个节点同时广播下一个区块的不同版本，则某些节点可能会先接收其中一个。在这种情况下，他们会处理收到的第一个分支，但保存另一个分支，以防它变得更长。当找到下一个工作量证明并且一个分支变得更长时，平局就会被打破； 然后，在另一个分支上工作的节点将切换到较长的分支。</p><p>新的交易广播不一定需要到达所有节点。只要到达很多节点，不久就会进入区块。块广播还可以容忍丢失的消息。 如果一个节点没有收到一个块，它会在收到下一个块并意识到它错过了一个块时请求它。</p><h2 id="6激励"><a class="markdownIt-Anchor" href="#6激励"></a> 6.激励</h2><p>按照惯例，区块中的第一笔交易是一项特殊交易，它启动了该区块创建者拥有的新硬币。这增加了节点支持网络的激励，并提供了一种最初将硬币分配到流通中的方法，因为没有中央机构来发行它们。稳定增加一定数量的新硬币类似于金矿开采者消耗资源以将黄金添加到流通中。 在我们的例子中，消耗的是 CPU 时间和电力。</p><p>该激励措施也可以通过交易费来资助。 如果交易的输出值小于其输入值，则差额就是交易费用，该费用将添加到包含该交易的区块的激励值中。一旦预定数量的代币进入流通，激励措施就可以完全转变为交易费用，并且完全不受通货膨胀影响。</p><p>这种激励措施可能有助于鼓励节点保持诚实。如果贪婪的攻击者能够聚集比所有诚实节点更多的 CPU 算力，他将不得不选择是用它来偷回他的付款来欺骗人们，还是用它来生成新的硬币。他应该发现遵守规则更有利可图，这些规则有利于他获得比其他人加起来更多的新硬币，而不是破坏系统和他自己财富的有效性。</p><h2 id="7回收磁盘空间"><a class="markdownIt-Anchor" href="#7回收磁盘空间"></a> 7.回收磁盘空间</h2><p>一旦硬币中的最新交易被埋在足够多的区块下，之前花费的交易就可以被丢弃以节省磁盘空间。为了在不破坏区块哈希的情况下实现这一点，交易在默克尔树中进行哈希处理，只有根包含在区块的哈希中。然后可以通过砍掉树的树枝来压缩旧块。不需要存储内部哈希值。</p><p><img src="../imgs/Bitcoin/image-20240527171755629.png" alt="Merkle Tree" /></p><p>没有交易的块头大约为 80 字节。 如果我们假设每 10 分钟生成一个块，则每年 80 字节 * 6 * 24 * 365 = 4.2MB。截至 2008 年，计算机系统通常配备 2GB RAM，并且摩尔定律预测当前每年增长 1.2GB，因此即使块头必须保存在内存中，存储也不应该成为问题。</p><h2 id="8简化的付款验证"><a class="markdownIt-Anchor" href="#8简化的付款验证"></a> 8.简化的付款验证</h2><p>无需运行完整的网络节点即可验证付款。用户只需要保留最长的工作证明链的块标头的副本，他可以通过查询网络节点来获得，直到他确信自己拥有最长的链条，并获得将交易链接到块的默克尔分支它是时间戳。他无法自己检查交易，但通过将其链接到链中的某个位置，他可以看到网络节点已接受该交易，并在进一步确认网络已接受该交易后添加区块。</p><p><img src="../imgs/Bitcoin/image-20240527172238185.png" alt="work chain" /></p><p>因此，只要诚实的节点控制网络，验证就是可靠的，但如果网络被攻击者压倒，验证就更容易受到攻击。虽然网络节点可以自行验证交易，但只要攻击者能够继续压制网络，简化的方法就可能会被攻击者捏造的交易所欺骗。防止这种情况的一种策略是，当网络节点检测到无效块时，接受来自网络节点的警报，提示用户的软件下载完整的块，并发出警报交易以确认不一致。经常收到付款的企业可能仍然希望运行自己的节点，以获得更独立的安全性和更快的验证。</p><h2 id="9合并和分割值"><a class="markdownIt-Anchor" href="#9合并和分割值"></a> 9.合并和分割值</h2><p>尽管可以单独处理硬币，但为转账中的每一分钱进行单独的交易会很麻烦。为了允许拆分和组合价值，事务包含多个输入和输出。通常，要么有一个来自较大先前交易的输入，要么来自多个输入组合较小的金额，最多有两个输出：一个用于付款，另一个将零钱（如果有）退还给发送者。</p><p>应该注意的是，扇出（其中一个事务依赖于多个事务，而这些事务又依赖于更多事务）在这里不是问题。 永远不需要提取交易历史记录的完整独立副本。</p><h2 id="10隐私"><a class="markdownIt-Anchor" href="#10隐私"></a> 10.隐私</h2><p>传统的银行模式通过限制相关方和受信任的第三方对信息的访问来实现一定程度的隐私。公开宣布所有交易的必要性排除了这种方法，但仍然可以通过在另一个地方中断信息流来维护隐私：通过保持公钥匿名。公众可以看到有人正在向其他人发送金额，但没有将交易与任何人联系起来的信息。 这类似于证券交易所发布的信息水平，其中个别交易的时间和规模，即“磁带”，是公开的，但没有说明各方是谁。</p><p><img src="../imgs/Bitcoin/image-20240527173756903.png" alt="Model" /></p><p>作为额外的防火墙，应为每个事务使用新的密钥对，以防止它们链接到共同所有者。 对于多输入交易，某些链接仍然是不可避免的，这必然表明它们的输入由同一所有者拥有。 风险在于，如果密钥的所有者被泄露，链接可能会泄露属于同一所有者的其他事务。</p><h2 id="11计算"><a class="markdownIt-Anchor" href="#11计算"></a> 11.计算</h2><p>我们考虑攻击者试图比诚实链更快地生成替代链的情况。即使实现了这一点，它也不会让系统接受任意更改，例如凭空创造价值或拿走不属于攻击者的金钱。节点不会接受无效的交易作为付款，诚实的节点也永远不会接受包含它们的区块。攻击者只能尝试更改自己的一笔交易来取回他最近花费的钱。</p><p>诚实链和攻击者链之间的竞争可以被描述为二项式随机游走。成功事件是诚实链延长一个区块，领先优势增加+1，失败事件是攻击者链延长一个区块，差距缩小-1。</p><p>攻击者追赶给定赤字的概率类似于赌徒破产问题。假设一个拥有无限信用的赌徒从赤字开始，并可能进行无限次尝试以试图达到收支平衡。我们可以计算他达到盈亏平衡的概率，或者攻击者追上诚实链的概率，如下所示：</p><p>p = 诚实节点找到下一个块的概率 q = 攻击者找到下一个块的概率 q<sub>z</sub> = 攻击者从后面的 z 个区块追上的概率</p><p><img src="../imgs/Bitcoin/image-20240527174845198.png" alt="formula1" /></p><p>鉴于我们假设 p &gt; q，随着攻击者必须追上的区块数量增加，概率呈指数下降。在形势对他不利的情况下，如果他没有尽早幸运地向前冲，随着他越来越落后，他的机会就会变得微乎其微。</p><p>我们现在考虑新交易的接收者需要等待多长时间才能充分确定发送者无法更改交易。我们假设发送者是一个攻击者，他想让接收者相信他已经支付了他一段时间，然后在一段时间过后将其转回给自己。当这种情况发生时，接收者会收到警报，但发送者希望为时已晚。</p><p>接收方生成一个新的密钥对，并在签名前不久将公钥提供给发送方。这可以防止发送者通过连续处理来提前准备一系列区块，直到他足够幸运地提前足够远，然后在那一刻执行交易。一旦交易被发送，不诚实的发送者就开始在包含其交易的替代版本的平行链上秘密工作。</p><p>接收者等待，直到交易被添加到一个块中并且 z 个块已链接到它之后。他不知道攻击者取得了多少进展，但假设诚实的区块花费了每个区块的平均预期时间，那么攻击者的潜在进展将是具有期望值的泊松分布：</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>λ</mi><mo>=</mo><mi>z</mi><mfrac><mi>q</mi><mi>p</mi></mfrac></mrow><annotation encoding="application/x-tex">\lambda=z\frac{q}{p}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal">λ</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.228608em;vertical-align:-0.481108em;"></span><span class="mord mathnormal" style="margin-right:0.04398em;">z</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.7475em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight">p</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.446108em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.03588em;">q</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.481108em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>​</p><p>为了得到攻击者现在仍然可以追上的概率，我们将他可以取得的每个进展量的泊松密度乘以他从那时起可以追上的概率：</p><p><img src="../imgs/Bitcoin/image-20240528150310073.png" alt="prob" /></p><p>重新排列以避免对分布的无限尾部求和…</p><p><img src="../imgs/Bitcoin/image-20240528150345475.png" alt="prob" /></p><p>转换为C代码</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;math.h&gt;</span> </span><br><span class="hljs-type">double</span> <span class="hljs-title function_">AttackerSuccessProbability</span><span class="hljs-params">(<span class="hljs-type">double</span> q, <span class="hljs-type">int</span> z)</span> <br>&#123;<br><span class="hljs-type">double</span> p = <span class="hljs-number">1.0</span> - q;<br><span class="hljs-type">double</span> lambda = z * (q / p);<br><span class="hljs-type">double</span> sum = <span class="hljs-number">1.0</span>;<br><span class="hljs-type">int</span> i, k;<br><span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= z; k++)<br>&#123;<br><span class="hljs-type">double</span> poisson = <span class="hljs-built_in">exp</span>(-lambda);<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i++)<br>poisson *= lambda / i;<br>sum -= poisson * (<span class="hljs-number">1</span> - <span class="hljs-built_in">pow</span>(q / p, z - k));<br>&#125;<br><span class="hljs-keyword">return</span> sum; <br>&#125; <br></code></pre></td></tr></table></figure><p>运行一些结果，我们可以看到概率随 z 呈指数下降</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-attribute">q</span>=0.1 <br><span class="hljs-attribute">z</span>=0    <span class="hljs-attribute">P</span>=1.0000000 <br><span class="hljs-attribute">z</span>=1    <span class="hljs-attribute">P</span>=0.2045873 <br><span class="hljs-attribute">z</span>=2    <span class="hljs-attribute">P</span>=0.0509779 <br><span class="hljs-attribute">z</span>=3    <span class="hljs-attribute">P</span>=0.0131722 <br><span class="hljs-attribute">z</span>=4    <span class="hljs-attribute">P</span>=0.0034552 <br><span class="hljs-attribute">z</span>=5    <span class="hljs-attribute">P</span>=0.0009137 <br><span class="hljs-attribute">z</span>=6    <span class="hljs-attribute">P</span>=0.0002428 <br><span class="hljs-attribute">z</span>=7    <span class="hljs-attribute">P</span>=0.0000647 <br><span class="hljs-attribute">z</span>=8    <span class="hljs-attribute">P</span>=0.0000173 <br><span class="hljs-attribute">z</span>=9    <span class="hljs-attribute">P</span>=0.0000046 <br><span class="hljs-attribute">z</span>=10   <span class="hljs-attribute">P</span>=0.0000012 <br><br><span class="hljs-attribute">q</span>=0.3 <br><span class="hljs-attribute">z</span>=0    <span class="hljs-attribute">P</span>=1.0000000 <br><span class="hljs-attribute">z</span>=5    <span class="hljs-attribute">P</span>=0.1773523 <br><span class="hljs-attribute">z</span>=10   <span class="hljs-attribute">P</span>=0.0416605 <br><span class="hljs-attribute">z</span>=15   <span class="hljs-attribute">P</span>=0.0101008 <br><span class="hljs-attribute">z</span>=20   <span class="hljs-attribute">P</span>=0.0024804 <br><span class="hljs-attribute">z</span>=25   <span class="hljs-attribute">P</span>=0.0006132 <br><span class="hljs-attribute">z</span>=30   <span class="hljs-attribute">P</span>=0.0001522 <br><span class="hljs-attribute">z</span>=35   <span class="hljs-attribute">P</span>=0.0000379 <br><span class="hljs-attribute">z</span>=40   <span class="hljs-attribute">P</span>=0.0000095 <br><span class="hljs-attribute">z</span>=45   <span class="hljs-attribute">P</span>=0.0000024 <br><span class="hljs-attribute">z</span>=50   <span class="hljs-attribute">P</span>=0.0000006<br></code></pre></td></tr></table></figure><p>求解 P 小于 0.1%…</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs routeros">P &lt; 0.001 <br><span class="hljs-attribute">q</span>=0.10   <span class="hljs-attribute">z</span>=5 <br><span class="hljs-attribute">q</span>=0.15   <span class="hljs-attribute">z</span>=8 <br><span class="hljs-attribute">q</span>=0.20   <span class="hljs-attribute">z</span>=11 <br><span class="hljs-attribute">q</span>=0.25   <span class="hljs-attribute">z</span>=15 <br><span class="hljs-attribute">q</span>=0.30   <span class="hljs-attribute">z</span>=24 <br><span class="hljs-attribute">q</span>=0.35   <span class="hljs-attribute">z</span>=41 <br><span class="hljs-attribute">q</span>=0.40   <span class="hljs-attribute">z</span>=89 <br><span class="hljs-attribute">q</span>=0.45   <span class="hljs-attribute">z</span>=340 <br></code></pre></td></tr></table></figure><h2 id="12总结"><a class="markdownIt-Anchor" href="#12总结"></a> 12.总结</h2><p>我们提出了一种不依赖信任的电子交易系统。我们从由数字签名制成的通常的硬币框架开始，它提供了对所有权的强大控制，但如果没有防止双重支出的方法，它是不完整的。为了解决这个问题，我们提出了一个点对点网络，它使用工作量证明来记录交易的公共历史记录，如果诚实的节点控制了大部分的CPU能力，攻击者很快就会在计算上变得不切实际。该网络因其非结构化的简单性而非常强大。 节点同时工作，几乎不需要协调。它们不需要被识别，因为消息不会路由到任何特定的地方，只需要尽力传递。节点可以随意离开和重新加入网络，接受工作量证明链作为它们离开时发生的事情的证明。他们用自己的 CPU 能力进行投票，通过扩展有效块来表达对有效块的接受，并通过拒绝处理无效块来表达对无效块的接受。任何需要的规则和激励措施都可以通过这种共识机制来执行。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>6.824</tag>
      
      <tag>分布式系统</tag>
      
      <tag>比特币</tag>
      
      <tag>电子现金</tag>
      
      <tag>区块链</tag>
      
      <tag>点对点网络</tag>
      
      <tag>双重支出</tag>
      
      <tag>数字签名</tag>
      
      <tag>工作量证明</tag>
      
      <tag>加密货币</tag>
      
      <tag>交易验证</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>troubleshooting-1</title>
    <link href="/2024/05/24/troubleshooting-1/"/>
    <url>/2024/05/24/troubleshooting-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="524-问题排查"><a class="markdownIt-Anchor" href="#524-问题排查"></a> 5.24-问题排查</h1><h2 id="rocketmq消息堆积问题排查"><a class="markdownIt-Anchor" href="#rocketmq消息堆积问题排查"></a> RocketMQ消息堆积问题排查</h2><h3 id="问题现象"><a class="markdownIt-Anchor" href="#问题现象"></a> 问题现象</h3><p>负责的业务中有一个应用因为特殊原因，需要修改消息配置（将Spring Cloud Stream 改为 RocketMQ native），修改前和修改后的配置项如下：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.cloud.stream.bindings.consumerA.group</span>=<span class="hljs-string">CID_CONSUMER_A</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerA.contentType</span>=<span class="hljs-string">text/plain</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerA.destination</span>=<span class="hljs-string">CONSUMER_A_TOPIC</span><br><span class="hljs-attr">spring.cloud.stream.rocketmq.bindings.consumerA.consumer.tags</span>=<span class="hljs-string">CONSUMER_A_TOPIC_TAG</span><br><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.group</span>=<span class="hljs-string">CID_CONSUMER_A</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.contentType</span>=<span class="hljs-string">text/plain</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.destination</span>=<span class="hljs-string">CONSUMER_B_TOPIC</span><br><span class="hljs-attr">spring.cloud.stream.rocketmq.bindings.consumerB.consumer.tags</span>=<span class="hljs-string">CONSUMER_B_TOPIC_TAG</span><br><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.group</span>=<span class="hljs-string">CID_CONSUMER_A</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.contentType</span>=<span class="hljs-string">text/plain</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.destination</span>=<span class="hljs-string">CONSUMER_C_TOPIC</span><br><span class="hljs-attr">spring.cloud.stream.rocketmq.bindings.consumerC.consumer.tags</span>=<span class="hljs-string">CONSUMER_C_TOPIC_TAG</span><br></code></pre></td></tr></table></figure><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rocketmq.consumers[0].consumer-group</span>=<span class="hljs-string">CID_CONSUMER_A</span><br><span class="hljs-attr">spring.rocketmq.consumers[0].topic</span>=<span class="hljs-string">CONSUMER_A_TOPIC</span><br><span class="hljs-attr">spring.rocketmq.consumers[0].sub-expression</span>=<span class="hljs-string">CONSUMER_A_TOPIC_TAG</span><br><span class="hljs-attr">spring.rocketmq.consumers[0].message-listener-ref</span>=<span class="hljs-string">consumerAListener</span><br><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.group</span>=<span class="hljs-string">CID_CONSUMER_A</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.contentType</span>=<span class="hljs-string">text/plain</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.destination</span>=<span class="hljs-string">CONSUMER_B_TOPIC</span><br><span class="hljs-attr">spring.cloud.stream.rocketmq.bindings.consumerB.consumer.tags</span>=<span class="hljs-string">CONSUMER_B_TOPIC_TAG</span><br><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.group</span>=<span class="hljs-string">CID_CONSUMER_A</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.contentType</span>=<span class="hljs-string">text/plain</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.destination</span>=<span class="hljs-string">CONSUMER_C_TOPIC</span><br><span class="hljs-attr">spring.cloud.stream.rocketmq.bindings.consumerC.consumer.tags</span>=<span class="hljs-string">CONSUMER_C_TOPIC_TAG</span><br></code></pre></td></tr></table></figure><p>但是机器发布一半后开始灰度观察的时候，出现了消息堆积问题</p><h3 id="问题原因"><a class="markdownIt-Anchor" href="#问题原因"></a> 问题原因</h3><h4 id="消息订阅关系不一致"><a class="markdownIt-Anchor" href="#消息订阅关系不一致"></a> 消息订阅关系不一致</h4><p>经过历史经验和踩坑，感觉有可能是订阅组机器订阅关系不一致导致的消息堆积问题（因为订阅组的机器有的订阅关系是A，有的是B，MQ不能确定是否要消费，就能只能先堆积到broker中），查看MQ控制台后发现，确实是消息订阅关系不一致，导致消息堆积</p><h4 id="spring-cloud-stream-和-rocketmq-native"><a class="markdownIt-Anchor" href="#spring-cloud-stream-和-rocketmq-native"></a> Spring Cloud Stream 和 RocketMQ Native</h4><p>所以就引申出了一个问题，为什么将Spring Cloud Stream修改为原生的MetaQ之后，同一个ConsumerId对应的订阅关系就会改变呢？</p><p>更简单来说，就是为什么当RocketMQ和Spring Cloud Stream 使用相同的ComsumerId之后，RocketMQ的订阅关系会把Spring Cloud Stream的订阅关系给冲掉呢？</p><blockquote><p>注意，一个consumerId是可以订阅多个topic的</p></blockquote><h5 id="rocketmq"><a class="markdownIt-Anchor" href="#rocketmq"></a> RocketMQ</h5><p>client的类图如下：</p><p><img src="../imgs/troubleshooting-1/image-20240524222103739.png" alt="RocketMQ client" /></p><ul><li>MQConsumerInner：记录当前consumerGroup和服务端的交互方式，以及topic和tag的映射关系。默认的实现时DefaultMQPushConsumerImpl，和consumerGroup的对应关系是1:1</li><li>MQClientInstance：统一管理网络连接等可以复用的对象，通过Map维护了ConsumerGroupId和MQConsumerInner的映射关系。简单来说，就是一个ConsumerGroup，只能对应一个MQConsumer</li></ul><h5 id="spring-cloud-stream"><a class="markdownIt-Anchor" href="#spring-cloud-stream"></a> Spring Cloud Stream</h5><p><img src="../imgs/troubleshooting-1/image-20240524222138611.png" alt="Spring Cloud Stream" /></p><p>Spring Cloud Stream是连接Spring和中间件的一个胶水层，在Spring Cloud Stream启动的时候，也会注册一个ConsumerGourp</p><h3 id="问题根因"><a class="markdownIt-Anchor" href="#问题根因"></a> 问题根因</h3><p>分析到这里，原因就已经很明显了。Spring Cloud Stream会在启动的时候自己new一个MetaPushConsumer（事实上就是一个新的MQConsumerInner），所以对于一个ConsumerGroup来说，就存在了两个MQConsumerInner，这显然是不符合RocketMQ要求的1:1的映射关系的，所以RocketMQ默认会用新的映射代替老的映射关系。显然，Spring Cloud Stream的被RocketMQ原生的给替代掉了。</p><p>这也就是为什么已经发布的机器中，对于ConsumerA来说，只剩下RocketMQ原生的那组订阅关系了</p><h3 id="解决思路"><a class="markdownIt-Anchor" href="#解决思路"></a> 解决思路</h3><p>修改consumerId</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring.rocketmq.consumers[0].consumer-group</span>=<span class="hljs-string">CID_CONSUMER_A</span><br><span class="hljs-attr">spring.rocketmq.consumers[0].topic</span>=<span class="hljs-string">CONSUMER_A_TOPIC</span><br><span class="hljs-attr">spring.rocketmq.consumers[0].sub-expression</span>=<span class="hljs-string">CONSUMER_A_TOPIC_TAG</span><br><span class="hljs-attr">spring.rocketmq.consumers[0].message-listener-ref</span>=<span class="hljs-string">consumerAListener</span><br><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.group</span>=<span class="hljs-string">CID_CONSUMER_B</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.contentType</span>=<span class="hljs-string">text/plain</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerB.destination</span>=<span class="hljs-string">CONSUMER_B_TOPIC</span><br><span class="hljs-attr">spring.cloud.stream.rocketmq.bindings.consumerB.consumer.tags</span>=<span class="hljs-string">CONSUMER_B_TOPIC_TAG</span><br><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.group</span>=<span class="hljs-string">CID_CONSUMER_B</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.contentType</span>=<span class="hljs-string">text/plain</span><br><span class="hljs-attr">spring.cloud.stream.bindings.consumerC.destination</span>=<span class="hljs-string">CONSUMER_C_TOPIC</span><br><span class="hljs-attr">spring.cloud.stream.rocketmq.bindings.consumerC.consumer.tags</span>=<span class="hljs-string">CONSUMER_C_TOPIC_TAG</span><br></code></pre></td></tr></table></figure><h3 id="思考与总结"><a class="markdownIt-Anchor" href="#思考与总结"></a> 思考与总结</h3><ol><li>问题原因并不复杂，但是很多人可能分析到第一层（订阅关系不一致导致消费堆积）就不会再往下分析了，但是我们还需要有更深入的探索精神的</li><li>生产环境中尽量不要搞两套配置项，会额外增加理解成本。。。。</li></ol>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>troubleshooting</tag>
      
      <tag>RocketMQ</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>scene-question-1</title>
    <link href="/2024/05/24/scene-question-1/"/>
    <url>/2024/05/24/scene-question-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="524-场景题"><a class="markdownIt-Anchor" href="#524-场景题"></a> 5.24-场景题</h1><h2 id="订单到期关闭如何实现"><a class="markdownIt-Anchor" href="#订单到期关闭如何实现"></a> 订单到期关闭如何实现</h2><h3 id="典型回答"><a class="markdownIt-Anchor" href="#典型回答"></a> 典型回答</h3><p>在电商、支付等系统中，一般都是先创建订单（支付单），再给用户一定的时间进行支付，如果没有按时支付的话，就需要把之前的订单（支付单）取消掉。这种类似的场景很多，比如到期自动收货、超时自动退款、下单后自动发送短信等等都是类似的业务问题。</p><p>订单到期关闭的实现有很多种方式，分别有：</p><ol><li>被动关闭（不推荐）</li><li>定时任务（<strong>推荐</strong>，适合时间精确度要求不高的场景）</li><li>DelayQueue（不推荐，基于内存，无法持久化）</li><li>时间轮（不推荐，基于内存，无法持久化）</li><li>kafka（MQ方案不推荐，大量无效调度）</li><li>RocketMQ延迟消息（MQ方案不推荐，大量无效调度）</li><li>RabbitMQ死信队列（MQ方案不推荐，大量无效调度）</li><li>RabbitMQ插件（MQ方案不推荐，大量无效调度）</li><li>Redis过期监听（不推荐，容易丢消息）</li><li>Redis的ZSet（不推荐，可能会重复消费）</li><li>Redisson（<strong>推荐</strong>，可以用）</li></ol><h3 id="实现复杂度包含用到的框架的依赖及部署"><a class="markdownIt-Anchor" href="#实现复杂度包含用到的框架的依赖及部署"></a> 实现复杂度（包含用到的框架的依赖及部署）</h3><p>Redisson &gt; RabbitMQ插件 &gt; RabbitMQ死信队列 &gt; RocketMQ延迟消费 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mrel">≈</span></span></span></span> Redis的zset &gt;  Redis过期监听 <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>≈</mo></mrow><annotation encoding="application/x-tex">\approx</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.48312em;vertical-align:0em;"></span><span class="mrel">≈</span></span></span></span> kafka时间轮 &gt; 定时任务 &gt; Netty的时间轮 &gt; JDK自带的DelayQueue &gt; 被动关闭</p><p>不同场景中也适合不同方案:</p><ul><li>自己玩：被动关闭</li><li>单体应用，业务量不大：Netty的时间轮、JDK自带的DelayQueue、定时任务</li><li>分布式应用，业务量不大：Redis过期监听、RabbitMQ死信队列、Redis的zset、定时任务</li><li>分布式应用、业务量大、并发高:Redisson、RabbitMQ插件、kafka时间轮、Rocket延迟任务、定时任务</li><li>业务量特别大：定时任务</li></ul><p>总体考虑到成本、方案完整性、以及方案的复杂度，还有用到的第三方框架的流行度，优先考虑定时任务、Redisson+Redis、RabbitMQ插件、RocketMQ延迟消息等方案</p><p>但是，如果考虑到订单到期关闭的业务特点，如果在订单量特别大的时候，MQ其实并不适合：</p><p><a href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E5%BB%BA%E8%AE%AE%E4%BD%BF%E7%94%A8MQ%E5%AE%9E%E7%8E%B0%E8%AE%A2%E5%8D%95%E5%88%B0%E6%9C%9F%E5%85%B3%E9%97%AD%EF%BC%9F">为什么不建议使用MQ实现订单到期关闭?</a> //todo</p><h2 id="扩展知识"><a class="markdownIt-Anchor" href="#扩展知识"></a> 扩展知识</h2><h3 id="i-被动关闭"><a class="markdownIt-Anchor" href="#i-被动关闭"></a> I、被动关闭</h3><p>简单来说，就是订单创建好之后。我们系统上不做主动关单，什么时候用户来访问这个订单了，再去判断时间是不是超过了过期时间，如果过了时间就进行关单操作，然后再提示用户。</p><p>这种做法是最简单的，基本不需要开发定时关闭的功能，但是他的缺点也很明显，那就是如果用户一直不来查看这个订单，那么就会有很多脏数据冗余在数据库中一直无法被关单。</p><p>还有一个缺点，那就是需要在用户的查询过程中进行写的操作，一般写操作都会比读操作更耗时，而且有失败的可能，一旦关单失败了，就会导致系统处理起来比较复杂。</p><h3 id="ii-定时任务"><a class="markdownIt-Anchor" href="#ii-定时任务"></a> II、定时任务</h3><p>具体实现细节就是我们通过一些调度平台来实现定时执行任务，任务就是去扫描所有到期的订单，然后执行关单动作。</p><p>这个方案的有点也是比较简单，实现起来很容易，基于Timer、ScheduledThreadPoolExecutor、或者像xxl-job这类调度框架都能实现，但是有以下几个问题：</p><ol><li>**时间不精确：**一般定时任务基于固定的频率、按照时间定时执行的，那么就可能会发生很多订单已经到了超时时间，但是定时任务的调度时间还没到，那么就会导致这些订单的实际关闭时间要比应该关闭的时间晚一些。</li><li>**无法处理大量订单：**定时任务的方式是会把本来比较分散的关闭时间集中到任务调度的那一段时间，如果订单量比较大的话，那么就会导致任务执行时间很长，整个任务的时间越长，订单被扫描到时间可能就很晚，那么就会导致关闭时间更晚。</li><li>**对数据库造成压力：**定时任务集中扫表，这会使得数据库IO在短时间内被大量占用和消耗，如果没有做好隔离，并且业务量比较大的话，就可能会影响到线上的正常业务。</li><li>**分库分表问题：**订单系统，一旦订单量大就可能会考虑分库分表，在分库分表中进行全表扫描，这是一个极不推荐的方案。</li></ol><p>解决方案如下：</p><p><a href="#%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%89%AB%E8%A1%A8%E7%9A%84%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88">定时任务扫表的问题解决方案</a></p><p>所以，定时任务的方案，适合对时间精确度要求不高、并且业务量不是很大的场景中。如果对时间精度要求比较高，这种方案不适用。（但是一般来说，订单的到期关闭这种业务，对时间精确度要求并不高，所以定时任务也是使用的最广泛的一种方案）</p><h3 id="iii-jdk自带的delayqueue"><a class="markdownIt-Anchor" href="#iii-jdk自带的delayqueue"></a> III、JDK自带的DelayQueue</h3><p>有这样一种方案，他不需要借助任何外部的资源，直接基于应用自身就能实现，那就是基于JDK自带的DelayQueue来实现。</p><blockquote><p><strong>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。</strong></p></blockquote><p>基于延迟队列，是可以实现订单的延迟关闭的，首先，在用户创建订单的时候，把订单加入到DelayQueue中，然后，还需要一个常驻任务不断的从队列中取出那些到了超时时间的订单，然后在把他们进行关单，之后再从队列中删除掉。</p><p>这个方案需要有一个线程，不断的从队列中取出需要关单的订单。一般在这个线程中需要加一个while(true)循环，这样才能确保任务不断的执行并且能够及时的取出超时订单。<br />使用DelayQueue实现超时关单的方案，实现起来简单，不须要依赖第三方的框架和类库，JDK原生就支持了。</p><p>当然这个方案也不是没有缺点的，首先，基于DelayQueue的话，需要把订单放进去，那如果订单量太大的话，可能会导致OOM的问题；另外，DelayQueue是基于JVM内存的，一旦机器重启了，里面的数据就都没有了。虽然我们可以配合数据库的持久化一起使用。而且现在很多应用都是集群部署的，那么集群中多个实例上的多个DelayQueue如何配合是一个很大的问题。</p><p>所以，基于JDK的DelayQueue方案只适合在单机场景、并且数据量不大的场景中使用，如果涉及到分布式场景，那还是不建议使用。</p><h3 id="iv-netty的时间轮"><a class="markdownIt-Anchor" href="#iv-netty的时间轮"></a> IV、Netty的时间轮</h3><p>还有一种方式，和上面我们提到的JDK自带的DelayQueue类似的方式，那就是基于时间轮实现。</p><p>为什么要有时间轮呢？主要是因为DelayQueue插入和删除操作的平均时间复杂度——O(nlog(n))，虽然已经挺好的了，但是时间轮的方案可以将插入和删除操作的时间复杂度都降为O(1)。</p><blockquote><p><strong>时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。</strong></p></blockquote><p>基于Netty的HashedWheelTimer可以帮助我们快速的实现一个时间轮，这种方式和DelayQueue类似，缺点都是基于内存、集群扩展麻烦、内存有限制等等。</p><p>但是他相比DelayQueue的话，效率更高一些，任务触发的延迟更低。代码实现上面也更加精简。</p><p>所以，基于Netty的时间轮方案比基于JDK的DelayQueue效率更高，实现起来更简单，但是同样的，只适合在单机场景、并且数据量不大的场景中使用，如果涉及到分布式场景，那还是不建议使用。</p><h3 id="v-kafka的时间轮"><a class="markdownIt-Anchor" href="#v-kafka的时间轮"></a> V、Kafka的时间轮</h3><p>既然基于Netty的时间轮存在一些问题，那么有没有其他的时间轮的实现呢？</p><p>还真有的，那就是Kafka的时间轮，Kafka内部有很多延时性的操作，如延时生产，延时拉取，延时数据删除等，这些延时功能由内部的延时操作管理器来做专门的处理，其底层是采用时间轮实现的。</p><p>而且，为了解决有一些时间跨度大的延时任务，Kafka 还引入了层级时间轮，能更好控制时间粒度，可以应对更加复杂的定时任务处理场景；</p><p>Kafka 中的时间轮的实现是 TimingWheel 类，位于 kafka.utils.timer 包中。基于Kafka的时间轮同样可以得到O(1)时间复杂度，性能上还是不错的。</p><p>基于Kafka的时间轮的实现方式，在实现方式上有点复杂，需要依赖kafka，但是他的稳定性和性能都要更高一些，而且适合用在分布式场景中。</p><h3 id="vi-rocketmq延迟消息"><a class="markdownIt-Anchor" href="#vi-rocketmq延迟消息"></a> VI、RocketMQ延迟消息</h3><p>相比于Kafka来说，RocketMQ中有一个强大的功能，那就是支持延迟消息</p><blockquote><p>延迟消息，当消息写入Broker后，不会立刻被消费者消费，需要等待指定的时长后才可被消费处理的消息，称为延迟消息</p></blockquote><p>有了延迟消息，我们就可以在订单创建好之后，发送一个延迟消息，比如20分钟取消订单，那就发一个延迟20分钟的延迟消息，然后在20分钟之后，消息就会被消费者消费，消费者在接收到消息之后，去关单就行了。</p><p>但是，RocketMQ的延迟消息并不是支持任意时长的延迟的，它只支持：1s 5s 10s 30s 1m 2m 3m 4m 5m 6m 7m 8m 9m 10m 20m 30m 1h 2h这几个时长。（商业版支持任意时长）</p><p>可以看到，有了RocketMQ延迟消息之后，我们处理上就简单很多，只需要发消息，和接收消息就行了，系统之间完全解耦了。但是因为延迟消息的时长受到了限制，所以并不是很灵活。</p><p>如果我们的业务上，关单时长刚好和RocketMQ延迟消息支持的时长匹配的话，那么是可以基于RocketMQ延迟消息来实现的。否则，这种方式并不是最佳的。（但是在RocketMQ 5.0中新增了基于时间轮实现的定时消息，可以解决这个问题）</p><h3 id="vii-rabbitmq死信队列"><a class="markdownIt-Anchor" href="#vii-rabbitmq死信队列"></a> VII、RabbitMQ死信队列</h3><p>延迟消息不仅在RocketMQ中支持，其实在RabbitMQ中也是可以实现的，只不过其底层是基于死信队列实现的。</p><p>当RabbitMQ中的一条正常的消息，因为过了存活时间（TTL过期）、队列长度超限、被消费者拒绝等原因无法被消费时，就会变成Dead Message，即死信。</p><p>当一个消息变成死信之后，他就能被重新发送到死信队列中（其实是交换机-exchange）。<br />那么基于这样的机制，就可以实现延迟消息了。那就是我们给一个消息设定TTL，但是并不消费这个消息，等他过期，过期后就会进入到死信队列，然后我们再监听死信队列的消息消费就行了。<br />而且，RabbitMQ中的这个TTL是可以设置任意时长的，这就解决了RocketMQ的不灵活的问题。</p><p>但是，死信队列的实现方式存在一个问题，那就是可能造成队头阻塞，如果死信队列中的队头的消息一直无法消费成功，那么就会阻塞整个队列，这时候即使排在他后面的消息过期需要处理了，那么也会被一直阻塞。</p><p>基于RabbitMQ的死信队列，可以实现延迟消息，非常灵活的实现定时关单，并且借助RabbitMQ的集群扩展性，可以实现高可用，以及处理大并发量。他的缺点第一是可能存在消息阻塞的问题，还有就是方案比较复杂，不仅要依赖RabbitMQ，而且还需要声明很多队列(exchange)出来，增加系统的复杂度。</p><h3 id="viii-rabbitmq插件"><a class="markdownIt-Anchor" href="#viii-rabbitmq插件"></a> VIII、RabbitMQ插件</h3><p>其实，基于RabbitMQ的话，可以不用死信队列也能实现延迟消息，那就是基于rabbitmq_delayed_message_exchange插件，这种方案能够解决通过死信队列实现延迟消息出现的消息阻塞问题。但是该插件从RabbitMQ的3.6.12开始支持的，所以对版本有要求。</p><p>这个插件是官方出的，可以放心使用，安装并启用这个插件之后，就可以创建x-delayed-message类型的队列了。</p><p>前面我们提到的基于死信队列的方式，是消息先会投递到一个正常队列，在TTL过期后进入死信队列。但是基于插件的这种方式，消息并不会立即进入队列，而是先把他们保存在一个基于Erlang开发的Mnesia数据库中，然后通过一个定时器去查询需要被投递的消息，再把他们投递到x-delayed-message队列中。</p><p>基于RabbitMQ插件的方式可以实现延迟消息，并且不存在消息阻塞的问题，但是因为是基于插件的，而这个插件支持的最大延长时间是(2^32)-1 毫秒，大约49天，超过这个时间就会被立即消费。但是他基于RabbitMQ实现，所以在可用性、性能方便都很不错</p><h3 id="ix-redis过期监听"><a class="markdownIt-Anchor" href="#ix-redis过期监听"></a> IX、Redis过期监听</h3><p>在 redis.conf 中，加入一条配置notify-keyspace-events Ex开启过期监听，然后再代码中实现一个KeyExpirationEventMessageListener，就可以监听key的过期消息了。</p><p>这样就可以在接收到过期消息的时候，进行订单的关单操作。</p><p>这个方案不建议大家使用，是因为Redis官网上明确的说过，Redis并不保证Key在过期的时候就能被立即删除，更不保证这个消息能被立即发出。所以，消息延迟是必然存在的，随着数据量越大延迟越长，延迟个几分钟都是常事儿。</p><p>而且，在Redis 5.0之前，这个消息是通过PUB/SUB模式发出的，他不会做持久化，至于你有没有接到，有没有消费成功，他不管。也就是说，如果发消息的时候，你的客户端挂了，之后再恢复的话，这个消息你就彻底丢失了。（在Redis 5.0之后，因为引入了Stream，是可以用来做延迟消息队列的。）</p><h3 id="x-redis的zset"><a class="markdownIt-Anchor" href="#x-redis的zset"></a> X、Redis的zset</h3><p>我们可以借助Redis中的有序集合——zset来实现这个功能。</p><p>zset是一个有序集合，每一个元素(member)都关联了一个 score，可以通过 score 排序来取集合中的值。</p><p>我们将订单超时时间的时间戳（下单时间+超时时长）与订单号分别设置为 score 和 member。这样redis会对zset按照score延时时间进行排序。然后我们再开启redis扫描任务，获取&quot;当前时间 &gt; score&quot;的延时任务，扫描到之后取出订单号，然后查询到订单进行关单操作即可。</p><p>使用redis zset来实现订单关闭的功能的优点是可以借助redis的持久化、高可用机制。避免数据丢失。但是这个方案也有缺点，那就是在高并发场景中，有可能有多个消费者同时获取到同一个订单号，一般采用加分布式锁解决，但是这样做也会降低吞吐型。</p><p>但是，在大多数业务场景下，如果幂等性做得好的，多个消费者取到同一个订单号也无妨。</p><h3 id="xi-redisson-redis"><a class="markdownIt-Anchor" href="#xi-redisson-redis"></a> XI、Redisson + Redis</h3><blockquote><p>Redisson时一个在Redis的基础上实现的框架，它不仅提供了一系列的分布式的Java常用对象，还提供了许多分布式服务。</p></blockquote><p>Redisson中定义了分布式延迟队列RDelayedQueue，这是一种基于我们前面介绍过的zset结构实现的延时队列，它允许以指定的延迟时长将元素放到目标队列中。</p><p>其实就是在zset的基础上增加了一个基于内存的延迟队列。当我们要添加一个数据到延迟队列的时候，redisson会把数据+超时时间放到zset中，并且起一个延时任务，当任务到期的时候，再去zset中把数据取出来，返回给客户端使用。</p><p><a href="#%E5%A6%82%E4%BD%95%E5%9F%BA%E4%BA%8ERedisson%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E5%BB%B6%E8%BF%9F%E9%98%9F%E5%88%97">如何基于Redisson实现一个延迟队列</a></p><p>基于Redisson的实现方式，是可以解决基于zset方案中的并发重复问题的，而且还能实现方式也比较简单，稳定性、性能都比较高。</p><hr /><h2 id="为什么不建议使用mq实现订单到期关闭"><a class="markdownIt-Anchor" href="#为什么不建议使用mq实现订单到期关闭"></a> 为什么不建议使用MQ实现订单到期关闭？</h2><ol><li>**资源占用与成本：**如果系统中存在大量订单，为每个订单都创建一个延迟消息可能会导致消息队列中积压大量的消息，这不仅增加了消息队列的资源消耗，也可能导致增加成本，尤其是在使用云服务提供商的消息队列服务时。</li><li>**延迟消息的限制：**首先并不是所有的消息队列服务都支持延迟消息，及时有一些支持，也可能对消息的延迟时间有限制。例如，某些服务可能限制延迟时间的最大值，这可能无法满足所有订单的到期关闭需求。</li><li>**可靠性问题：**虽然消息队列一般来说可靠性较高，但是也没办法做到100%不丢消息，所以在极端情况下，会有丢消息的风险。</li><li>**精确性问题：**消息的投递延迟是比较常见的一种情况，这可能会导致订单关闭操作不够精确。</li><li>**大量无效消息：**使用MQ实现订单到期关闭就要把订单放到MQ中，但是大部分订单会提前取消或者完成支付，这就会导致很多无效的消息。</li><li>**扩展性问题：**随着系统规模的扩大，依赖于消息队列的延迟消息来处理订单到期可能遇到扩展性问题。系统可能需要更复杂的消息队列管理策略和更高效的资源利用策略来应对不断增长的订单量。</li></ol><h2 id="定时任务扫表的问题解决方案"><a class="markdownIt-Anchor" href="#定时任务扫表的问题解决方案"></a> 定时任务扫表的问题解决方案</h2><h3 id="数据量多扫表慢"><a class="markdownIt-Anchor" href="#数据量多扫表慢"></a> 数据量多，扫表慢</h3><p>随着需要扫描的表中的数据量越来越大，通过定时任务扫表的方式会越来越慢，那么想要解决这个问题，首先可以考虑加索引。</p><p>我们可以在state字段上增加一个索引，虽然这个字段的区分度不高，但是一般来说，这张表中，SUCCESS的数据量占90%，而INIT的数据量只占10%，而我们扫表的时候只关心INIT即可，所以增加索引后，扫表的效率是可以大大提升的。</p><p>其次，可以考虑多线程并发扫表，这里可以考虑采用线程池，在任务中开多个线程并发的从数据库中扫描数据进行处理。</p><p>但是这样做，会带来一个问题，那就是多个线程之间如何做好隔离，如何确保不会出现并发导致同一条记录被多个线程执行多次呢？</p><p>首先最基本的保障，扫表之后的处理逻辑要做好幂等控制，一旦出现了重复的情况，下游也能因为做了幂等而不会重复处理。</p><p>除此以外，在扫表的时候，可以通过分段的思想进行数据隔离。举个例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-type">Long</span> <span class="hljs-variable">minId</span> <span class="hljs-operator">=</span> messageService.getMinInitId();<br><br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= threadPool.size(); i++) &#123;<br>  <span class="hljs-type">Long</span> <span class="hljs-variable">maxId</span> <span class="hljs-operator">=</span> minId + segmentSize()*i;<br>  <br>  List&lt;Message&gt; messages = messageService.scanInitMessages(minId,maxId);<br>  <br>  procss(messages);<br>  minId = maxId + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>像上面的例子中，假设有10个线程，那么第一个线程就扫描Id处于0-1000的数据，第二个线程扫描1001-2000的数据，第三个线程扫描2001-3000的数据。这样以此类推，线程之间通过分段的方式就做好了隔离，可以避免同一个数据被多个线程扫描到。</p><p>这个做法，有个小问题，那就是INIT的数据的ID可能不是连续的，那么就需要考虑其他的分段方式，比如在事件表中增加一个业务ID，然后根据这个biz_id做分片也可以。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= threadPool.size(); i++) &#123;<br>List&lt;Message&gt; messages = messageService.scanInitMessages(i);<br>process(messages);<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在SQL中：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> RETRY_MESSAGE <span class="hljs-keyword">WHERE</span><br>STATE <span class="hljs-operator">=</span> &quot;INIT&quot;<br><span class="hljs-keyword">AND</span> BIZ_ID <span class="hljs-keyword">LIKE</span> &quot;$&#123;frontNumber&#125;$&quot;;<br></code></pre></td></tr></table></figure><p>那么，不同线程执行的SQL就不一样了，分别是：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> RETRY_MESSAGE <span class="hljs-keyword">WHERE</span><br>STATE <span class="hljs-operator">=</span> &quot;INIT&quot;<br><span class="hljs-keyword">AND</span> BIZ_D <span class="hljs-keyword">LIKE</span> &quot;1%&quot;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> RETRY_MESSAGE <span class="hljs-keyword">WHERE</span><br>STATE <span class="hljs-operator">=</span> &quot;INIT&quot;<br><span class="hljs-keyword">AND</span> BIZ_D <span class="hljs-keyword">LIKE</span> &quot;2%&quot;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> RETRY_MESSAGE <span class="hljs-keyword">WHERE</span><br>STATE <span class="hljs-operator">=</span> &quot;INIT&quot;<br><span class="hljs-keyword">AND</span> BIZ_D <span class="hljs-keyword">LIKE</span> &quot;3%&quot;<br><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> RETRY_MESSAGE <span class="hljs-keyword">WHERE</span><br>STATE <span class="hljs-operator">=</span> &quot;INIT&quot;<br><span class="hljs-keyword">AND</span> BIZ_D <span class="hljs-keyword">LIKE</span> &quot;4%&quot;<br></code></pre></td></tr></table></figure><h3 id="集中式扫表会影响正常业务"><a class="markdownIt-Anchor" href="#集中式扫表会影响正常业务"></a> 集中式扫表会影响正常业务</h3><p>如果业务量比较大的话，集中式的扫描数据库势必给数据库带来一定的压力，那么就会影响到正常的业务。</p><p>那么想要解决这个问题，首先可以考虑，不扫主库，而是扫描备库。之所以能这么做，是因为这个业务场景一般都是可以接受一定的数据延迟的，那么备库带来延迟就可以忽略，但是备库是没有业务操作的，所以对备库的扫描是不会对业务造成影响的。</p><p>当然，这里还要考虑一个问题，那就是备库扫描数据之后的执行，执行完该如何同步到主库，这里可以直接修改主库，主备库数据ID一致的，直接去修改主库的就行了。不建议直接在备库上修改。</p><p>但是不管怎么样，备库还是可以分担扫表的这个大量高峰请求的。</p><p>除了扫备库，还有一个方案，那就是做分库。把原来集中在同一个数据库的数据分散到不同的数据库中，这样用集群代替单库来整体对外提供服务，可以大大的提升吞吐量。</p><p>因为多个数据库的话，每个库提供的连接数就会多，并且多个实例的话，CPU、IO、LOAD这些指标也可以互相分担。</p><h3 id="定时扫表存在延迟问题"><a class="markdownIt-Anchor" href="#定时扫表存在延迟问题"></a> 定时扫表存在延迟问题</h3><p>定时任务都是集中式的定时执行的，那么就会存在延迟的问题。随着数据库越来越大，延迟会越来越长。</p><p>想要降低延迟，那就要抛弃定时任务的方案，可以考虑延迟消息，基于延迟消息来做定时执行。</p><p>用了延迟消息之后，还可以缓解数据库的压力。也能比定时扫表的性能要好，实时性也更高。</p><p>当然，引入另外一个中间件也需要考虑成本的。</p><h3 id="同步转异步"><a class="markdownIt-Anchor" href="#同步转异步"></a> 同步转异步</h3><p>就是同步先执行，失败了的话，再异步执行。如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">namedThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>()<br>    .setNameFormat(<span class="hljs-string">&quot;hollis-pool-%d&quot;</span>).build();<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">pool</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<span class="hljs-number">5</span>, <span class="hljs-number">200</span>,<br>    <span class="hljs-number">0L</span>, TimeUnit.MILLISECONDS,<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;Runnable&gt;(<span class="hljs-number">1024</span>), namedThreadFactory, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>.AbortPolicy());<br><span class="hljs-meta">@Transactional(rollbackFor = Exception.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pay</span><span class="hljs-params">(PayRequest payRequest)</span>&#123;<br><span class="hljs-comment">//在同一个事务中做本地业务操作和记录消息</span><br>payService.doPay(payRequest);<br>    retryMessageService.init(payRequest);<br><span class="hljs-comment">//同步执行一次外部调用</span><br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-type">Result</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> outerService.doSth(payRequest);<br>        <span class="hljs-keyword">if</span>(result.isSuccess())&#123;<br>            retryMessageService.success(payRequest);<br>        &#125;<br>    &#125;<span class="hljs-keyword">catch</span>(Exception e)&#123;<br>        <span class="hljs-comment">// 捕获异常，失败依赖异步重试</span><br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>如上，在同步接口中，先尝试执行一次要可能会失败的任务，如果成功了，那就把事件推进到成功。如果失败了也无所谓，因为会有异步定时任务捞起来重试。</p><h2 id="如何基于redisson实现一个延迟队列"><a class="markdownIt-Anchor" href="#如何基于redisson实现一个延迟队列"></a> 如何基于Redisson实现一个延迟队列</h2><p>Redisson中定义了分布式延迟队列RDelayedQueue，这是一种基于我们前面介绍过的zset结构实现的延时队列，它允许以指定的延迟时长将元素放到目标队列中。</p><p>其实就是在zset的基础上增加了一个基于内存的延迟队列。当我们要添加一个数据到延迟队列的时候，redisson会把数据+超时时间放到zset中，并且起一个延时任务，当任务到期的时候，再去zset中把数据取出来，返回给客户端使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;dependency&gt;<br>    &lt;groupId&gt;org.redisson&lt;/groupId&gt;<br>    &lt;artifactId&gt;redisson&lt;/artifactId&gt;<br>    &lt;version&gt;最新版&lt;/version&gt; <br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>定义一个Redisson客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonConfig</span> &#123;<br>    <br>    <span class="hljs-meta">@Bean(destroyMethod=&quot;shutdown&quot;)</span><br>    <span class="hljs-keyword">public</span> RedissonClient <span class="hljs-title function_">redisson</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-type">Config</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Config</span>();<br>config.useSingleServer().setAddress(<span class="hljs-string">&quot;redis://127.0.0.1:6379&quot;</span>);<br><span class="hljs-type">RedissonClient</span> <span class="hljs-variable">redisson</span> <span class="hljs-operator">=</span> Redisson.create(config);<br>        <span class="hljs-keyword">return</span> redisson;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>接下来，在想要使用延迟队列的地方做如下方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs Java"><span class="hljs-keyword">import</span> org.redisson.api.RBlockingDeque;<br><span class="hljs-keyword">import</span> org.redisson.api.RDelayedQueue;<br><span class="hljs-keyword">import</span> org.redisson.api.RedissonClient;<br><span class="hljs-keyword">import</span> org.springframework.beans.factory.annotation.Autowired;<br><span class="hljs-keyword">import</span> org.springframework.stereotype.Component;<br><span class="hljs-keyword">import</span> java.time.LocalDateTime;<br><span class="hljs-keyword">import</span> java.time.format.DateTimeFormatter;<br><span class="hljs-keyword">import</span> java.util.concurrent.TimeUnit;<br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">RedissonOrderDelayQueue</span> &#123;<br>    <span class="hljs-meta">@Autowired</span><br>    RedissonClient redisson;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">addTaskToDelayQueue</span><span class="hljs-params">(String orderId)</span> &#123;<br>      <br>        RBlockingDeque&lt;String&gt; blockingDeque = redisson.getBlockingDeque(<span class="hljs-string">&quot;orderQueue&quot;</span>);<br>        RDelayedQueue&lt;String&gt; delayedQueue = redisson.getDelayedQueue(blockingDeque);<br>        System.out.println(LocalDateTime.now().format(DateTimeFormatter.ofPattern(<span class="hljs-string">&quot;yyyy-MM-dd HH:mm:ss&quot;</span>)) + <span class="hljs-string">&quot;添加任务到延时队列里面&quot;</span>);<br>        delayedQueue.offer(orderId, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>        delayedQueue.offer(orderId, <span class="hljs-number">6</span>, TimeUnit.SECONDS);<br>        delayedQueue.offer(orderId, <span class="hljs-number">9</span>, TimeUnit.SECONDS);<br>    &#125;<br>   <span class="hljs-keyword">public</span> String <span class="hljs-title function_">getOrderFromDelayQueue</span><span class="hljs-params">()</span> &#123;<br>        RBlockingDeque&lt;String&gt; blockingDeque = redisson.getBlockingDeque(<span class="hljs-string">&quot;orderQueue&quot;</span>);<br>        RDelayedQueue&lt;String&gt; delayedQueue = redisson.getDelayedQueue(blockingDeque);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">orderId</span> <span class="hljs-operator">=</span> blockingDeque.take();<br>        <span class="hljs-keyword">return</span> orderId;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用offer方法将两条延迟消息添加到RDelayedQueue中，使用take方法从RQueue中获取消息，如果没有消息可用，该方法会阻塞等待，直到消息到达。</p><p>我们使用 RDelayedQueue 的 offer 方法将元素添加到延迟队列，并指定延迟的时间。当元素的延迟时间到达时，Redisson 会将元素从 RDelayedQueue 转移到关联的 RBlockingDeque 中。</p><p>使用 RBlockingDeque 的 take 方法从关联的 RBlockingDeque 中获取元素。这是一个阻塞操作，如果没有元素可用，它会等待直到有元素可用。</p><p>所以，为了从延迟队列中取出元素，使用 RBlockingDeque 的 take 方法，因为 Redisson 的 RDelayedQueue 实际上是通过转移元素到关联的 RBlockingDeque 来实现延迟队列的。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>scene</tag>
      
      <tag>mq</tag>
      
      <tag>redis+redisson</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tea5.20-5.24</title>
    <link href="/2024/05/24/tea5-20-5-24/"/>
    <url>/2024/05/24/tea5-20-5-24/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶520-524"><a class="markdownIt-Anchor" href="#茶520-524"></a> 茶5.20-5.24</h1><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/problemset/problem/1354/B">Ternary String 1354B</a></p><p><strong>题目翻译：</strong></p><p>输入T（T&lt;=2<sup>4</sup>)，表示T组数据。所有数据的字符串长度之和&lt;=2<sup>5</sup>。</p><p>每组数据输入一个长度&lt;=2<sup>5</sup>的字符串，只包含数字’1’,‘2’,‘3’。</p><p>输出s中的最短子串的长度，该子串必须包含所有’1’‘2’'3’三种字符。</p><p>如果没有这样的子串，输出0。</p><p><strong>Sol：</strong></p><p>用一个长为3的cnt数组维护子串内的1 2 3的个数。如果三个数的cnt都大于0，就更新答案的最小值，移动左端点。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    string s;<br>    cin&gt;&gt;s;<br>    <span class="hljs-type">int</span> length = s.<span class="hljs-built_in">size</span>();<br>    <span class="hljs-function">vi <span class="hljs-title">cnt</span><span class="hljs-params">(<span class="hljs-number">3</span>,<span class="hljs-number">0</span>)</span></span>;<br>    <span class="hljs-type">int</span> ans = INT_MAX;<br>    <span class="hljs-type">int</span> left = <span class="hljs-number">0</span>,right = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span>(right = <span class="hljs-number">0</span>; right &lt; length; right++) &#123;<br>        cnt[s[right]-<span class="hljs-string">&#x27;1&#x27;</span>]++;<br>        <span class="hljs-keyword">while</span>(cnt[<span class="hljs-number">0</span>]&gt;<span class="hljs-number">0</span>&amp;&amp;cnt[<span class="hljs-number">1</span>]&gt;<span class="hljs-number">0</span>&amp;&amp;cnt[<span class="hljs-number">2</span>]&gt;<span class="hljs-number">0</span>) &#123;<br>            ans = <span class="hljs-built_in">min</span>(ans,right-left+<span class="hljs-number">1</span>);<br>            cnt[s[left]-<span class="hljs-string">&#x27;1&#x27;</span>]--;<br>            left++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(ans==INT_MAX) &#123;<br>        ans=<span class="hljs-number">0</span>;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="feb"><a class="markdownIt-Anchor" href="#feb"></a> Feb</h2><p><a href="https://codeforces.com/problemset/problem/760/B">Frodo and pillows 760B</a></p><p><strong>题目翻译：</strong></p><p>输入n m k(1&lt;=n&lt;=m&lt;=10<sup>9</sup>,1&lt;=k&lt;=n).</p><p>有一个长为n的数组a，已知其所有元素均为正整数，元素和等于m且|a[i]-a[i+1]|&lt;=1.</p><p>问：a[k]最大能是多少？</p><p><strong>Sol：</strong></p><p>二分。设a[k]=mx,那么数组元素最佳是按照</p><p>… a[k-2] = mx-2,a[k-1] = mx - 1,a[k] = mx,a[k+1] = mx - 1,a[k+2] = mx - 2,…</p><p>这样元素和尽量小。按照上述规则，计算等差数列和cnt，通过比较cnt与m的大小来调整二分边界。</p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    ll n,m,k;<br>    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;<br>    m -= n;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> lo = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> hi = m;<br>    <br>    <span class="hljs-keyword">while</span> (lo &lt; hi) &#123;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> mid = (lo + hi + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        <span class="hljs-type">long</span> <span class="hljs-type">long</span> need = -mid;<br>        <span class="hljs-keyword">if</span> (mid &lt;= k) &#123;<br>        need += mid * (mid + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        need += (mid + mid - k + <span class="hljs-number">1</span>) * k / <span class="hljs-number">2</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (mid &lt;= n - k + <span class="hljs-number">1</span>) &#123;<br>        need += mid * (mid + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        need += (mid + mid - n + k) * (n - k + <span class="hljs-number">1</span>) / <span class="hljs-number">2</span>;<br>        &#125;<br>    <br>        <span class="hljs-keyword">if</span> (need &lt;= m) &#123;<br>        lo = mid;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>        hi = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <br>    cout &lt;&lt; lo + <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/problemset/problem/1689/C">Infected Tree 1689C</a></p><p><strong>题目描述：</strong></p><p>输入 T(≤5000) 表示 T 组数据。所有数据的 n 之和 ≤3e5。 每组数据输入 n(2≤n≤3e5) 和一棵 n 个节点的二叉树的 n-1 条双向边。节点编号从 1 开始。  二叉树的根节点是 1。 一开始，根节点被感染。 然后执行如下过程 n 次：</p><p>首先，选择一个未被感染也未被删除的点，将其删除（相连的边也删除）；或者什么也不做。</p><p>然后，任何与被感染节点相邻的节点，都被感染。</p><p>输出最多可以让多少个点不被感染也不被删除。</p><p><strong>拓展：</strong></p><p>改成多叉树：<a href="https://www.luogu.com.cn/problem/P1041">传染病控制</a></p><p><strong>Sol：</strong></p><p>贪心 + 树形dp</p><p>当某颗子树的根节点被感染时，删除左儿子或右儿子，可以尽最大可能地减少感染。</p><p>那么应该删除左儿子还是右儿子，用dp判断最优解。</p><p>可以考虑感染和删除最少多少个点。</p><p>对于以v为根点子树而言，在v被感染的情况下：</p><p>1.如果v是叶子，返回1，表示v被感染。</p><p>2.如果v只有一个儿子，删除儿子，返回2，表示v被感染，v的儿子被删除。</p><p>3.如果v有两个儿子，枚举删除哪个儿子，递归另一颗子树w，返回dfs（w，v） + 2 的最小值，第二个参数是父节点。</p><p>答案为 n - dfs（1，0）。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt;&amp; g, <span class="hljs-type">int</span> v, <span class="hljs-type">int</span> fa)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (g[v].<span class="hljs-built_in">size</span>() &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> g[v].<span class="hljs-built_in">size</span>();<br>    &#125;<br>    <span class="hljs-type">int</span> mx = <span class="hljs-number">1e9</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> w : g[v]) &#123;<br>        <span class="hljs-keyword">if</span> (w != fa) &#123;<br>            mx = <span class="hljs-built_in">min</span>(mx, <span class="hljs-built_in">dfs</span>(g, w, v) + <span class="hljs-number">2</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mx;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">g</span>(n + <span class="hljs-number">1</span>);<br>    g[<span class="hljs-number">1</span>] = &#123;<span class="hljs-number">0</span>&#125;;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> v, w;<br>        cin&gt;&gt;v&gt;&gt;w;<br>        g[v].<span class="hljs-built_in">push_back</span>(w);<br>        g[w].<span class="hljs-built_in">push_back</span>(v);<br>    &#125;<br>    cout &lt;&lt; n - <span class="hljs-built_in">dfs</span>(g, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>) &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/problemset/problem/451/E">Devu and Flowers 451E</a></p><p>输入 n(1≤n≤20) s(0≤s≤1e14) 和长为 n 的数组 a(0≤a[i]≤1e12)。</p><p>你有 n 个盒子，第 i 个盒子装有 a[i] 朵颜色一样的花（无法区分）。<br />此外，没有两个盒子中的花朵颜色相同。<br />从这些盒子中恰好选出 s 朵花的方案数是多少？</p><p>输入<br />2 3<br />1 3<br />输出 2</p><p>输入<br />2 4<br />2 2<br />输出 1</p><p>输入<br />3 5<br />1 3 2<br />输出 3</p><p><strong>Sol：</strong></p><p>容斥原理+组合数。</p><p>请先阅读 <a href="https://leetcode.cn/problems/distribute-candies-among-children-ii/solution/o1-rong-chi-yuan-li-pythonjavacgo-by-end-2woj/">n=3 时的题解</a>  看成是把 s 个无区别的小球，分给 n 个有区别的盒子，第 i 个盒子至多容纳 a[i] 个小球。</p><p>计算方法同上面的力扣题（n=3 的情况）。</p><p>枚举 a 的所有子集，子集中的盒子预先分配 a[i]+1 个小球。 剩余的小球 s2 按照 C(s2+n-1,n-1) 计算方案数。  组合数 C(n,k) 的计算可以分别计算分子和分母，最后用模运算除法解决。 关于模运算除法请看 <a href="https://leetcode.cn/circle/discuss/mDfnkW/">模运算的世界：当加减乘除遇上取模</a>  注意 n 很大，要先把 n 取模。 注意使用 64 位整数。  <a href="https://codeforces.com/problemset/submission/451/261442815">代码</a>  <a href="https://codeforces.com/problemset/submission/451/261443307">优化：预处理 n-1 以内的阶乘的逆元</a></p><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstdio&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N = <span class="hljs-number">20</span>;<br><br><span class="hljs-type">int</span> n;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> f[N];<br><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> MOD = <span class="hljs-number">1000000007</span>;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">inv</span><span class="hljs-params">(<span class="hljs-type">int</span> a)</span> </span>&#123;<br><span class="hljs-keyword">return</span> a == <span class="hljs-number">1</span> ? <span class="hljs-number">1</span> : (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(MOD - MOD / a) * <span class="hljs-built_in">inv</span>(MOD % a) % MOD;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">choose</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> s, <span class="hljs-type">long</span> <span class="hljs-type">long</span> n)</span> </span>&#123;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> ret = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>ret = (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)ret * ((s - i) % MOD) % MOD * <span class="hljs-built_in">inv</span>(i + <span class="hljs-number">1</span>) % MOD;<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-title">go</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">long</span> <span class="hljs-type">long</span> s)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (s &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (i == n) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">choose</span>(s + n - <span class="hljs-number">1</span>, n - <span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-built_in">go</span>(i + <span class="hljs-number">1</span>, s) - <span class="hljs-built_in">go</span>(i + <span class="hljs-number">1</span>, s - f[i])) % MOD;<br>&#125;<br><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> s;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>cin &gt;&gt; n &gt;&gt; s;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>cin &gt;&gt; f[i];<br>++f[i];<br>&#125;<br>cout &lt;&lt; (<span class="hljs-built_in">go</span>(<span class="hljs-number">0</span>, s) + MOD) % MOD &lt;&lt; endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="fri"><a class="markdownIt-Anchor" href="#fri"></a> Fri</h2><p>状压 DP！</p><p><a href="https://leetcode.cn/problems/beautiful-arrangement/">优美的排列</a></p><p>如果一个 1-n 的排列 p，对于每个 i=1,2,3,…n，都满足 i 和 p[i] 其中一个能整除另一个，则称 p 是好的。<br />输入 n(1≤n≤15)，输出有多少个 1-n 的排列是好的。</p><p>输入 2<br />输出 2<br />解释 [1,2] 和 [2,1]</p><p>输入 1<br />输出 1</p><p>额外加练：</p><p><a href="https://codeforces.com/problemset/problem/1771/F">Hossam and Range Minimum Query</a></p><p>题解(仙佬的）:<a href="https://www.cnblogs.com/Athanasy/p/18012165">https://www.cnblogs.com/Athanasy/p/18012165</a></p><p><strong>Sol：（摘自灵神）</strong></p><p>1.寻找子问题</p><p>将1-n的排列简记为p</p><p>假设n=5，先不考虑整除：</p><ul><li>枚举p<sub>1</sub>选哪个，它可以是1，2，3，4，5，假设p<sub>1</sub>=2.</li><li>枚举p<sub>2</sub>选哪个，它可以是1，3，4，5，假设p<sub>2</sub>=4.</li><li>枚举p<sub>3</sub>选哪个，它可以是1，3，5，假设p<sub>3</sub>=5.</li><li>枚举p<sub>4</sub>选哪个，它可以是1，3，假设p<sub>4</sub>=3.</li><li>枚举p<sub>5</sub>选哪个，它只可以是1，所以p<sub>5</sub>=1.</li></ul><p>在这个过程中，我们需要知道：哪些数不能选。可以用一个集合S存储选过的数。枚举p<sub>i</sub>的值，然后加入集合S。注意剩下能选的数变少了，要解决的问题规模也小了。</p><p>所以我们可以考虑递归解决。但是注意上述过程中，会产生重复子问题,例如</p><ul><li>目前生成的排列 p = [2,4,1,<em>,</em>], 现在递归到倒数第二个位置，那么 S = {1,2,4}.</li><li>目前生成的排列 p = [4,2,1,<em>,</em>], 现在递归到倒数第二个位置，那么 S = {1,2,4}.</li></ul><p>前面的排列具体如何，我们并不关心，我们记录的是无序的集合，不是有序的列表。</p><p>2.状态定义和状态转移方程</p><p>按照上面的讨论，定义dfs(S)表示在之前选过的数的集合为S的情况下，剩余数字可以构造的优美排列的数量。</p><p>考虑p<sub>i</sub>选什么：</p><ul><li>枚举 j = 1,2,…,n,且j <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo mathvariant="normal">∉</mo></mrow><annotation encoding="application/x-tex">\notin</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mrel"><span class="mord"><span class="mrel">∈</span></span><span class="mord vbox"><span class="thinbox"><span class="llap"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="inner"><span class="mord"><span class="mord">/</span><span class="mspace" style="margin-right:0.05555555555555555em;"></span></span></span><span class="fix"></span></span></span></span></span></span></span></span> S 且 i 和 j 一个可以整除另一个</li><li>要解决的问题变成：在之前选过的数的集合为 S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋃</mo></mrow><annotation encoding="application/x-tex">\bigcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span></span></span></span> {j} 的情况下，剩余数字可以构造的优美排列的数量，即dfs(S <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo>⋃</mo></mrow><annotation encoding="application/x-tex">\bigcup</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.00001em;vertical-align:-0.25001em;"></span><span class="mop op-symbol small-op" style="position:relative;top:-0.0000050000000000050004em;">⋃</span></span></span></span> {j}).</li></ul><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy="false">(</mo><mi>S</mi><mo stretchy="false">)</mo><mo>=</mo><munder><mo>∑</mo><mi>j</mi></munder><mi>d</mi><mi>f</mi><mi>s</mi><mo stretchy="false">(</mo><mi>S</mi><mo>⋃</mo><mi>j</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">dfs(S) = \sum_jdfs(S \bigcup {j})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.463782em;vertical-align:-1.413777em;"></span><span class="mop op-limits"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.050005em;"><span style="top:-1.8723309999999997em;margin-left:0em;"><span class="pstrut" style="height:3.05em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span><span style="top:-3.0500049999999996em;"><span class="pstrut" style="height:3.05em;"></span><span><span class="mop op-symbol large-op">∑</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:1.413777em;"><span></span></span></span></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord mathnormal">d</span><span class="mord mathnormal" style="margin-right:0.10764em;">f</span><span class="mord mathnormal">s</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.05764em;">S</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mop op-symbol large-op" style="position:relative;top:-0.000004999999999977245em;">⋃</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.05724em;">j</span></span><span class="mclose">)</span></span></span></span></span></p><p>递归边界: dfs(U) = 1,其中全集 U = {1,2,…n}.如果能递归到S = U的状态，表示所有数都选完了，我们找到了一个合法排列。</p><p>递归入口:dfs(<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span>),也就是答案。其中<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="normal">∅</mi></mrow><annotation encoding="application/x-tex">\emptyset</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.80556em;vertical-align:-0.05556em;"></span><span class="mord">∅</span></span></span></span>表示空集，因为一开始什么也没选。</p><p>3.递归搜索+保存递归返回值=记忆化搜索</p><p>考虑到整个递归过程中有大量重复递归调用（递归入参相同）。由于递归函数没有副作用，同样的入参无论计算多少次，算出来的结果都是一样的，因此可以用记忆话搜索来优化：</p><ul><li>如果一个状态（递归入参）是第一次遇到，那么可以在返回前，把状态及其结果记到一个memo数组中。</li><li>如果一个状态不是第一次遇到（memo中保存的结果不等于memo的初始值），那么可以返回memo中保存的结果。</li></ul><p><strong>Code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">countArrangement</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">memo</span><span class="hljs-params">(<span class="hljs-number">1</span> &lt;&lt; n, <span class="hljs-number">-1</span>)</span></span>;<br>        function&lt;<span class="hljs-type">int</span>(<span class="hljs-type">int</span>)&gt; dfs = [&amp;](<span class="hljs-type">int</span> s) -&gt; <span class="hljs-type">int</span> &#123;<br>            <span class="hljs-keyword">if</span> (s == (<span class="hljs-number">1</span> &lt;&lt; n) - <span class="hljs-number">1</span>) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-type">int</span> &amp;res = memo[s];<br>            <span class="hljs-keyword">if</span> (res != <span class="hljs-number">-1</span>) &#123;<br>                <span class="hljs-keyword">return</span> res;<br>            &#125;<br>            res = <span class="hljs-number">0</span>;<br>            <span class="hljs-type">int</span> i = __builtin_popcount(s) + <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>; j &lt;= n; j++) &#123;<br>                <span class="hljs-keyword">if</span> ((s &gt;&gt; (j - <span class="hljs-number">1</span>) &amp; <span class="hljs-number">1</span>) == <span class="hljs-number">0</span> &amp;&amp; (i % j == <span class="hljs-number">0</span> || j % i == <span class="hljs-number">0</span>)) &#123;<br>                    res += <span class="hljs-built_in">dfs</span>(s | (<span class="hljs-number">1</span> &lt;&lt; (j - <span class="hljs-number">1</span>)));<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> res;<br>        &#125;;<br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">dfs</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>algorithm</tag>
      
      <tag>tea</tag>
      
      <tag>dfs</tag>
      
      <tag>dp</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>tea5.13-5.17</title>
    <link href="/2024/05/17/tea5-13-5-17/"/>
    <url>/2024/05/17/tea5-13-5-17/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="茶513-517"><a class="markdownIt-Anchor" href="#茶513-517"></a> 茶5.13-5.17</h1><p>只能做出来周一-周三，周四看题解勉强会，周五不想看了</p><h2 id="mon"><a class="markdownIt-Anchor" href="#mon"></a> Mon</h2><p><a href="https://codeforces.com/contest/251/problem/A">Points on Line</a></p><p><strong>题目翻译：</strong></p><p>小Petya非常喜欢积分。最近，他妈妈给了他 OX 线上的 n 个点。现在 Petya 想知道有多少种方法可以选择三个不同的点，使得其中最远的两个点之间的距离不超过 d。</p><p>请注意，三个所选点组内点的顺序并不重要</p><p><strong>输入：</strong></p><p>第一行 n和d (1&lt;=n&lt;=10<sup>5</sup>;1&lt;=d&lt;=10<sup>9</sup>).接下来一行包括n个整数，绝对值不超过10<sup>9</sup>，代表Petya 得到的点的 x 坐标。</p><p><strong>输出：</strong></p><p>打印一个整数 — 三点组的数量，其中两个最远点之间的距离不超过 d。</p><p><strong>Sol:</strong></p><p>让我们选择三元组的最右边点。为此，我们可以按 X 坐标的升序遍历所有点。同时，我们将保持一个指向最左边点的指针，该指针位于与当前最右边点的距离不超过 d 的距离上。我们可以很容易地找出两个指针之间的线段中的点数，不包括最右边的点。我们称这个数字为 k。然后正好存在 k * （k - 1） / 2 个具有固定最右边点的三元组点。剩下的唯一事情就是将这些值相加以获得所有最右边的点。</p><p><strong>Code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n,d;<br>    cin&gt;&gt;n&gt;&gt;d;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        cin&gt;&gt;a[i];<br>    &#125;<br>    <span class="hljs-type">int</span> j = <span class="hljs-number">0</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-type">long</span> ans = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>;i&lt;n;i++) &#123;<br>        <span class="hljs-keyword">while</span> (a[i]-a[j] &gt; d) j++;<br>        ans += (<span class="hljs-type">long</span> <span class="hljs-type">long</span>)(i-j)*(i-j<span class="hljs-number">-1</span>)/<span class="hljs-number">2</span>;<br>    &#125;<br>    cout&lt;&lt;ans&lt;&lt;endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="tue"><a class="markdownIt-Anchor" href="#tue"></a> Tue</h2><p><a href="https://codeforces.com/contest/576/problem/A">Vasya and Petya’s Game</a></p><p><strong>题目翻译：</strong></p><p>Vasya 和 Petya 正在玩一个简单的游戏。Vasya 想到了 1 和 n 之间的数字 x，Petya 试图猜测这个数字。</p><p>Petya 可以问这样的问题：“未知数可以被数 y 整除吗？</p><p>游戏按照以下规则进行：首先Petya问所有他感兴趣的问题（而且，他可以不问任何问题），然后Vasya用“是”或“否”回答每个问题。在收到所有答案后，佩蒂亚应该确定瓦夏想到的数字。</p><p>不幸的是，佩蒂亚并不熟悉数论。帮助他找到他应该问的最少问题数量，以保证猜测 Vasya 的数字，以及他应该问的问题。</p><p><strong>输入：</strong></p><p>一个整数n(1&lt;=n&lt;=10<sup>3</sup>).</p><p><strong>输出：</strong></p><p>打印问题序列 k (0 ≤ k ≤ n) 的长度，后跟 k 个数字 — 问题 y<sub>i</sub> (1 ≤ y<sub>i</sub> ≤ n)。</p><p><strong>思路：</strong></p><p>如果Petya没有问p<sup>k</sup>，其中p是素数且k ≥ 1，他将无法区分p<sup>k - 1</sup>和p<sup>k</sup>。 也就是说，他应该问所有的数字p<sup>k</sup>。很容易证明这个序列实际上猜出了从 1 到 n 的所有数字</p><p><strong>code:</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin &gt;&gt; n;<br>    <span class="hljs-function">vi <span class="hljs-title">is_prime</span><span class="hljs-params">(n + <span class="hljs-number">1</span>, <span class="hljs-literal">true</span>)</span>, primes</span>;<br>    is_prime[<span class="hljs-number">0</span>] = is_prime[<span class="hljs-number">1</span>] = <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">2</span>; i * i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = i * i; j &lt;= n; j += i) &#123;<br>                is_prime[j] = <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>    vector&lt;<span class="hljs-type">int</span>&gt; ans;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt;= n; i++) &#123;<br>        <span class="hljs-keyword">if</span> (is_prime[i]) &#123;<br>            <span class="hljs-type">int</span> q = <span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">while</span> (q &lt;= n / i) &#123;<br>                q *= i;<br>                ans.<span class="hljs-built_in">push_back</span>(q);<br>            &#125;<br>        &#125;<br>    &#125;<br>    cout&lt;&lt;ans.<span class="hljs-built_in">size</span>()&lt;&lt;endl;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> e:ans) cout&lt;&lt;e&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="wed"><a class="markdownIt-Anchor" href="#wed"></a> Wed</h2><p><a href="https://codeforces.com/contest/1165/problem/E">Two Arrays and Sum of Functions</a></p><p><strong>题目翻译：</strong></p><p>给你两个数组a和b，长度都为n</p><p>定义一个函数：</p><p><img src="../imgs/tea5-13-5-17/image-20240518001130370.png" alt="f(l,r)=um_{l&lt;=i&lt;=r}a_i * b_i" /></p><p>您的任务是对数组的元素重新排序（选择任意元素顺序）𝑏 来最小化</p><p><img src="../imgs/tea5-13-5-17/image-20240518001142307.png" alt="um_{1&lt;=l&lt;=r&lt;=n}f(l,r)" /></p><p>由于答案可能非常大，因此您必须以 998244353 为模来打印它 998244353 。请注意，您应该最小化答案，但不要最小化其余数。</p><p><strong>输入：</strong></p><p>第一行一个整数n（1&lt;=n&lt;=2*10<sup>5</sup>),代表数组a和b的长度</p><p>第二行包含n个整数a<sub>1</sub>,a<sub>2</sub>,a<sub>3</sub>,…,a<sub>n</sub>(1&lt;=a<sub>i</sub>&lt;=10<sup>6</sup>)</p><p>第二行包含n个整数b<sub>1</sub>,b<sub>2</sub>,b<sub>3</sub>,…,b<sub>n</sub>(1&lt;=b<sub>i</sub>&lt;=10<sup>6</sup>)</p><p><strong>输出：</strong></p><p>一个整数，代表上述函数的最小可能值</p><p><strong>思路：</strong></p><p>让我们使用对求和技术的贡献来解决这个问题。值 a<sub>i</sub>⋅b<sub>i</sub> 会在答案里出现多少次呢？它将发生 i⋅（n−i+1）次。好的，现在我们可以看到，对于每个位置 i 我们的值为 a<sub>i</sub>⋅b<sub>i</sub>⋅i⋅（n−i+1）.唯一的非常量值是 b<sub>i</sub>.所以设 val<sub>i</sub>=a<sub>i</sub>⋅i⋅（n−i+1）.请注意，您不能在此处取此值模998244353因为那样就无法正确比较这些值。我们应该配对最小 b<sub>i</sub><br />具有最大 val<sub>i</sub>，第二个最小值与第二个最大值，依此类推。因此，让我们对数组 val 进行排序和数组 b，反转数组 b 并计算值 Val<sub>i</sub>⋅b<sub>i</sub> 的总和（不要忘记这里的模数！)</p><p><strong>code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    <span class="hljs-function">vi <span class="hljs-title">a</span><span class="hljs-params">(n)</span>, <span class="hljs-title">b</span><span class="hljs-params">(n)</span></span>;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin&gt;&gt;a[i];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) cin&gt;&gt;b[i];<br>    <span class="hljs-built_in">sort</span>(b.<span class="hljs-built_in">begin</span>(), b.<span class="hljs-built_in">end</span>());<br>vector&lt;pair&lt;<span class="hljs-type">long</span> <span class="hljs-type">long</span>, <span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">val</span>(n);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>val[i].first = (i + <span class="hljs-number">1</span>) * <span class="hljs-number">1ll</span> * (n - i) * a[i];<br>val[i].second = i;<br>&#125;<br><span class="hljs-built_in">sort</span>(val.<span class="hljs-built_in">rbegin</span>(), val.<span class="hljs-built_in">rend</span>());<br><span class="hljs-type">int</span> ans = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ++i) &#123;<br>ans = (ans + (val[i].first % MOD * <span class="hljs-number">1ll</span> * b[i]) % MOD) % MOD;<br>&#125;<br>cout &lt;&lt; ans &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="thu"><a class="markdownIt-Anchor" href="#thu"></a> Thu</h2><p><a href="https://codeforces.com/contest/1878/problem/F">Vasilije Loves Number Theory</a></p><p>题目翻译：</p><p>Vasilije 是一个聪明的学生，他的离散数学老师 Sonja 把他的数论教得很好。他给了 Ognjen 一个正整数 𝑛 。</p><p>表示 𝑑(𝑛) 作为 𝑛 的正整数除数的数量，并表示 𝑔𝑐𝑑(𝑎,𝑏) 作为最大整数 𝑔 这样 𝑎 可以被𝑔整除和 𝑏 可以被𝑔整除。</p><p>之后，他给了 Ognjen 𝑞 个查询，有 2 种查询类型。</p><ul><li>1 𝑥 — 设置 𝑛 到 𝑛⋅𝑥 ，然后回答以下问题：是否存在正整数𝑎 使得 𝑔𝑐𝑑(𝑎,𝑛)=1 ，并且 𝑑(𝑛⋅𝑎)=𝑛 ？</li><li>2 - 重置n为其初始值（在任何查询之前）</li></ul><p>请注意 𝑛 在类型 1 查询后不会返回到其初始值。</p><p>由于 Ognjen 害怕数论，Vasilije 向他保证，每次查询后，𝑑(𝑛)≤10<sup>9</sup>然而，即使有这样的限制，他仍然需要你的帮助来解决这个问题。</p><p><strong>输入：</strong></p><p>第一行包含一个正整数𝑡 , (1≤𝑡≤100) — 测试用例的数量。</p><p>每个测试用例的第一行包含2 整数，𝑛 和𝑞 (1≤𝑛≤10<sup>6</sup>, 1≤𝑞≤1000) — 数字 𝑛 以及查询的数量。</p><p>以下𝑞 行包含一个整数 𝑘 (1 ≤ 𝑘 ≤ 2 ), 如果 𝑘=1 那么这一行还有另一个整数𝑥 (1 ≤ 𝑥 ≤ 10<sup>6</sup>) — 查询的描述。</p><p>对于给定的输入，保证 𝑑(𝑛)  不超过10<sup>9</sup>在任何时候。 保证 𝑞 的总和所有测试用例不超过10<sup>3</sup> 。</p><p><strong>输出：</strong></p><p>对于每个类型 1 查询，如果满足条件输出“YES”，否则输出“NO”。</p><p><strong>思路：</strong></p><p>当且仅当d(n)整除于n是存在解</p><p>proof：</p><p><img src="../imgs/tea5-13-5-17/image-20240517231438423.png" alt="证明" /></p><p><strong>code：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ll long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ull unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vi vector<span class="hljs-string">&lt;int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> vll vector<span class="hljs-string">&lt;ll&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pb(x) push_back(x)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> out(x) cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> pii pair<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mii map<span class="hljs-string">&lt;int,int&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mp(x,y) make_pair(x,y)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MOD 1000000007</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> F first</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> S second</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> gcd(a,b) __gcd(a,b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lcm(a,b) (a*b)/gcd(a,b)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> mem(a,b) memset(a,b,sizeof(a))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> FOR(i, a, b) for (int (i) = (a); (i) &lt;= (b); ++(i))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ROF(i, a, b) for (int (i) = (a); (i) &gt;= (b); --(i))</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> BUG(x) cerr &lt;&lt; #x &lt;&lt; <span class="hljs-string">&quot; = &quot;</span> &lt;&lt; (x) &lt;&lt; endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sort(a) sort (a.begin(),a.end())</span><br><span class="hljs-comment">//#define rsort(v) sort(v.rbegin(),v.rend());</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> gsort(a) sort(a.begin(), a.end(), greater<span class="hljs-string">&lt;ll&gt;</span>())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rvs(a) reverse(a.begin(),a.end())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ctv(v) for(auto it:v)cout&lt;&lt;it&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>; cout&lt;&lt;endl;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> cnv(v) for(auto &amp;it:v) cin&gt;&gt;it;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> all(v) v.begin(),v.end()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> rall(v) v.rbegin(),v.rend()</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v_sum(a) accumulate(a.begin(),a.end(),0)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v_min(a) *min_element (a.begin(),a.end())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> v_max(a) *max_element (a.begin(),a.end())</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> upbd(v,x) upper_bound(v.begin(),v.end(),r)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> lwbd(v,x) lower_bound(v.begin(),v.end(),r)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> sp cout&lt;&lt;fixed&lt;&lt;setprecision(10)&lt;&lt;num&lt;&lt;endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> test ll t;cin&gt;&gt;t;while(t--)</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> gap <span class="hljs-string">&quot; &quot;</span></span><br><span class="hljs-type">const</span> <span class="hljs-type">int</span> N=<span class="hljs-number">2e6</span>+<span class="hljs-number">10</span>;<br><span class="hljs-type">const</span> ll mod=<span class="hljs-number">1000000007</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> INF 1e18;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> print(a) for(auto e:a) cout&lt;&lt;e&lt;&lt;<span class="hljs-string">&#x27; &#x27;</span>;</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> yes cout&lt;&lt;<span class="hljs-string">&quot;YES&quot;</span>&lt;&lt;endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> no cout&lt;&lt;<span class="hljs-string">&quot;NO&quot;</span>&lt;&lt;endl</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> xd ios_base::sync_with_stdio(false); cin.tie(NULL);</span><br><span class="hljs-keyword">namespace</span> io &#123;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fastio</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        ios::<span class="hljs-built_in">sync_with_stdio</span>(<span class="hljs-literal">false</span>);<br>        cin.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>), cout.<span class="hljs-built_in">tie</span>(<span class="hljs-number">0</span>);<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">int</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> op = <span class="hljs-built_in">getchar</span>(); <span class="hljs-type">int</span> x = <span class="hljs-number">0</span>, f = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">while</span> (op &lt; <span class="hljs-number">48</span> || op &gt; <span class="hljs-number">57</span>) &#123;<span class="hljs-keyword">if</span> (op == <span class="hljs-string">&#x27;-&#x27;</span>) f = <span class="hljs-number">-1</span>; op = <span class="hljs-built_in">getchar</span>();&#125;<br>        <span class="hljs-keyword">while</span> (<span class="hljs-number">48</span> &lt;= op &amp;&amp; op &lt;= <span class="hljs-number">57</span>) x = (x &lt;&lt; <span class="hljs-number">1</span>) + (x &lt;&lt; <span class="hljs-number">3</span>) + (op ^ <span class="hljs-number">0x30</span>), op = <span class="hljs-built_in">getchar</span>();<br>        <span class="hljs-keyword">return</span> x * f;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">inline</span> <span class="hljs-type">void</span> <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-keyword">if</span> (x &lt; <span class="hljs-number">0</span>) <span class="hljs-built_in">putchar</span>(<span class="hljs-string">&#x27;-&#x27;</span>), x = -x;<br>        <span class="hljs-keyword">if</span> (x &gt; <span class="hljs-number">9</span>) <span class="hljs-built_in">write</span>(x / <span class="hljs-number">10</span>);<br>        <span class="hljs-built_in">putchar</span>(x % <span class="hljs-number">10</span> + <span class="hljs-number">0x30</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> io;<br>mii powers;<br>mii original_divisors;<br><span class="hljs-type">int</span> smallest_divisor[N];<br><span class="hljs-type">bool</span> mark[N];<br>ll divisor_count = <span class="hljs-number">1</span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">prime</span><span class="hljs-params">()</span></span>&#123; <span class="hljs-comment">//calculates the smallers divisor for each number from 1 to N (sieve of erathosetenes)</span><br>smallest_divisor[<span class="hljs-number">1</span>]=<span class="hljs-number">1</span>;<br>smallest_divisor[<span class="hljs-number">2</span>]=<span class="hljs-number">2</span>;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">4</span>; i&lt;N; i+=<span class="hljs-number">2</span>)&#123;<br>mark[i]=<span class="hljs-literal">true</span>;<br>smallest_divisor[i]=<span class="hljs-number">2</span>;<br>&#125;<br><span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">3</span>; i&lt;N; i+=<span class="hljs-number">2</span>)&#123;<br><span class="hljs-keyword">if</span>(!mark[i])&#123;<br>smallest_divisor[i]=i;<br><span class="hljs-keyword">for</span>(ll j = i*<span class="hljs-number">1ll</span>*i; j&lt;N; j+=<span class="hljs-number">2</span>*i)&#123;<br><span class="hljs-keyword">if</span>(!mark[j])&#123;<br>smallest_divisor[j]=i;<br>mark[j]=<span class="hljs-number">1</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">factorize</span><span class="hljs-params">(<span class="hljs-type">int</span> x)</span></span>&#123; <br><span class="hljs-type">int</span> p=<span class="hljs-number">0</span>;<br><span class="hljs-type">int</span> current_divisor = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(x&gt;<span class="hljs-number">1</span>)&#123; <span class="hljs-comment">//while x has non 1 divisors, divide it by it&#x27;s smallest divisor which isn&#x27;t 1(smallers divisor if always prime)</span><br><span class="hljs-keyword">if</span>(smallest_divisor[x]!=current_divisor)&#123;<br><span class="hljs-keyword">if</span>(p&gt;<span class="hljs-number">0</span>)&#123;<br>divisor_count/=powers[current_divisor]+<span class="hljs-number">1</span>;<br>powers[current_divisor]+=p;<br>divisor_count*=powers[current_divisor]+<span class="hljs-number">1</span>;<br>&#125;<br>p=<span class="hljs-number">1</span>;<br>current_divisor=smallest_divisor[x];<br>&#125;<br><span class="hljs-keyword">else</span>&#123;<br>p++;<br>&#125;<br>x/=smallest_divisor[x];<br>&#125;<br><span class="hljs-keyword">if</span>(p&gt;<span class="hljs-number">0</span>)&#123;<br>divisor_count/=powers[current_divisor]+<span class="hljs-number">1</span>;<br>powers[current_divisor]+=p;<br>divisor_count*=powers[current_divisor]+<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">solve</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n; <span class="hljs-type">int</span> q;<br>    cin &gt;&gt; n &gt;&gt; q;<br>    <span class="hljs-built_in">factorize</span>(n);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> prime : powers)&#123;<br>        original_divisors[prime.first]=prime.second;<br>    &#125;<br>    <span class="hljs-type">int</span> original_divisor_count = divisor_count; <br>    vector&lt;<span class="hljs-type">int</span>&gt; queries;<br>    <span class="hljs-keyword">while</span>(q--)&#123;<br>        <span class="hljs-type">int</span> query_type;<br>        cin &gt;&gt; query_type;<br>        <span class="hljs-keyword">if</span>(query_type==<span class="hljs-number">1</span>)&#123; <br>            <span class="hljs-type">int</span> x;<br>            cin &gt;&gt; x;<br>            <span class="hljs-built_in">factorize</span>(x); <br>            queries.<span class="hljs-built_in">push_back</span>(x); <br>            ll num=n;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> query : queries)&#123; <br>                num*=query;<br>                num%=divisor_count;<br>            &#125;<br>            <span class="hljs-keyword">if</span>(num==<span class="hljs-number">0</span>)&#123; <br>                cout &lt;&lt; <span class="hljs-string">&quot;YES\n&quot;</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> cout &lt;&lt; <span class="hljs-string">&quot;NO\n&quot;</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123; <br>            powers.<span class="hljs-built_in">clear</span>(); <br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> original_div : original_divisors)&#123;<br>                powers[original_div.first]=original_div.second;<br>            &#125;<br>            divisor_count=original_divisor_count; <br>            queries.<span class="hljs-built_in">clear</span>(); <br>        &#125;<br>    &#125;<br>    original_divisors.<span class="hljs-built_in">clear</span>();<br>    powers.<span class="hljs-built_in">clear</span>();<br>    divisor_count=<span class="hljs-number">1</span>;<br>    original_divisor_count =<span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-function">xd</span><br><span class="hljs-function">    <span class="hljs-title">prime</span><span class="hljs-params">()</span></span>;<br>    test&#123;<br>        <span class="hljs-built_in">solve</span>();<br>        <span class="hljs-keyword">if</span>(t) cout &lt;&lt; <span class="hljs-string">&quot;\n&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>codeforces</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
      <tag>algorithm</tag>
      
      <tag>tea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Bigtable</title>
    <link href="/2024/05/11/Bigtable/"/>
    <url>/2024/05/11/Bigtable/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="bigtable结构化数据的分布式存储系统"><a class="markdownIt-Anchor" href="#bigtable结构化数据的分布式存储系统"></a> <a href="https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/bigtable-osdi06.pdf">Bigtable：结构化数据的分布式存储系统</a></h1><h2 id="概要"><a class="markdownIt-Anchor" href="#概要"></a> 概要</h2><p>Bigtable是一个用于管理结构化数据的分布式存储系统，旨在扩展到非常大的尺寸：数千台商用服务器上的PB级数据。Google 的许多项目都将数据存储在 Bigtable 中，包括网络索引、Google Earth 和 Google Finance。这些应用程序对 Bigtable 提出了截然不同的要求，无论是在数据大小（从 URL 到网页到卫星图像）还是延迟要求（从后端批量处理到实时数据服务）方面。尽管存在这些不同的需求，Bigtable 仍然成功地为所有这些 Google 产品提供了灵活的高性能解决方案。在本文中，我们描述了 Bigtable 提供的简单数据模型，该模型使客户端能够动态控制数据布局和格式，并描述了 Bigtable 的设计和实现。</p><h2 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1 介绍</h2><p>在过去的两年半中，我们设计、实现和部署了一个分布式存储系统，用于管理 Google 的结构化数据，称为 Bigtable。Bigtable 旨在可靠地扩展到 PB 级数据和数千台机器。Bigtable 实现了多个目标：广泛适用性、可扩展性、高性能和高可用性。Bigtable 被 60 多个 Google 产品和项目使用，包括 Google Analytics、Google Finance、Orkut、个性化搜索、Writely 和 Google Earth。这些产品将 Bigtable 用于各种要求苛刻的工作负载，从面向吞吐量的批处理作业到向最终用户提供对延迟敏感的数据。这些产品使用的 Bigtable 集群涵盖范围广泛的服务器，从少量到数千台服务器，并存储多达数百 TB 的数据。</p><p>在许多方面，Bigtable 类似于一个数据库：它与数据库共享许多实现策略。Parallel 数据库和主内存数据库已经实现了可扩展性和高性能，但 Bigtable 提供了与此类系统不同的接口。Bigtable不支持完整的关系数据模型；相反，它为客户端提供了一个简单的数据模型，支持对数据布局和格式的动态控制，并允许客户端推断底层存储中表示的数据的局部性属性。使用行名和列名（可以是任意字符串）对数据进行索引。Bigtable 还将数据视为未解释的字符串，尽管客户端经常将各种形式的结构化和半结构化数据序列化到这些字符串中。客户可以通过仔细选择其模式来控制数据的位置。最后，Bigtable模式参数允许客户端动态控制是从内存还是从磁盘提供数据。</p><p>第 2 节更详细地描述了数据模型，第 3 节提供了客户端 API 的概述。第4节简述了Bigtable所依赖的底层Google基础设施。第5节描述了Bigtable实现的基础知识，第6节描述了我们为提高Bigtable性能所做的一些改进。我们在第 7 节中描述了 Google 如何使用 Bigtable 的几个示例，并在第 8 节中讨论了我们在设计和支持 Bigtable 时学到的一些经验教训。最后，第9节描述了相关工作，第10节介绍了我们的结论。</p><h2 id="2-数据模型"><a class="markdownIt-Anchor" href="#2-数据模型"></a> 2 数据模型</h2><p>Bigtable是一个稀疏的、分布式的、持久的多维排序映射。该映射通过行键、列键和时间戳进行索引；映射中的每个值都是未解释的字节数组。</p><p><code>(row:string, column:string, time:int64) -&gt; string </code></p><p><img src="../imgs/Bigtable/image-20240511210040299.png" alt="图 1：存储网页的示例表的切片。行名是反转的 URL。内容列族包含页面内容，锚点列族包含引用该页面的任何锚点的文本。CNN的主页被《体育画报》和MY-look主页引用，因此该行包含名为anchor:cnnsi.com和anchor：my.look.ca的列。每个锚单元格都有一个版本;内容列有三个版本，时间戳为 T3、T5 和 T6。" /></p><p>在检查了类似 Bigtable 的系统的各种潜在用途后，我们决定采用这个数据模型。作为推动我们的一些设计决策的一个具体示例，假设我们向阳保留大量网页和相关信息的副本，供许多不同的项目使用；让我们将这个特定的表称为Webtable。在Webtable中，我们将使用URL作为行键，使用网页的各个方面作为列名称，并将网页内容存储在抓取时的时间戳下的contents：column中，如图1所示。</p><h3 id="行"><a class="markdownIt-Anchor" href="#行"></a> 行</h3><p>在一个表中行键值是任意的字符串（目前最大大小为64kb，尽管10-100字节时我们大多数用户的典型大小）。在单个行键下读取或写入数据的每次都是原子的（无论行中读取或写入的不同列的数量如何），这种设计决策使客户端更容易在同一行存在并发更新的情况下推理系统的行为。</p><p>Bigtable按行键的字典顺序维护数据。一个表的行范围是动态分区的。每一个行范围称为一个tablet，它是分配和负载均衡的单位。因此，短行范围的读取是有效的，并且通常只需要与少量机器进行通信。客户端可以通过选择行键来利用此属性，以便获得良好的数据访问局部性。例如，在Webtable中，通过反转URL的主机名部分，同一域中的页面被分组为连续的行。例如，<a href="http://xn--maps-965f170emvj.google.com/index.html%E7%9A%84%E6%95%B0%E6%8D%AE%E5%AD%98%E5%82%A8%E5%9C%A8com.google.maps/index.htm%E9%94%AE%E4%B8%8B%E3%80%82%E5%B0%86%E6%9D%A5%E8%87%AA%E5%90%8C%E4%B8%80%E5%9F%9F%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%BD%BC%E6%AD%A4%E9%9D%A0%E8%BF%91%E5%AD%98%E5%82%A8%E5%8F%AF%E4%BB%A5%E4%BD%BF%E6%9F%90%E4%BA%9B%E4%B8%BB%E6%9C%BA%E5%92%8C%E5%9F%9F%E5%88%86%E6%9E%90%E6%9B%B4%E5%8A%A0%E6%9C%89%E6%95%88%E3%80%82">我们将maps.google.com/index.html的数据存储在com.google.maps/index.htm键下。将来自同一域的页面彼此靠近存储可以使某些主机和域分析更加有效。</a></p><h3 id="列族"><a class="markdownIt-Anchor" href="#列族"></a> 列族</h3><p>列键被分组为称为列族的集合，它们构成访问控制的基本单元。存储在了列族中的所有数据通常都是相同的类型（我们将同一列族中的数据压缩在一起）。必须先创建列族，然后才能将数据存储在该族中的任何一个列键下；创建族后，可以使用族内的任何列键。我们的目的是表中不同列族的数量很小（最多数百个），并且列族在操作过程中很少发生变化。相反，表可以具有无限数量的列。</p><p>列键使用以下语法命名：family：qualifier。列族名称必须是可打印的，但限定符可以是任意字符串。Webtable的一个示例列族是language，它存储编写网页所用的语言。我们只使用language族中的一个列键，它存储每个网页的语言ID。该表的另一个有用的列族是锚；该族中的每个列键代表一个锚点，如图1所示。限定符是引用站点的名称；单元格内容是链接文本。</p><p>访问控制以及磁盘和内存和酸都是在列族级别执行的。在我们Webtable示例中，这些控件使我们能够管理几种不同类型的应用程序：有些添加新的基础数据，有些读取基础数据并创建派生列族，有些只允许查看现有数据（处于隐私原因甚至可能不允许查看所有现有列族）。</p><h3 id="时间戳"><a class="markdownIt-Anchor" href="#时间戳"></a> 时间戳</h3><p>Bigtable中的每个单元格可以包含相同数据的多个版本；这些版本按时间戳索引。Bigtable时间戳是64位整数。它们可以由 Bigtable 签名，在这种情况下，它们以微秒为单位表示“实时”，也可以由客户端应用程序显式分配。需要避免冲突的应用程序必须自己生成唯一的时间戳。单元的不同版本按时间戳降序存储，以便可以首先读取最新版本。</p><p><strong><code>写入Bigtable</code></strong></p><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs pf">// Open the <span class="hljs-built_in">table</span> <br>Table *T = OpenOrDie(<span class="hljs-string">&quot;/bigtable/web/webtable&quot;</span>); <br>// Write a new <span class="hljs-built_in">anchor</span> and delete an old <span class="hljs-built_in">anchor</span> <br>RowMutation r1(T, <span class="hljs-string">&quot;com.cnn.www&quot;</span>); <br>r1.Set(<span class="hljs-string">&quot;anchor:www.c-span.org&quot;</span>, <span class="hljs-string">&quot;CNN&quot;</span>); <br>r1.Delete(<span class="hljs-string">&quot;anchor:www.abc.com&quot;</span>); <br>Operation op; <br>Apply(&amp;op, &amp;r1); <br></code></pre></td></tr></table></figure><p>为了减轻版本数据的管理负担，我们支持两个每列族设置，告诉Bigtable自动垃圾收集单元版本。客户端可以指定仅保留单元的最后 n 个版本，或者仅保留足够新的版本（例如，仅保留最近 7 天内写入的值）。</p><p>在我们的 Webtable 示例中，我们将存储在 content：column中的已爬网页的时间戳设置为实际爬取这些页面版本的时间。上面描述的垃圾回收机制允许我们只保留每个页面的最新三个版本。</p><h2 id="3-api"><a class="markdownIt-Anchor" href="#3-api"></a> 3 API</h2><p>Bigtable API 提供了创建和删除表和列族的功能。它还提供更改集群、表和列族元数据的功能，例如访问控制权限。</p><p>客户端应用程序可以在 Bigtable 中写入或删除值、从各个行查找值或迭代表中的数据子集。图 2 显示了使用 RowMutation 抽象来按形式进行一系列更新的 C++ 代码。（省略了不相关的细节，以保持示例简短。对 Apply 的调用对 Webtable 执行原子突变：它向 <a href="http://www.cnn.com">www.cnn.com</a> 添加一个锚点并删除另一个锚点。</p><p>图 3 显示了使用 Scanner 抽象遍历特定行中所有定位点的 C++ 代码。客户端可以遍历多个列族，并且有多种机制可用于限制扫描生成的行、列和时间戳。例如，我们可以将上面的扫描限制为仅生成其列与正则表达式锚点匹配的锚点：*.cnn.com，或者仅生成时间戳落在当前时间十天内的锚点。</p><p>从Bigtable读取：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xl">Scanner scanner(T); <br><br>ScanStream *stream; <br><br>stream = scanner.FetchColumnFamily(<span class="hljs-string">&quot;anchor&quot;</span>); <br><br><span class="hljs-function"><span class="hljs-title">stream</span>-&gt;</span>SetReturnAllVersions(); <br><br>scanner.Lookup(<span class="hljs-string">&quot;com.cnn.www&quot;</span>); <br><br><span class="hljs-function"><span class="hljs-title">for</span> (; !stream-&gt;</span>D<span class="hljs-function"><span class="hljs-title">one</span>(); stream-&gt;</span>Next()) &#123; <br><br>printf(<span class="hljs-string">&quot;%s %s %lld %s\n&quot;</span>, <br><br>scanner.RowName(), <br><br><span class="hljs-function"><span class="hljs-title">stream</span>-&gt;</span>ColumnName(), <br><br><span class="hljs-function"><span class="hljs-title">stream</span>-&gt;</span>MicroTimestamp(), <br><br><span class="hljs-function"><span class="hljs-title">stream</span>-&gt;</span>Value()); <br><br>&#125;<br></code></pre></td></tr></table></figure><p>Bigtable 支持其他几个功能，允许用户以更复杂的方式操作数据。首先，Bigtable 支持单行事务，可用于对存储在单行键下的数据执行原子读取-修改-写入序列。Bigtable 目前不支持跨行键的一般事务，尽管它提供了一个用于在客户端跨行键批量写入的接口。其次，Bigtable 允许将单元格用作整数计数器。最后，Bigtable 支持在服务器的地址空间中执行客户端提供的脚本。这些脚本是用 Google 开发的一种名为 Sawzall 的数据处理语言编写的。目前，我们基于 Sawzall 的 API 不允许客户端脚本写回 Bigtable，但它允许各种形式的数据转换、基于任意表达式的过滤以及通过各种运算符进行汇总。</p><p>Bigtable 可以与 MapReduce 一起使用，MapReduce 是 Google 开发的运行大规模并行计算的框架。我们编写了一组包装器，允许将 Bigtable 用作 MapReduce 作业的输入源和输出目标。</p><h2 id="4-建筑模块"><a class="markdownIt-Anchor" href="#4-建筑模块"></a> 4 建筑模块</h2><p>Bigtable是建立在Google基础架构的其他几个部分之上的。Bigtable使用分布式Google文件系统（GFS）来存储日志和数据文件。Bigtable集群通常在运行各种其他分布式应用程序的计算机共享池中运行，并且Bigtable进程通常与其他应用程序的进程共享同一台计算机。Bigtable依赖于集群管理系统来调度作业、管理共享机器上的资源、处理机器故障以及监视机器状态。</p><p>Google SSTable文件格式在内部使用来存储Bigtable数据。SSTable提供了从键到值的持久的、有序的不可变映射，其中键和值都是任意字节字符串。提供了一些操作来查找与指定键关联的值，并循环访问指定键范围内的所有键/值对。在内部，每个SSTable包含一系列块（通常每个块的大小为64KB，但这是可配置的）。块索引（存储在SSTable的末尾）用于定位块；当SSTable打开时，索引被加载到内存中。可以通过单个磁盘查找来执行查找：我们首先通过在内存索引中执行二分搜索来找到适当的块，然后从磁盘中读取适当的块。或者，SSTable可以完全映射到内存中，这使我们能够在不接触磁盘的情况下执行查找和扫描。</p><p>Bigtable依赖于一个名为Chubby的高可用且持久的分布式锁服务。一个Chubby服务由5个活动副本组成，其中一个被选举为主副本并主动服务请求。当大多数副本正在运行并且可以相互通信时，该服务处于活动状态。Chubby使用Paxos算法在出现故障时保持其副本的一致性。Chubby提供了一个由目录和小文件组成的命名空间。每个目录或文件都可以用作锁，并且对文件的读取和写入是原子的。Chubby客户端库提供了Chubby文件的一致缓存。每个Chubby客户端都维护与Chubby服务的会话。如果客户端无法在租约到期时间内续订其会话租约，则客户端的会话将到期。当客户端的会话过期时，它会丢失所有锁和打开的句柄。Chubby客户端还可以在Chubby文件和目录上注册回调，以通知更改或会话过期。</p><p>Bigtable使用Chubby执行各种任务：确保在任何时候最多有一个活动主节点;存储 Bigtable 数据的引导位置（参见第 5.1 节）;发现tablet服务器并确定tablet服务器死亡（请参阅第 5.2 节）;存储 Bigtable 架构信息（每个 table 的列族信息）;并存储访问控制列表。如果 Chubby 在很长一段时间内不可用，则 Bigtable 将不可用。我们最近在跨越 11 个 Chubby 实例的 14 个 Bigtable 集群中检验了这种效果。由于 Chubby 不可用（由 Chubby 中断或网络问题引起）而导致存储在 Bigtable 中的某些数据不可用的 Bigtable 服务器时间的平均百分比为 0.0047%。受 Chubby 不可用性影响最大的单个集群的百分比为 0.0326%。</p><h2 id="5-实现"><a class="markdownIt-Anchor" href="#5-实现"></a> 5 实现</h2><p>Bigtable实现具有三个主要组件：链接到每个客户端的库、一台主服务器和许多tablet服务器。可以从集群中动态添加或删除tablet服务器，以适应工作负载的变化。</p><p>master负责将tablet分配给tablet服务器、检测tablet服务器的添加和过期、平衡tablet服务器负载以及GFS中文件的垃圾收集。此外，它还处理架构更改，例如表和列族的创建。</p><p>每个tablet服务器管理一组tablet（通常每个tablet服务器有十到一千个tablet）。tablet服务器处理对其已加载到table的读写请求，并且分割内存已经变得太大的tablet。</p><p>与许多单主机分布式存储系统一样，客户端数据不通过主机移动：客户端直接与tablet服务器通信以进行读取和写入。由于Bigtable客户端不依赖主服务器获取tablet位置信息，因此大多数客户端从不与主服务器通信。因此，master在实践中的负载很轻。</p><p>Bigtable集群存储许多表。每个表由一组tablet组成，每个tablet包含与行范围相关联的所有数据。最初，每个表仅包含一个tablet，随着表的增长，它会自动拆分为多个片，默认情况下每个片的大小约为100-200MB。</p><h3 id="51-tablet位置"><a class="markdownIt-Anchor" href="#51-tablet位置"></a> 5.1 Tablet位置</h3><p>我们使用类似于B+树的三级层次结构来存储tablet的位置信息（图4）。</p><p><img src="../imgs/Bigtable/image-20240511210136031.png" alt="图4" /></p><p>第一层是存储在Chubby中的文件，其中包含根数据块的位置。根tablet包含所有tablet在特殊METADATA表中的位置。每个元数据tablet都包含一组用户tablet的位置。根tablet只是METADATA表中的第一个tablet，但经过特殊处理——它永远不会被分割——以确保tablet位置层次结构不超过三个级别。METADATA 表将tablet的位置存储在行键下，该行键是tablet的表标识符及其结束行的编码。每个METADATA行在内存中存储大约1KB的数据。由于128MB元数据tablet的适度限制，我们的三级定位方案足以寻址2<sup>34</sup>个tablet（或者128MBtablet中的2<sup>61</sup>个字节)。</p><p>客户端库缓存tablet位置。如果客户端不知道tablet的位置，或者发现缓存的位置信息不正确，则它会递归地向上移动tablet位置层次结构。如果客户端的缓存为空，则定位算法需要3次网络往返，其中一次从Chubby读取。如果客户端的缓存已过时，则定位算法可能需要最多6次往返，因为过时的缓存条目仅在未命中时才会发现（假设METADATA tablet不经常移动）。尽管tablet位置存储在内存中，因此不需要 GFS 访问，但在常见情况下，我们通过让客户端库预取tablet位置来进一步降低此成本：每当它读取 METADATA 表时，它都会读取多个tablet的元数据。</p><p>我们还在元数据表中存储辅助信息，包括与每个tablet相关的所有事件的日志（例如服务器何时开始为其提供服务）。这些信息有助于调试和性能分析。</p><h3 id="52-tablet分配"><a class="markdownIt-Anchor" href="#52-tablet分配"></a> 5.2 tablet分配</h3><p>每个tablet一次分配给一台tablet服务器。主服务器跟踪一组活动的tablet服务器，以及tbalet到tablet服务器的当前分配，包括哪些tablet未分配。当一个tablet未被分配，并且有足够空间容纳该tablet的tablet服务器可用时，master通过向tablet服务器发送一个tablet加载请求来分配该tablet。</p><p>Bigtable 使用 Chubby 来跟踪tablet服务器。当 Tablet 服务器启动时，它会在特定的 Chubby 目录中创建一个唯一命名的文件，并获取该文件的独占锁。主服务器监视此目录（服务器目录）以发现tablet服务器。如果 Tablet 服务器失去其独占锁，则它会停止为其 Tablet 提供服务：例如，由于网络分区导致服务器丢失其 Chubby 会话。（Chubby 提供了一种有效的机制，允许 Tablet 服务器检查它是否仍然持有锁定，而不会产生网络流量。）只要文件仍然存在，tablet 服务器就会尝试重新获取其文件上的独占锁。如果该文件不再存在，那么tablet服务器将永远无法再次提供服务，因此它会自毁进程。每当tablet服务器终止时（例如，因为集群管理系统正在从集群中删除tablet服务器的机器），它会尝试释放其锁，以便主服务器更快地重新分配其tablet。</p><p>主服务器负责检测tablet服务器何时不再为其tablet提供服务，并尽快重新分配这些tablet。为了检测某个tablet服务器何时不再为其tablet提供服务，master会定期向每个tablet服务器询问其锁的状态。如果一个tablet服务器报告它已经失去了锁，或者如果主服务器在最后几次尝试期间无法到达服务器，则主服务器会尝试获取服务器文件上的独占锁。如果master能够获取锁，那么Chubby是活的，而tablet服务器要么死了，要么无法到达Chubby，所以master通过删除他的服务器文件来确保tablet服务器永远不会再次提供服务。一旦服务器的文件被删除，master就可以将先前分配给该服务器的所有tablet移动到未分配的tablet组中。为了确保Bigtable集群不会受到master和Chubby之间网络问题的影响，如果Chubby会话过期，master就会自毁。然而，如上述所说，主节点故障不会改变tablet到tablet服务器的分配。</p><p>当集群管理系统启动master时，它需要先发现当前的tablet分配，然后才能更改它们。master在启动时执行以下步骤。</p><ol><li>主节点在Chubby中获取唯一的主锁，这可以防止并发主节点实例化。</li><li>主服务器扫描Chubby中的服务器目录以查找活动服务器。</li><li>主服务器与每个活动的tablet服务器进行通信，以发现哪些tablet已分配给每个服务器。</li><li>主服务器扫描元数据表以了解tablet组。</li></ol><p>每当此扫描遇到尚未分配的tablet时，主设备都会将该tablet添加到未分配的tablet集合中，这使得该tablet有资格进行tablet分配。</p><p>一个复杂的情况是，在分配METADATA片之前无法扫描METADATA表。因此，在开始扫描（步骤4）之前，如果在步骤3期间未发现根tablet的分配，则主设备会将根tablet添加到未分配的tablet集合中。此添加可确保分配根tablet。因为根tablet包含所有METADATA tablet的名称，所以master在扫描根tablet后就知道所有这些信息。</p><p>仅当创建或删除表、合并两个现有tablet以形成一个较大的tablet或将现有tablet拆分为两个较小的tablet时，现有tablet集才会发生变化。主设备能够跟踪这些更改，因为它启动了除最后一个之外的所有更改。tablet拆分会被特殊处理，因为它们是由tablet服务器发起的。tabelt服务器通过在METADATA表中记录新tablet的信息来提交拆分。当拆分提交后，它会通知master。为了防止拆分通知丢失（因为tablet服务器或主节点宕机），当master请求tablet服务器加载现在已经分裂的tablet时，它会检测到新的tablet。tablet服务器将通知master拆分的信息，因为它在元数据表中找到的tablet条目将仅指定master要求其加载的tablet的一部分。</p><h3 id="53-tablet服务"><a class="markdownIt-Anchor" href="#53-tablet服务"></a> 5.3 tablet服务</h3><p>tablet的持久状态存储在GFS中，如图5所示。更新被提交到存储重做记录的提交日志中。在这些更新中，最近提交的更新存储在内存中一个称为memtable的排序缓冲区中；较旧的更新存储在一系列SSTable中。为了恢复tablet，tablet服务器从 METADATA 表中读取其元数据。</p><p><img src="../imgs/Bigtable/image-20240511210159571.png" alt="图5" /></p><p>该元数据包含SSTable列表，该列表包含一个tablet和一组重做点，这些重做点是指向可能包含tablet数据的任何提交日志的指针。服务器将SSTable的索引读取到内存中，并通过应用自重做点以来已提交的所有更新来重建内存表。</p><p>当写操作到达tablet服务器时，服务器会检查它的格式是否正确，以及发送者是否有权执行突变。授权是通过从Chubby文件（几乎总是在Chubby客户端缓存中命中）读取允许的写入者列表来执行的。有效的变更将写入提交日志。组提交用于提高大量小突变的吞吐量。提交写入后，其内容将插入到内存表中。</p><p>当读取操作到达tablet服务器时，同样会检查其格式正确性和正确的授权。在SSTable序列和内存表的合并视图上执行有效的读取操作。由于SSTable和memtable时按字典序排序的数据结构，因此可以有效地形成合并视图。</p><p>当tablet被拆分和合并时，传入的读取和写入操作可以继续。</p><h3 id="54-压缩"><a class="markdownIt-Anchor" href="#54-压缩"></a> 5.4 压缩</h3><p>随着写操作的执行，内存表的大小会增加。当memtable大小达到阈值时，memtable被冻结，创建新的memtable，并将冻结的memtable转换为SSTable并写入GFS。这个次要压缩过程有两个目标：它减少了tablet服务器的内存使用量，并且减少了如果该服务器挂掉时在恢复期间必须从提交日志中读取的数据量。当压缩发生时，传入的读和写操作可以继续。</p><p>每次较小的压缩都会创建一个新的 SSTable。如果这种行为继续不加控制，读取操作可能需要合并来自任意数量的 SSTable 的更新。相反，我们通过在后台定期执行合并压缩来限制此类文件的数量。合并压缩读取几个SSTable和memtable的内容，并写出一个新的SSTable。压缩完成后，输入的SSTable和memtable就可以被丢弃。</p><p>将所有SSTable重写为一个SSTable的合并压缩称为主要压缩。非主要压缩生成的SSTable可以包含特殊的删除条目，这些条目会抑制仍然存在的旧SSTable中已删除的数据。另一方面，主要压缩会生成不包含删除信息或已删除数据的SSTable。Bigtable循环遍历其所有tablet，并定期对它们应用主要压缩。这些主要压缩使Bigtable能够回收已删除数据所使用的资源，并确保已删除数据及时从系统中消失，这对于存储敏感数据的服务非常重要。</p><h2 id="6-改进"><a class="markdownIt-Anchor" href="#6-改进"></a> 6 改进</h2><p>上一节中描述的实现需要进行大量改进才能实现用户所需的高性能、可用性和可靠性。本节更详细地描述了部分实现，以突出这些改进。</p><h3 id="位置组"><a class="markdownIt-Anchor" href="#位置组"></a> 位置组</h3><p>客户端可以将多个列族组合到一个位置组中。为每个tablet中的每个位置组生成一个单独的SSTable。将通常不一起访问的列族分离到单独的位置组中可以实现更高效的读取。例如，Webtable中的页面元数据（例如语言和校验和）可以位于一个位置组中，而页面的内容可以位于不同的组中：想要读取元数据的应用程序不需要读取所有页面内容。</p><p>此外，还可以在每个位置组的基础上指定一些有用的优化参数。例如，可以将位置组声明为内存中。内存中位置组的 SSTable 将延迟加载到 Tablet 服务器的内存中。加载后，可以在不访问磁盘的情况下读取属于此类位置组的列名称。此功能对于经常访问的小块数据非常有用：我们在内部将其用于 METADATA 表中的位置列系列。</p><h3 id="压缩"><a class="markdownIt-Anchor" href="#压缩"></a> 压缩</h3><p>客户端可以控制是否压缩位置组的 SSTable，如果是，则使用哪种压缩格式。用户指定的压缩格式应用于每个 SSTable 块（其大小可通过局部组特定调整参数进行控制）。虽然我们通过单独压缩每个块而损失了一些空间，但我们受益于可以读取 SSTable 的一小部分，而无需解压缩整个文件。许多客户端使用两遍自定义压缩方案。第一遍使用 Bentley 和 McIlroy 的方案，该方案在一个大窗口中压缩长的公共字符串。第二遍使用快速压缩算法，在数据的 16 KB 小窗口中查找重复项。两种压缩过程都非常快，在现代机器上，它们的编码速度为 100-200 MB/s，解码速度为 400-1000 MB/s。</p><p>尽管我们在选择压缩算法时强调速度而不是空间减少，但这种两遍压缩方案的表现却出奇的好。例如，在Webtable中，我们使用这种压缩方案来存储网页内容。在一项实验中，我们将大量文档存储在压缩的位置组中。出于实验目的，我们将自己限制为每个文档的一个版本，而不是存储我们可用的所有版本。该方案实现了10比1的空间缩减。由于 Webtable 行的布局方式，这比 HTML 页面上典型的 Gzip 压缩（3 比 1 或 4 比 1）要好得多：来自单个主机的所有页面都彼此靠近存储。这允许 Bentley-McIlroy 算法识别来自同一主机的页面中的大量共享样板。许多应用程序（不仅仅是 Webtable）选择它们的行名，以便类似的数据最终聚集起来，从而实现非常好的压缩比。当我们在Bigtable中存储相同值的多个版本时，压缩率会变得更好。</p><h3 id="缓存以提高读取性能"><a class="markdownIt-Anchor" href="#缓存以提高读取性能"></a> 缓存以提高读取性能</h3><p>为了提高读取性能，tablet服务器使用两个级别的缓存。扫描缓存是一种更高级别的缓存，用于缓存 SSTable 接口返回的键值对到tablet服务器代码。块缓存是一种较低级别的缓存，用于缓存从 GFS 读取的 SSTables 块。扫描缓存对于倾向于重复读取相同数据的应用程序最有用。块缓存对于倾向于读取接近其最近读取的数据（例如，顺序读取或对热行中同一位置组中的不同列的随机读取）的应用程序非常有用。</p><h3 id="布隆过滤器"><a class="markdownIt-Anchor" href="#布隆过滤器"></a> 布隆过滤器</h3><p>如第 5.3 节所述，读取操作必须从构成tablet状态的所有 SSTable 中读取。如果这些 SSTable 不在内存中，我们最终可能会进行许多磁盘访问。我们通过允许客户端指定应为特定位置组中的 SSTables 创建 Bloom 过滤器来减少访问次数。Bloom lter 允许我们询问 SSTable 是否可能包含指定行/列对的任何数据。对于某些应用程序，用于存储 Bloom 过滤器的少量tablet服务器内存可大大减少读取操作所需的磁盘寻道次数。我们使用 Bloom 过滤器还意味着大多数对不存在的行或列的查找不需要接触磁盘。</p><h3 id="提交日志实现"><a class="markdownIt-Anchor" href="#提交日志实现"></a> 提交日志实现</h3><p>如果我们将每个 tablet 的提交日志保存在一个单独的日志文件中，那么 GFS 中将同时写入大量文件。根据每个 GFS 服务器上的底层文件系统实现，这些写入可能会导致大量磁盘寻求写入不同的物理日志。此外，每个tablet都有单独的日志 les 也会降低组提交优化的有效性，因为组往往会更小。为了解决这些问题，我们将突变附加到每个tablet服务器的单个提交日志中，将不同tablet的突变混合在同一物理日志中。</p><p>在正常操作期间使用一个日志可以提供显著的性能优势，但它会使恢复变得复杂。当一个tablet服务器挂掉时，它所服务的tablet将被转移到大量其他tablet服务器上：每个服务器通常加载少量原始服务器的tablet。为了恢复tablet的状态，新的tablet服务器需要从原始tablet服务器写入的提交日志中重新应用该tablet的突变。然而，这些tablet的突变混合在同一个物理日志文件中。一种方法是让每个新的tablet服务器读取此完整的提交日志，并仅应用它需要恢复的tablet所需的条目。但是，在这种方案下，如果 100 台计算机从发生故障的tablet服务器中为每台计算机分配一台tablet，则日志文件将被读取 100 次（每台服务器读取一次）。</p><p>我们通过首先按键&lt;表，行名，日志序列号&gt;的顺序对提交日志条目进行排序来避免重复读取日志。在排序的输出中，特定tablet的所有突变都是连续的，因此可以通过一次磁盘查找和顺序读取来有效地读取。为了并行排序，我们将日志文件划分为64MB的段，并在不同的Tablet服务器上并行对每个段进行排序。此排序过程由主服务器协调，并在Tablet服务器指示它需要从某些提交日志文件中恢复突变时启动。</p><p>将提交日志写入 GFS 有时会导致性能中断，原因有多种（例如，写入崩溃时涉及的 GFS 服务器计算机，或者为到达特定的三台 GFS 服务器而遍历的网络路径遭受网络拥塞，或者负载过重）。为了保护突变免受 GFS 延迟峰值的影响，每个 Tablet 服务器实际上有两个日志写入线程，每个线程写入自己的日志文件；一次只有这两个线程之一处于活动状态。如果对活动日志文件的写入性能不佳，则日志文件写入将切换到另一个线程，并且提交日志队列中的突变将由新的活动日志写入线程写入。日志条目包含序列号，以允许恢复过程消除由该日志切换过程产生的重复条目。</p><h3 id="加速tablet恢复"><a class="markdownIt-Anchor" href="#加速tablet恢复"></a> 加速tablet恢复</h3><p>如果主服务器将一个tablet从一个tablet服务器移动到另一个tablet服务器，则源tablet服务器首先对该tablet进行次要压缩。这种压缩通过减少tablet服务器提交日志中未压缩状态的数量来减少恢复时间。关闭此操作后，tablet服务器将停止为tablet提供服务。在实际卸载tablet之前，tablet服务器会执行其他（通常非常快）的次要压缩，以消除在执行第一次小型压缩时到达的tablet服务器日志中任何剩余的未压缩状态。在第二次较小的压缩完成后，该tablet可以加载到另一个tablet服务器上，而不需要恢复任何日志条目。</p><h3 id="利用不变性"><a class="markdownIt-Anchor" href="#利用不变性"></a> 利用不变性</h3><p>除了SSTable缓存之外，我们生成的所有SSTable都是不可变的，这一事实也简化了Bigtbale系统的各个其他部分。例如，从 SSTable 读取时，我们不需要对文件系统的访问进行任何同步。因此，可以非常有效地实现行的并发控制。唯一可通过读取和写入访问的可变数据结构是内存表。为了减少读取内存表期间的争用，我们使每个内存表行进行写时复制，并允许读取和写入并行进行。</p><p>由于 SSTable 是不可变的，永久删除已删除数据的问题就转化为垃圾收集过时的 SSTable。每个tablet的SSTables都注册在METADATA表中。主节点删除过时的 SSTable，作为 SSTable 集合上的标记和清除垃圾收集，其中 METADATA 表包含根集合。</p><p>最后，SSTables 的不变性使我们能够快速拆分平板电脑。我们让子tablet 共享父tablet 的SSTable，而不是为每个子tablet 生成一组新的SSTable。</p><h2 id="7-经验教训"><a class="markdownIt-Anchor" href="#7-经验教训"></a> 7 经验教训</h2><p>在设计、实现、维护和支持Bigtable的过程中，我们获得了有用的经验，并学到了一些有趣的教训。</p><p>我们学到的一个教训是，大型分布式系统容易遭受多种类型的故障，而不仅仅是许多分布式协议中所设想的标准网络分区和故障停止故障。例如，我们已经见到由于下列原因造成的问题：内存和网络损坏，大时钟偏差，挂机，扩展和对称网络分区，使用其他系统中的错误（比如Chubby），GFS配额溢出，以及计划内和计划外的硬件维护。随着我们在解决这些问题方面获得了更多经验，我们通过更改各种协议来解决这些问题。例如，我们向我们的RPC机制添加了校验和。我们还通过删除系统的一部分对另一部分所做的假设来处理一些问题。例如，我们不再假设给定的 Chubby 操作只能返回一组固定错误中的一个。</p><p>我们学到的另一个教训是，在明确如何使用新功能之前，推迟添加新功能非常重要。例如，我们最初计划在 API 中支持通用交易。因为我们没有立即使用它们，无论如何，我们没有实施它们。现在，我们在 Bigtable 上运行了许多实际应用程序，我们已经能够检查它们的实际需求，并且已经发现大多数应用程序只需要单行反转操作。当人们要求分布式交易时，最重要的用途是维护二级索引，我们计划添加专门的机制来满足这一需求。新机制将不如分布式事务那么通用，但会更高效（特别是对于跨越数百行或更多行的更新），并且还将与我们的乐观跨数据中心复制方案更好地交互。</p><p>我们从支持 Bigtable 中学到的一个实际教训是适当的系统级监控的重要性（即监控 Bigtable 本身以及使用 Bigtable 的客户端进程）。例如，我们扩展了 RPC 系统，以便对于 RPC 样本，它可以保留代表该 RPC 执行的重要操作的详细跟踪。此功能使我们能够检测和解决许多问题，例如 Tablet 数据结构上的锁争用、提交 Bigtable 突变时向 GFS 写入缓慢，以及当 METADATA Tablet 不可用时对 METADATA 表的访问卡住。另一个有用的监控示例是，每个 Bigtable 集群都在 Chubby 中注册。这使我们能够跟踪所有集群，发现它们有多大，查看它们正在运行的软件版本，它们接收了多少传输，以及是否存在任何问题，例如意外的大延迟。</p><p>我们学到的最重要的一课是简单设计的价值。考虑到我们系统的规模（大约 100,000 行非测试代码），以及代码随着时间的推移以意想不到的方式演变的事实，我们发现代码和设计的清晰度对代码维护和调试有很大帮助。其中一项检查是我们的平板电脑-服务器会员协议。我们的第一个协议很简单：主服务器定期向平板电脑服务器发出租约，如果他们的租约到期，平板电脑服务器就会杀死他们自己。不幸的是，在存在网络问题的情况下，这种原型会显著降低可用性，并且对主重新存储时间也很敏感。我们多次重新设计协议，直到我们有一个表现良好的协议。然而，最终的协议过于复杂，并且依赖于其他应用程序很少使用的 Chubby 功能的行为。我们发现我们花费了大量的时间来调试模糊的极端情况，不仅在 Bigtable 代码中，而且在 Chubby 代码中也是如此。最终，我们放弃了这个协议，转而采用一个更新的、更简单的协议，该协议仅依赖于广泛使用的 Chubby 功能。</p><h2 id="8-相关工作"><a class="markdownIt-Anchor" href="#8-相关工作"></a> 8 相关工作</h2><p>Boxwood 项目的组件在某些方面与 Chubby、GFS 和 Bigtable 重叠，因为它提供了分布式协议、锁定、分布式块存储和分布式 B 树存储。在每种有重叠的情况下，Box-wood 的组件似乎都比相应的 Google 服务低一些。Boxwood 项目的目标是为构建更高级别的服务（如文件系统或数据库）提供基础设施，而 Bigtable 的目标是直接支持希望存储数据的客户端应用程序。</p><p>最近的许多项目都解决了在广域网上提供分布式存储或更高级别的服务的问题，通常是在“互联网”规模上。这些系统解决了 Bigtable 不会出现的问题，例如高度可变的带宽、不受信任的参与者或频繁的重新协调;去中心化控制和拜占庭式容错不是 Bigtable 的目标。</p><p>就可能提供给应用程序开发人员的分布式数据存储模型而言，我们认为分布式 B 树或分布式哈希表提供的键值对模型过于局限。键值对是一个有用的构建块，但它们不应该是提供给开发人员的唯一构建块。我们选择的模型比简单的键值对更丰富，并且支持稀疏的半结构化数据。尽管如此，它仍然足够简单，以至于它适合于非常有效的平面文件表示，并且它足够透明（通过位置组），允许我们的用户调整系统的重要行为。</p><p>一些数据库供应商已经开发了可以存储大量数据的并行数据库。Oracle 的 Real Application Cluster 数据库 [27] 使用共享磁盘来存储数据（Bigtable 使用 GFS）和分布式锁管理器（Bigtable 使用 Chubby）。IBM 的 DB2 Parallel Edition [4] 基于类似于 Bigtable 的无共享 [33] 架构。每个 DB2 服务器负责表中行的子集，该行存储在本地关系数据库中。这两种产品都提供了一个完整的事务关系模型。</p><p>对于使用基于列而不是基于行的存储在磁盘上组织数据的其他系统，包括 C-Store [1， 34] 和商业产品，如 Sybase IQ [15， 36]、SenSage [31]、KDB+ [22] 和 MonetDB/X100 中的 ColumnBM 存储层 [38]，Bigtable 局部组实现了类似的压缩和磁盘读取性能。另一个将垂直和水平数据划分为atles并实现良好数据压缩比的系统是AT&amp;T的Day-tona数据库[19]。局部组不支持 CPU 缓存级别的优化，例如 Ailamaki [2] 所描述的优化。</p><p>Bigtable 使用 memtables 和 SSTables 来存储平板电脑更新的方式类似于日志结构化合并树 [26] 存储更新以索引数据的方式。在这两种系统中，排序后的数据在写入磁盘之前都会在内存中缓冲，并且读取必须合并内存和磁盘中的数据。</p><p>C-Store 和 Bigtable 有许多共同的特点：这两个系统都使用无共享架构，并具有两种不同的数据结构，一种用于存储最近的写入，另一种用于存储长期数据，并具有将数据从一种形式移动到另一种形式的机制。这些系统在其 API 中存在显着差异：C-Store 的行为类似于关系数据库，而 Bigtable 提供较低级别的读写接口，旨在支持每台服务器每秒数千次此类操作。C-Store 也是一个“读取优化的关系 DBMS”，而 Bigtable 在读取密集型和写入密集型应用程序上都提供了良好的性能。</p><p>Bigtable 的负载均衡器必须解决一些与无共享数据库相同的负载和内存平衡问题（例如，[11， 35]）。我们的问题稍微简单一些：（1）我们没有考虑同一数据的多个副本的可能性，由于视图或索引，可能以不同的形式出现;（2）我们让用户告诉我们哪些数据属于内存，哪些数据应该保留在磁盘上，而不是试图动态地确定这一点;（3）我们没有复杂的查询来执行或优化。</p><h2 id="9-总结"><a class="markdownIt-Anchor" href="#9-总结"></a> 9 总结</h2><p>我们已经描述了 Bigtable，这是一个用于在 Google 存储结构化数据的分布式系统。Bigtable 集群自 2005 年 4 月以来一直在生产中使用，在此之前，我们花了大约 7 个人年的时间进行设计和实施。截至 2006 年 8 月，已有 60 多个项目在使用 Bigtable。我们的用户喜欢 Bigtable 组件提供的性能和高可用性，并且随着资源需求的变化，他们只需向系统添加更多计算机即可扩展集群的容量。</p><p>鉴于 Bigtable 的不寻常界面，一个有趣的问题是我们的用户适应使用它的难度有多大。新用户有时不确定如何最好地使用 Bigtable 界面，特别是如果他们习惯于使用支持通用事务的关系数据库。尽管如此，许多 Google 产品成功使用 Bigtable 的事实表明，我们的设计在实践中运行良好。</p><p>我们正在实现一些附加的 Bigtable 功能，例如支持二级索引和基础设施，用于构建具有多个主副本的跨数据中心复制的 Bigtable。我们还开始将 Bigtable 作为服务部署到 产品组，这样各个组就不需要维护自己的集群。随着服务集群的扩展，我们将需要在 Bigtable 内部处理更多的资源共享问题 [3， 5]。</p><p>最后，我们发现在 Google 构建我们自己的存储解决方案具有重要的优势。我们从为 Bigtable 设计自己的数据模型中获得了大量的灵活性。此外，我们对 Bigtable 的实施以及 Bigtable 所依赖的其他 Google 基础设施的控制意味着我们可以在出现瓶颈和缺陷时消除它们。</p><h2 id="引用"><a class="markdownIt-Anchor" href="#引用"></a> 引用</h2><p>[1] ABADI, D. J., MADDEN, S. R., AND FERREIRA,</p><p>M. C. Integrating compression and execution in column-</p><p>oriented database systems. Proc. of SIGMOD (2006).</p><p>[2] AILAMAKI, A., DEWITT, D. J., HILL, M. D., AND SK-</p><p>OUNAKIS, M. Weaving relations for cache performance.</p><p>In The VLDB Journal (2001), pp. 169ñ180.</p><p>[3] BANGA, G., DRUSCHEL, P., AND MOGUL, J. C. Re-</p><p>source containers: A new facility for resource manage-</p><p>ment in server systems. In Proc. of the 3rd OSDI (Feb.</p><p>1999), pp. 45ñ58.</p><p>[4] BARU, C. K., FECTEAU, G., GOYAL, A., HSIAO,</p><p>H., JHINGRAN, A., PADMANABHAN, S., COPELAND,</p><p>G. P., AND WILSON, W. G. DB2 parallel edition. IBM</p><p>Systems Journal 34, 2 (1995), 292ñ322.</p><p>[5] BAVIER, A., BOWMAN, M., CHUN, B., CULLER, D.,</p><p>KARLIN, S., PETERSON, L., ROSCOE, T., SPALINK, T.,</p><p>AND WAWRZONIAK, M. Operating system support for</p><p>planetary-scalenetworkservices. InProc.of the1stNSDI</p><p>(Mar. 2004), pp. 253ñ266.</p><p>[6] BENTLEY, J. L., AND MCILROY, M. D. Data compres-</p><p>sion using long common strings. In Data Compression</p><p>Conference (1999), pp. 287ñ295.</p><p>[7] BLOOM, B. H. Space/timetrade-offs inhashcodingwith</p><p>allowable errors. CACM 13, 7 (1970), 422ñ426.</p><p>[8] BURROWS, M. The Chubby lock service for loosely-</p><p>coupled distributed systems. In Proc. of the 7th OSDI</p><p>(Nov. 2006).</p><p>[9] CHANDRA, T., GRIESEMER, R., AND REDSTONE, J.</p><p>Paxos made live ó An engineering perspective. In Proc.</p><p>of PODC (2007).</p><p>[10] COMER, D. Ubiquitous B-tree. Computing Surveys 11, 2</p><p>(June 1979), 121ñ137.</p><p>[11] COPELAND, G. P., ALEXANDER, W., BOUGHTER,</p><p>E. E., AND KELLER, T. W. Dataplacement in Bubba. In</p><p>Proc. of SIGMOD (1988), pp. 99ñ108.</p><p>[12] DEAN, J., AND GHEMAWAT, S. MapReduce: Simplied</p><p>dataprocessingonlargeclusters. InProc.of the6thOSDI</p><p>(Dec. 2004), pp. 137ñ150.</p><p>[13] DEWITT, D., KATZ, R., OLKEN, F., SHAPIRO, L.,</p><p>STONEBRAKER, M., AND WOOD, D. Implementation</p><p>techniques for main memory database systems. In Proc.</p><p>of SIGMOD (June 1984), pp. 1ñ8.</p><p>[14] DEWITT, D. J., AND GRAY, J. Parallel database sys-</p><p>tems: The future of high performance database systems.</p><p>CACM 35, 6 (June 1992), 85ñ98.</p><p>[15] FRENCH, C. D. One size ts all database architectures</p><p>do not work for DSS. In Proc. of SIGMOD (May 1995),</p><p>pp. 449ñ450.</p><p>[16] GAWLICK, D., AND KINKADE, D. Varieties of concur-</p><p>rency controlin IMS/VSfastpath. Database Engineering</p><p>Bulletin 8, 2 (1985), 3ñ10.</p><p>[17] GHEMAWAT, S., GOBIOFF, H., AND LEUNG, S.-T. The</p><p>Googlelesystem. InProc.of the19thACMSOSP(Dec.</p><p>2003), pp. 29ñ43.</p><p>[18] GRAY, J. Notes on database operating systems. In Oper-</p><p>ating Systems ó An Advanced Course, vol. 60 of Lecture</p><p>Notes in Computer Science. Springer-Verlag, 1978.</p><p>[19] GREER, R. Daytona and the fourth-generation language</p><p>Cymbal. In Proc. of SIGMOD (1999), pp. 525ñ526.</p><p>[20] HAGMANN, R. Reimplementing the Cedar le system</p><p>using logging and group commit. In Proc. of the 11th</p><p>SOSP (Dec. 1987), pp. 155ñ162.</p><p>[21] HARTMAN, J. H., AND OUSTERHOUT, J. K. The Zebra</p><p>striped network le system. In Proc. of the 14th SOSP</p><p>(Asheville, NC, 1993), pp. 29ñ43.</p><p>[22] <a href="http://KX.COM">KX.COM</a>. <a href="http://kx.com/products/database.php">kx.com/products/database.php</a>. Product page.</p><p>[23] LAMPORT, L. The part-time parliament. ACM TOCS 16,</p><p>2 (1998), 133ñ169.</p><p>[24] MACCORMICK, J., MURPHY, N., NAJORK, M.,</p><p>THEKKATH, C. A., AND ZHOU, L. Boxwood: Abstrac-</p><p>tionsasthefoundation forstorage infrastructure. InProc.</p><p>of the 6th OSDI (Dec. 2004), pp. 105ñ120.</p><p>[25] MCCARTHY, J. Recursive functions of symbolic expres-</p><p>sionsandtheircomputationbymachine. CACM3, 4 (Apr.</p><p>1960), 184ñ195.</p><p>[26] O’NEIL, P., CHENG, E., GAWLICK, D., AND O’NEIL,</p><p>E. The log-structured merge-tree (LSM-tree). Acta Inf.</p><p>33, 4 (1996), 351ñ385.</p><p>[27] <a href="http://ORACLE.COM">ORACLE.COM</a>. <a href="http://www.oracle.com/technology/products/-">www.oracle.com/technology/products/-</a></p><p>database/clustering/index.html. Product page.</p><p>[28] PIKE, R., DORWARD, S., GRIESEMER, R., AND QUIN-</p><p>LAN, S. Interpreting the data: Parallel analysis with</p><p>Sawzall. Scientic Programming Journal 13, 4 (2005),</p><p>227ñ298.</p><p>[29] RATNASAMY, S., FRANCIS, P., HANDLEY, M., KARP,</p><p>R., AND SHENKER, S. A scalable content-addressable</p><p>network. In Proc. of SIGCOMM (Aug. 2001), pp. 161ñ</p><ol start="172"><li></li></ol><p>[30] ROWSTRON, A., AND DRUSCHEL, P. Pastry: Scal-</p><p>able, distributed object location and routing for large-</p><p>scale peer-to-peer systems. In Proc. of Middleware 2001</p><p>(Nov. 2001), pp. 329ñ350.</p><p>[31] <a href="http://SENSAGE.COM">SENSAGE.COM</a>. <a href="http://sensage.com/products-sensage.htm">sensage.com/products-sensage.htm</a>.</p><p>Product page.</p><p>[32] STOICA, I., MORRIS, R., KARGER, D., KAASHOEK,</p><p>M. F., AND BALAKRISHNAN, H. Chord: A scalable</p><p>peer-to-peer lookup service for Internet applications. In</p><p>Proc. of SIGCOMM (Aug. 2001), pp. 149ñ160.</p><p>[33] STONEBRAKER, M. The case for shared nothing.</p><p>Database Engineering Bulletin 9, 1 (Mar. 1986), 4ñ9.</p><p>[34] STONEBRAKER, M., ABADI, D. J., BATKIN, A., CHEN,</p><p>X., CHERNIACK, M., FERREIRA, M., LAU, E., LIN,</p><p>A., MADDEN, S., O’NEIL, E., O’NEIL, P., RASIN,</p><p>A., TRAN, N., AND ZDONIK, S. C-Store: A column-</p><p>oriented DBMS. InProc.ofVLDB(Aug.2005), pp. 553ñ</p><ol start="564"><li></li></ol><p>[35] STONEBRAKER, M., AOKI, P. M., DEVINE, R.,</p><p>LITWIN, W., AND OLSON, M. A. Mariposa: A new ar-</p><p>chitecturefordistributeddata. InProc.oftheTenthICDE</p><p>(1994), IEEEComputer Society, pp. 54ñ65.</p><p>[36] <a href="http://SYBASE.COM">SYBASE.COM</a>. <a href="http://www.sybase.com/products/database-">www.sybase.com/products/database-</a></p><p>servers/sybaseiq. Product page.</p><p>[37] ZHAO, B. Y., KUBIATOWICZ, J., AND JOSEPH, A. D.</p><p>Tapestry: An infrastructure for fault-tolerant wide-area</p><p>location and routing. Tech. Rep. UCB/CSD-01-1141, CS</p><p>Division, UC Berkeley, Apr. 2001.</p><p>[38] ZUKOWSKI, M., BONCZ, P. A., NES, N., AND HEMAN,</p><p>S. MonetDB/X100 óA DBMSin the CPUcache. IEEE</p><p>Data Eng. Bull. 28, 2 (2005), 17ñ22.</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>mit6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZooKeeper</title>
    <link href="/2024/05/02/ZooKeeper/"/>
    <url>/2024/05/02/ZooKeeper/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="zookeeper互联网规模的无等待协调"><a class="markdownIt-Anchor" href="#zookeeper互联网规模的无等待协调"></a> ZooKeeper：互联网规模的无等待协调</h1><h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>在本文中，我们介绍ZooKeeper，一个用于协调分布式应用程序过程的服务。由于ZooKeeper时关键基础架构的一部分，它旨在为客户建立更复杂的协调基础提供一个简单而高性能的内核。它在复制的集中式服务中结合了小组消息传递，共享寄存器和分布式锁服务的元素。ZooKeeper暴露的接口具有共享寄存器的无等待方面，其事件驱动的机制类似于分布式文件系统的缓存无效，以提供简单但功能可行的协调服务。</p><p>ZooKeeper接口可以实现高性能服务。除了无等待属性外，ZooKeeper还为所有更改ZooKeeper状态的重新审查的请求执行和线性化提供了每个客户的保障。这些设计决定促进了高性能处理管道的实现，并在本地服务器满足读取请求。我们显示目标工作负载2：1至100：1读取比例，Zookeeper可以处理数十万到数十万每秒的交易。该性能使Zookeeper可以通过客户端应用程序进行广泛的使用。</p><h2 id="1介绍"><a class="markdownIt-Anchor" href="#1介绍"></a> 1.介绍</h2><p>大型分布式应用需要不同形式的协调。配置是协调的最基本形式之一。以最简单的形式，配置只是系统调用的操作参数列表，而更复杂的系统具有动态配置参数。小组成员和领导者选举在分布式系统中也很常见：通常，操作需要知道哪些其他操作还活着以及这些操作负责什么。锁构成了强大的协调原语，该原语可实施对关键资源的相互排斥访问。</p><p>协调的一种方法是为每个不同的协调需求开发服务。比如说Amazon Simple Queue Service专门针对队列，其他services是专门针对领导者选举和配置开发的。比如说Chubby是一个有强一致性保障的锁服务。然后可以使用锁来实施领导者选举，小组成员资格等。</p><p>在设计协调服务时，我们不再在服务器端实施特定的原始图，而是选择了使应用程序开发人员能够实现自己的基础的API。这样的选择导致了协调内核的实现，该内核可以使新的原始素无需更改服务核心。该AP搜索实现了适合应用程序要求的多种形式的协调，而不是将开发人员限制为一组固定的原语。在设计ZooKeeper的API时，我们避开了阻塞原语（例如锁）。除其他问题外，锁协调服务的原语可能会导致客户速度缓慢或有缺陷的客户，从而对更快的客户的表现产生负面影响。如果处理请求取决于响应和其他客户的失败检测，那么服务本身的实现将变得更加复杂。因此，我们的系统（Zookeeper）实现了一种API，该API像文件系统中一样，在层次上组织简单的无等待数据对象。实际上，Zookeeper API类似于其他任何文件系统之一，并且仅查看API签名，Zookeeper似乎像Chubby一样没有锁、open和close。但是，实现无需候补数据对象，基于阻止原语锁（例如锁），将ZooKeeper与系统显著区分。虽然无等待属性对性能和容错很重要，但它不足以协调。我们还必须为操作提供顺序保证。特别是，我们发现，保证所有操作的FIFO客户端顺序和线性写入能够有效地实施该服务，并且足以为我们的应用程序的实施关注的协调基础。实际上，我们可以使用我们的API对任何数量的流程实现共识，并且根据Herlihy的层次结构，Zoo-Keeper实现了一个通用对象。Zookeeper服务包括一系列服务器，这些服务器使用复制来实现高可用性和性能。它的高性能使应用程序可以使用大量操作来使用此类协调内核来管理协调的所有方面。我们能够实施一个简单的管道架构，使我们能够有数百或数千个请求，同时仍达到低延迟。这样的管道自然可以以FIFO顺序从单个客户端执行操作。保证FIFO客户顺序使客户能够异步提交操作。通过异步操作，客户可以一次进行多个不错的操作。当新客户成为领导者时，此功能是可取的，因此必须操纵元数据并相应地对其进行更新。如果没有多次出色操作的可能性，初始化的时间可以是秒的顺序，而不是次秒。</p><p>为了确保该更新操作满足线性性能，我们实施了一个基于领导者的原子广播协议，称为ZAB。但是，Zookeeper应用程序的典型工作负载主要由读取操作主导，并且希望扩展读取吞吐量。在Zookeeper中，服务器过程在本地读取操作，我们不会使用ZAB来完全排序它们。</p><p>客户端的缓存数据是提高读取性能的重要技术。例如，对于一个过程来缓存当前领导者的标识符，而不是每次需要了解领导者时探测Zookeeper，这很有用。Zookeeper使用watch机制来使客户能够直接加速客户端缓存数据。有了这种机制，客户端可以关注给定数据对象的更新，并在更新时接收通知。Chubby直接管理客户端缓存。它会阻止更新，以内部估算所有客户端的缓存数据的缓存。在此设计下，如果这些客户端中的任何一个是缓慢或错误的，则更新会延迟。Chubby使用租赁来防止有缺陷的客户无限地阻塞系统。但是，租赁只会限制慢速或错误客户的影响，而ZooKeeper的watch机制完全避免了问题。</p><p>在本文中，我们讨论了我们对ZooKeeper的设计和实施。使用Zookeeper，即使只能写入可以线性化，我们也能够完成我们应用所需的所有协调基础。为了验证我们的方法，我们展示了如何与Zookeeper实施一些协调基础。</p><p>总而言之，在本文中，我们的主要贡献是：</p><p><code>协调内核</code>：我们提出了一项无等待的协调，并具有轻松的一致性保证，可用于分布式系统。我们特别描述了协调内核的设计和实现，我们已在许多关键应用程序中使用该内核来实现各种协调技术。</p><p><code>协调方案</code>：我们展示了如何使用 ZooKeeper 构建更高级别的协调原语，甚至是分布式应用程序中经常使用的阻塞和强一致原语。</p><p><code>协调经验</code>：我们分享一些使用 ZooKeeper 并评估其性能的方法。</p><h2 id="2zookeeper服务"><a class="markdownIt-Anchor" href="#2zookeeper服务"></a> 2.ZooKeeper服务</h2><p>客户端使用 ZooKeeper 客户端库通过客户端 API 向 ZooKeeper 提交请求。除了通过客户端API公开ZooKeeper服务接口之外，客户端库还管理客户端和ZooKeeper服务器之间的网络连接。在本节中，我们首先提供 ZooKeeper 服务的高级视图。然后我们讨论客户端用来与ZooKeeper交互的API。</p><p><code>术语</code>：本文中，我们用client表示ZooKeeper服务的用户，server表示提供ZooKeeper服务的进程，znode 表示 ZooKeeper 数据中的内存数据节点，它组织在称为数据树的分层命名空间中。</p><h3 id="21-服务概览"><a class="markdownIt-Anchor" href="#21-服务概览"></a> 2.1 服务概览</h3><p>ZooKeeper 向其客户端提供一组数据节点（znode）的抽象，这些数据节点根据分层名称空间进行组织。此层次结构中的 znode 是客户端通过 ZooKeeper API 操作的数据对象。层次命名空间通常用在文件系统中。这是组织数据对象的理想方式，因为用户已经习惯了这种抽象，并且它可以更好地组织应用程序元数据。为了指向一个给定的znode，我们对文件系统路径使用标准 UNIX 表示法。例如，我们使用 /A/B/C 来表示 znode C 的路径，其中 C 以 B 作为其父节点，B 以 A 作为其父节点。所有 znode 都存储数据，并且除临时 znode 之外的所有 znode 都可以有子节点。</p><p><img src="../imgs/ZooKeeper/image-20240502031217505.png" alt="图 1：ZooKeeper 分层名称空间的图示。" /></p><p>客户端可以创建两种类型的znode：</p><p><code>常规</code>：客户端通过显式创建和删除常规znode来操作它们；</p><p><code>短期</code>：客户端创建此类znode，并且它们要么显式删除它们，要么让系统在创建它们的会话终止时（故意或由于失败）自动删除它们。</p><p>此外，当创建新的 znode 时，客户端可以设置顺序标志。使用顺序标志集创建的节点具有附加到其名称的单调递增计数器的值。如果 n 是新 znode，p 是父 znode，则 n 的序列值永远不会小于 p 下创建的任何其他顺序 znode 的名称中的值。ZooKeeper 实现了Watch，允许客户端及时接收更改通知，而无需轮询。当客户端发出设置了watch标志的读取操作时，操作会正常完成，只是服务器承诺在返回的信息发生更改时通知客户端。监视是与会话关联的一次性触发器；一旦触发或会话关闭，它们就会被注销。Watch指示已发生更改，但不提供更改。例如，如果客户端在“/foo”更改两次之前发出 getData(‘‘/foo’’, true)，则客户端将收到一个监视事件，告诉客户端“/foo”的数据已更改。会话事件（例如连接丢失事件）也会发送到监视回调，以便客户端知道监视事件可能会延迟。</p><p><strong>数据模型</strong></p><p>ZooKeeper的数据模型本质上是一个具有简化API且仅进行完整数据读写的文件系统，或者是具有分层键的键/值表。分层命名空间对于为不同应用程序的命名空间分配子树以及设置对这些子树的访问权限非常有用。我们还利用客户端的目录概念来构建更高级别的原语，正如我们将在 2.4 节中看到的那样。</p><p>与文件系统中的文件不同，znode 并不是为一般数据存储而设计的。相反，znode 映射到客户端应用程序的抽象，通常对应于用于协调目的的元数据。为了说明这一点，在图 1 中，我们有两个子树，一个用于应用程序 1 (/app1)，另一个用于应用程序 2 (/app2)。应用程序 1 的子树实现了一个简单的组成员身份协议：每个客户端进程 pi 在 /app1 下创建一个 znode pi，只要进程正在运行，该节点就会持续存在。</p><p>尽管 znode 不是为一般数据存储而设计的，但 ZooKeeper 确实允许客户端存储一些可用于分布式计算中的元数据或配置的信息。例如，在基于领导者的应用程序中，对于刚刚开始了解哪个其他服务器当前是领导者的应用程序服务器非常有用。为了实现这个目标，我们可以让当前领导者将此信息写入 znode 空间中的已知位置。Znode 还具有与时间戳和版本计数器关联的元数据，这允许客户端跟踪 znode 的更改并根据 znode 的版本执行条件更新。</p><p><strong>会话</strong></p><p>客户端连接到 ZooKeeper 并启动会话。会话有对应的超时。如果客户端在超过该超时时间内没有从会话中收到任何内容，Zoo-Keeper 就会认为客户端有故障。当客户端显式关闭会话句柄或 ZooKeeper 检测到客户端出现故障时，会话结束。在会话中，客户端观察到一系列反映其操作执行情况的状态更改。会话使客户端能够在 ZooKeeper 整体中透明地从一台服务器移动到另一台服务器，从而在 ZooKeeper 服务器之间持续存在。</p><h3 id="22-客户端api"><a class="markdownIt-Anchor" href="#22-客户端api"></a> 2.2 客户端API</h3><p>我们在下面介绍了 ZooKeeper API 的相关子集，并讨论了每个请求的语义。</p><p><code>create(path, data, flags)</code>：创建一个路径名为path的znode，在其中存储data[]，并返回新znode的名称。 flags 使客户端能够选择 znode 的类型：常规、临时，并设置顺序标志；</p><p><code>delete(path, version)</code>：如果 znode 处于预期的版本，则删除该 znode 路径；</p><p><code>exists(path, watch)</code>:如果路径名为path的znode存在则返回true，否则返回false。watch标识符使用户在该znode上建立一个watch</p><p><code>getData(path, watch)</code>：返回与 znode 关联的数据和元数据，例如版本信息。 watch 标志的工作方式与 Exists() 相同，只是如果 znode 不存在，Zoo-Keeper 不会设置 watch；</p><p><code>setData(path, data, version)</code>：如果版本号是znode的当前版本，则将data[]写入znode路径；</p><p><code>getChildren(path, watch)</code>：返回 znode 的子节点的名称集合；</p><p><code>sync(path)</code>：等待操作开始时挂起的所有更新传播到客户端连接到的服务器。该路径当前被忽略。</p><p>所有方法都有通过 API 提供的同步和异步版本。当应用程序需要执行单个 ZooKeeper 操作并且没有要执行的并发任务时，应用程序会使用同步 API，因此它会进行必要的 ZooKeeper 调用并阻塞。然而，异步 API 使应用程序能够同时执行多个未完成的 ZooKeeper 操作和其他任务。ZooKeeper 客户端保证每个操作的相应回调按顺序调用。</p><p>请注意，ZooKeeper 不使用句柄来访问 znode。每个请求都包含正在操作的 znode 的完整路径。这种选择不仅简化了 API（没有 open() 或 close() 方法），而且还消除了服务器需要维护的额外状态。</p><p>每个更新方法都采用预期的版本号，这使得可以实现条件更新。如果 znode 的实际版本号与预期版本号不匹配，则更新将失败并出现意外版本错误。如果版本号为-1，则不进行版本检查。</p><h3 id="23-zookeeper-保证"><a class="markdownIt-Anchor" href="#23-zookeeper-保证"></a> 2.3 ZooKeeper 保证</h3><p>ZooKeeper 有两个基本的顺序保证：</p><ol><li>线性化写入：所有更新 ZooKeeper 状态的请求都是可序列化的并尊重优先级；</li><li>FIFO 客户端顺序：来自给定客户端的所有请求都按照客户端发送的顺序执行。</li></ol><p>请注意，我们对线性化的定义与 Herlihy 最初提出的定义不同，我们将其称为 A-线性化（异步线性化）。在 Herlihy 对线性化的最初定义中，客户端一次只能有一个未完成的操作（一个客户端是一个线程）。在我们的系统中，我们允许一个客户端有多个未完成的操作，因此我们可以选择对同一客户端的未完成操作不保证特定的顺序，或者保证先进先出的顺序。我们为我们的属性选择后者。重要的是要观察到，适用于可线性化对象的所有结果也适用于可线性化对象，因为满足A-线性化的系统也满足可线性化的系统。由于只有更新请求是 A 线性化的，ZooKeeper 在每个副本上本地处理读取请求。这使得服务可以随着服务器添加到系统而线性扩展。</p><p>要了解这两个保证如何相互作用，请考虑以下场景。包含多个进程的系统会选举一个领导者来指挥工作进程。当新的领导者接管系统时，它必须更改大量配置参数，并在完成后通知其他进程。那么我们有两个重要的要求：</p><ul><li>当新的领导者开始进行更改时，我们不希望其他进程开始使用正在更改的配置；</li><li>如果新的领导者在配置完全更新之前死亡，我们不希望进程使用这部分配置。</li></ul><p>请注意，分布式锁（例如 Chubby 提供的锁）有助于满足第一个要求，但不足以满足第二个要求。通过ZooKeeper，新领导者可以指定一条路径作为就绪znode；其他进程只会在该 znode 存在时使用该配置。新领导者通过删除ready、更新各种配置znodes以及创建ready来进行配置更改。所有这些更改都可以通过管道传输并异步发出，以快速更新配置状态。尽管变更操作的延迟约为 2 毫秒，但如果请求是另一个接一个地发出的请求，则必须更新5000个不同Znodes的新领导者将需要10秒；通过异步发出请求，请求将不到一秒钟。由于顺序保证，如果一个进程看到就绪的 znode，它还必须看到新领导者所做的所有配置更改。如果新的领导者在创建就绪的 znode 之前死亡，则其他进程知道配置尚未最终确定并且不会使用它。上述方案仍然存在一个问题：如果一个进程在新的领导者开始进行更改之前发现就绪存在，然后在更改正在进行时开始读取配置，会发生什么情况。这个问题可以通过通知的顺序保证来解决：如果客户端正在监视更改，则客户端将在更改发生后看到系统的新状态之前看到通知事件。因此，如果读取就绪 znode 的进程请求获得该 znode 更改的通知，在它可以读取任何新配置之前它会看到通知告诉它客户端的更改。</p><p>当客户端除了 ZooKeeper 之外还有自己的通信通道时，可能会出现另一个问题。例如，考虑两个客户端 A 和 B 在 ZooKeeper 中具有共享配置并通过共享通信通道进行通信。如果 A 更改了 ZooKeeper 中的共享配置并通过共享通信通道告知 B 更改，B 会期望在重新读取配置时看到更改。如果 B 的 ZooKeeper 副本稍微落后于 A，则它可能看不到新配置。使用上述保证 B 可以通过在重新读取配置之前发出写入来确保它看到最新的信息。为了更有效地处理这种情况，Zoo-Keeper 提供了同步请求：当随后进行读取时，构成慢速读取。同步会导致服务器在处理读取之前应用所有挂起的写入请求，而不会产生完整写入的开销。该原语在思想上与ISIS的flush原语类似。</p><p>ZooKeeper还具有以下两个活性和持久性保证：</p><ul><li>如果大多数 ZooKeeper 服务器处于活动状态并且通信服务可用；</li><li>如果 ZooKeeper 服务成功响应更改请求，则只要特度不够数量的服务器最终能够恢复，该更改就会在任意数量的故障中持续存在。</li></ul><h3 id="24-原语示例"><a class="markdownIt-Anchor" href="#24-原语示例"></a> 2.4 原语示例</h3><p>在本节中，我们将展示如何使用ZooKeeper API来实现更强大的原语。ZooKeeper服务对这些更强大的原语一无所知，因为它们完全是使用ZooKeeper客户端API在客户端实现的。一些常见的原语（例如组成员身份和配置管理）也是无需等待的。对于其他事件，例如集合点，客户端需要等待事件。即使 ZooKeeper 是无等待的，我们也可以使用 ZooKeeper 实现高效的阻塞原语。ZooKeeper 的排序保证允许对系统状态进行有效的推理，而监视则允许有效的等待。</p><p><code>配置管理</code>：ZooKeeper可用于在分布式应用程序中实现动态配置。配置以最简单的形式存储在 znode z<sub>c</sub> 中。进程以z<sub>c</sub>的完整路径名启动。启动进程通过读取 z<sub>c</sub> 来获取其配置，并将监视标志设置为 true。如果 z<sub>c</sub> 中的配置被更新，进程会收到通知并读取新配置，再次将监视标志设置为 true。请注意，在此方案中，与大多数使用监视的其他方案一样，监视用于确保进程拥有最新信息。例如，如果监视 z<sub>c</sub> 的进程收到 z<sub>c</sub> 更改的通知，并且在它可以发出对 z<sub>c</sub> 的读取之前，z<sub>c</sub> 又发生了三个更改，则该进程不会再收到三个通知事件。这不会影响进程的行为，因为这三个事件只是通知进程它已经知道的事情：它拥有的 z<sub>c</sub> 信息已过时。</p><p><code>汇合</code>：有时，在分布式系统中，并不总是先验地清楚最终的系统配置会是什么样子。例如，客户端可能想要启动一个主进程和几个工作进程，但是启动进程是由调度程序完成的，因此客户端无法提前知道可以为工作进程提供连接到主进程的地址和端口等信息。我们通过 ZooKeeper 使用集合点 znode z<sub>r</sub> 来处理这种情况，z<sub>r</sub> 是客户端创建的节点。客户端将 z<sub>r</sub> 的完整路径名作为主进程和工作进程的启动参数传递。当主机启动时，它会在 z<sub>r</sub> 中填充有关其正在使用的地址和端口的信息。当worker启动时，他们会读取 z<sub>r</sub> 并将 watch 设置为 true。如果 z<sub>r</sub> 尚未填写，worker 等待 z<sub>r</sub> 更新时收到通知。如果 z<sub>r</sub> 是临时节点，则主进程和工作进程可以监视 z<sub>r</sub> 是否被删除，并在客户端结束时自行清理。</p><p><code>组成员</code>：我们利用临时节点来实现组成员资格。具体来说，我们利用临时节点允许我们查看创建节点的会话状态的事实。我们首先指定一个 znode，z<sub>g</sub> 来代表该组。当组中的进程成员启动时，它会在 z<sub>g</sub> 下创建一个临时子 znode。如果每个进程都有唯一的名称或标识符，则该名称用作子 znode 的名称；否则，进程将创建带有 SEQUENTIAL 标志的 znode 以获得唯一的名称分配。例如，进程可以将进程信息放入子znode的数据、进程使用的地址和端口中。</p><p>在 z<sub>g</sub> 下创建子 znode 后，进程正常启动。它不需要做任何其他事情。如果进程失败或者结束，z<sub>g</sub>下代表它的znode会被自动移除。</p><p>进程可以通过简单地列出 z<sub>g</sub> 的子进程来获取组信息。如果进程想要监视组成员身份的更改，则该进程可以将监视标志设置为 true，并在收到更改通知时刷新组信息（始终将监视标志设置为 true）。</p><p><code>简单的锁</code>：虽然ZooKeeper不是一个锁服务，但它可以用来实现锁。使用 ZooKeeper 的应用程序通常使用根据其需求定制的同步原语，例如上面所示的那些。在这里，我们展示了如何使用 ZooKeeper 实现锁，以表明它可以实现各种通用同步原语。</p><p>最简单的锁实现使用“锁文件”。锁由 znode 表示。为了获取锁，客户端尝试使用 EPHEMERAL 标志创建指定的 znode。如果创建成功，则客户端持有锁。否则，客户端可以读取设置了监视标志的 znode，以便在当前领导者死亡时收到通知。客户端在死亡或显式删除 znode 时释放锁。其他正在等待锁的客户端一旦观察到 znode 被删除，就会再次尝试获取锁。</p><p>虽然这个简单的锁定协议有效，但它确实存在一些问题。首先，它受到羊群效应的影响。如果有很多客户端等待获取锁，那么当锁释放时，即使只有一个客户端可以获得锁，它们也会争夺锁。其次，它只实现独占锁定。以下两个原语展示了如何克服这两个问题。</p><p><code>无羊群效应的简单锁</code>：我们定义一个锁znode l来实现这样的锁。直观上，我们将所有请求锁的客户端排列起来，每个客户端按照请求到达的顺序获得锁。因此，希望获得锁的客户端执行以下操作：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs awk">Lock <br><span class="hljs-number">1</span> n = create(l + “/lock-”, EPHEMERAL|SEQUENTIAL) <br><span class="hljs-number">2</span> C = getChildren(l, false) <br><span class="hljs-number">3</span> <span class="hljs-keyword">if</span> n is lowest znode <span class="hljs-keyword">in</span> C, <span class="hljs-keyword">exit</span> <br><span class="hljs-number">4</span> p = znode <span class="hljs-keyword">in</span> C ordered just before n <br><span class="hljs-number">5</span> <span class="hljs-keyword">if</span> exists(p, true) wait <span class="hljs-keyword">for</span> watch event <br><span class="hljs-number">6</span> goto <span class="hljs-number">2</span> <br>Unlock <br><span class="hljs-number">1</span> <span class="hljs-keyword">delete</span>(n) <br></code></pre></td></tr></table></figure><p>Lock 第 1 行中 SEQUENTIAL 标志的使用命令客户端获取锁的尝试相对于所有其他尝试。如果客户端的 znode 在第 3 行具有最低序列号，则客户端持有锁。否则，客户端将等待删除拥有锁或将在该客户端的 znode 之前接收锁的 znode。通过仅观察客户端 znode 之前的 znode，我们可以在释放锁或放弃锁请求时仅唤醒一个进程，从而避免羊群效应。一旦客户端正在监视的 znode 消失，客户端必须检查它现在是否持有锁。（之前的锁请求可能已经被放弃，并且有一个序列号较低的znode仍在等待或持有锁。）</p><p>释放锁就像删除代表锁请求的 znode n 一样简单。通过在创建时使用 EPHEMERAL 标志，崩溃的进程将自动清除任何锁定请求或释放它们可能拥有的任何锁定。综上所述，这种锁定方案有以下优点：</p><ol><li>删除一个 znode 只会导致一个客户端醒来，因为每个 znode 都被另一个客户端监视，所以我们没有羊群效应；</li><li>没有轮询或超时；</li><li>由于我们实现锁定的方式，我们可以通过浏览 ZooKeeper 数据来查看锁争用、中断锁定和调试锁定问题的数量。</li></ol><p><code>读/写锁</code>：为了实现读/写锁，我们稍微改变了锁定过程，并具有单独的读锁和写锁过程。解锁过程与全局锁定情况相同。</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Write</span> <span class="hljs-keyword">Lock</span> <br><span class="hljs-number">1</span> n = <span class="hljs-keyword">create</span>(l + “/<span class="hljs-keyword">write</span>-”, EPHEMERAL|SEQUENTIAL) <br><span class="hljs-number">2</span> C = getChildren(l, <span class="hljs-keyword">false</span>) <br><span class="hljs-number">3</span> <span class="hljs-keyword">if</span> n <span class="hljs-keyword">is</span> lowest znode <span class="hljs-keyword">in</span> C, <span class="hljs-keyword">exit</span> <br><span class="hljs-number">4</span> p = znode <span class="hljs-keyword">in</span> C ordered just <span class="hljs-keyword">before</span> n <br><span class="hljs-number">5</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>(p, <span class="hljs-keyword">true</span>) wait <span class="hljs-keyword">for</span> event <br><span class="hljs-number">6</span> goto <span class="hljs-number">2</span> <br><span class="hljs-keyword">Read</span> <span class="hljs-keyword">Lock</span> <br><span class="hljs-number">1</span> n = <span class="hljs-keyword">create</span>(l + “/<span class="hljs-keyword">read</span>-”, EPHEMERAL|SEQUENTIAL) <br><span class="hljs-number">2</span> C = getChildren(l, <span class="hljs-keyword">false</span>) <br><span class="hljs-number">3</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">no</span> <span class="hljs-keyword">write</span> znodes lower than n <span class="hljs-keyword">in</span> C, <span class="hljs-keyword">exit</span> <br><span class="hljs-number">4</span> p = <span class="hljs-keyword">write</span> znode <span class="hljs-keyword">in</span> C ordered just <span class="hljs-keyword">before</span> n <br><span class="hljs-number">5</span> <span class="hljs-keyword">if</span> <span class="hljs-keyword">exists</span>(p, <span class="hljs-keyword">true</span>) wait <span class="hljs-keyword">for</span> event <br><span class="hljs-number">6</span> goto <span class="hljs-number">3</span> <br></code></pre></td></tr></table></figure><p>此锁定过程与之前的锁定略有不同。写锁仅在命名上有所不同。由于读锁可能是共享的，因此第 3 行和第 4 行略有不同，因为只有较早的写锁 znode 会阻止客户端获取读锁。当有多个客户端等待读锁并在删除序列号较低的“写”znode 时收到通知时，我们可能会出现“羊群效应”；事实上，这是一种期望的行为，所有这些读取客户端都应该被释放，因为它们现在可能拥有锁。</p><p><code>双重屏障</code>:双屏障使客户端能够同步计算的开始和结束。当由屏障阈值定义的足够多的进程加入屏障时，进程开始计算并在完成后离开屏障。我们用 znode 表示 ZooKeeper 中的屏障，称为 b。每个进程 p 在进入时向 b 注册（通过创建一个 znode 作为 b 的子节点），并在准备离开时取消注册（重新移动子节点）。当 b 的子 znode 数量超过屏障阈值时，进程可以进入屏障。当所有进程都删除了它们的子进程时，进程就可以离开屏障。我们使用watch有效等待满足的进入和退出条件。为了进入，进程会监视 b 是否存在就绪子级，该子级将由导致子级数量超过屏障阈值的进程创建。为了离开，进程会监视特定子节点的消失，并且仅在该 znode 被删除后才检查退出条件。</p><h2 id="3-zookeeper应用程序"><a class="markdownIt-Anchor" href="#3-zookeeper应用程序"></a> 3 ZooKeeper应用程序</h2><p>现在我们描述一些使用 ZooKeeper 的应用程序，并简要解释它们如何使用它。我们以<strong>粗体</strong>显示每个示例的原语。</p><p><strong>抓取服务</strong> 爬虫是搜索引擎的重要组成部分，而 Yahoo!抓取数十亿的Web文档。获取服务 (FS) 是Yahoo!爬虫的一部分，目前正在生产中。本质上，它具有命令页面获取进程的主进程。主设备为提取器提供配置，并且提取器回写通知其状态和健康状况。使用 ZooKeeper for FS 的主要优点是从主服务器故障中恢复、在发生故障时保证可用性以及将客户端与服务器解耦，允许他们通过从 ZooKeeper 读取状态来将请求定向到健康的服务器。因此，FS主要使用ZooKeeper来管理配置元数据，尽管它也使用ZooKeeper来选举master（领导者选举）。</p><p><img src="../imgs/ZooKeeper/image-20240502031314762.png" alt="" /></p><p>图 2 显示了 FS 使用的 ZooKeeper 服务器三天内的读写流量。为了生成这个图表，我们计算了该时间段内每一秒的操作次数，每个点对应于该秒内的操作次数。我们观察到读取流量比写入流量高得多。在速率高于每秒 1,000 次操作期间，读：写比率在 10:1 和 100:1 之间变化。此工作负载中的读取操作为 getData()、getChildren() 和 Exists()，按流行程度递增的顺序排列</p><p><strong><font size=3>Katta</font></strong> Katta是一个分布式索引器，使用 ZooKeeper 进行协调，它是非 Yahoo! 的一个示例应用。Katta 使用分片来划分索引工作。主服务器将分片分配给从服务器并跟踪进度。从站可能会发生故障，因此主节点必须在从节点来来去去时重新分配负载。主服务器也可能发生故障，因此其他服务器必须准备好在发生故障时接管。 Katta 使用 ZooKeeper 跟踪从服务器和主服务器的状态（组成员身份），并处理主服务器故障转移（领导者选举）。Katta 还使用 ZooKeeper 来跟踪分片分配并将其传播到从属设备（配置管理）。</p><p><strong><font size=3>Yahoo!消息代理</font></strong> Yahoo！消息代理（YMB）是一个分布式发布订阅系统。该系统管理着数千个主题，客户端可以向这些主题发布消息并从中接收消息。这些主题分布在一组服务器中以提供可扩展性。每个主题都使用主备方案进行复制，确保消息复制到两台机器，以确保可靠的消息传递。组成 YMB 的服务器使用无共享分布式架构，这使得协调对于正确操作至关重要。组成 YMB 的服务器使用无共享分布式架构，这使得协调对于正确操作至关重要。YMB使用ZooKeeper来管理主题的分布（配置元数据），处理系统中机器的故障（故障检测和组成员身份），并控制系统操作。</p><p><img src="../imgs/ZooKeeper/image-20240502031330397.png" alt="图 3：YMB在ZooKeeper中的消息代理结构" /></p><p>图 3 显示了 YMB 的 znode 数据布局的一部分。每个代理域都有一个称为节点的 znode，它为组成 YMB 服务的每个活动服务器都有一个临时 znode。每个 YMB 服务器在具有负载和状态信息的节点下创建一个临时 znode，通过 ZooKeeper 提供组成员身份和状态信息。禁止关闭和迁移等节点由组成服务的所有服务器进行监控，并允许 YMB 进行集中控制。主题目录对于 YMB 管理的每个主题都有一个子 znode。这些主题 znode 具有子 znode，它们指示每个主题的主服务器和备份服务器以及该主题的订阅者。主服务器和备份服务器 znode 不仅允许服务器发现负责某个主题的服务器，而且还管理领导者选举和服务器崩溃。</p><p><img src="../imgs/ZooKeeper/image-20240502031349211.png" alt="图4：ZooKeeper服务的组件" /></p><h2 id="4zookeeper实现"><a class="markdownIt-Anchor" href="#4zookeeper实现"></a> 4.ZooKeeper实现</h2><p>ZooKeeper 通过在组成服务的每台服务器上复制 ZooKeeper 数据来提供高可用性。我们假设服务器因崩溃而发生故障，并且此类故障服务器稍后可能会恢复。图 4 显示了 ZooKeeper 服务的高级组件。接收到请求后，服务器准备执行该请求（请求处理器）。如果这样的请求需要服务器之间的协调（写请求），那么它们使用一致协议（原子广播的实现），最后，服务器将更改提交到 ZooKeeper 数据库，并在整体的所有服务器上完全复制。在读取请求的情况下，服务器只需读取本地数据库的状态并生成对请求的响应。</p><p>复制数据库是包含整个数据树的内存数据库。树中的每个 znode 默认情况下最多存储 1MB 的数据，但这个最大值是一个配置参数，可以在特定情况下更改。为了可恢复性，我们将更新有效地记录到磁盘，并强制写入在磁盘介质上，然后再应用于内存数据库。事实上，正如Chubby一样，我们保留已提交操作的重播日志（在我们的例子中是预写日志），并生成内存数据库的定期快照。</p><p>每个 ZooKeeper 服务器都为客户端提供服务。客户端仅连接到一台服务器来提交其请求。正如我们之前提到的，读取请求由每个服务器数据库的本地副本提供服务。更改服务状态的请求（写入请求）由协议协议处理。作为协议的一部分，写请求被转发到称为领导者的单个服务器。剩下的ZooKeeper服务器，叫做跟随者，接收消息提案包括来自领导者的状态更改，并就状态更改达成一致。</p><h3 id="41-请求处理器"><a class="markdownIt-Anchor" href="#41-请求处理器"></a> 4.1 请求处理器</h3><p>由于消息传递层是原子的，因此我们保证本地副本永远不会分歧，尽管在任何时候某些服务器可能比其他服务器应用了更多的事务。与客户端发送的请求不同，事务是幂等的。当领导者收到写入请求时，它会计算应用写入时系统的状态，并将其转换为捕获此新状态的事务。必须计算未来状态，因为可能存在尚未应用到数据库的未完成事务。例如，如果客户端执行了条件 setData 并且请求中的版本号与正在更新的 znode 的未来版本号相匹配，该服务生成一个 setDataTXN，其中包含新数据、新版本号和更新的时间戳。如果发生错误，例如版本号不匹配或要更新的 znode 不存在，则会生成 errorTXN。</p><h3 id="42-原子广播"><a class="markdownIt-Anchor" href="#42-原子广播"></a> 4.2 原子广播</h3><p>所有更新 ZooKeeper 状态的请求都会转发给领导者。 Leader 执行请求并通过原子广播协议 Zab 将变化广播到 ZooKeeper 状态。接收到客户端请求的服务器在传递相应的状态变化时响应客户端。Zab 默认使用简单多数仲裁来决定提案，因此只有大多数服务器正确时，Zab 和 ZooKeeper 才能工作（即，使用 2f + 1 个服务器，我们可以容忍 f 个故障）。</p><p>为了实现高吞吐量，ZooKeeper 尝试保持请求处理管道已满。它可能在处理管道的不同部分有数千个请求。由于状态更改取决于先前状态更改的应用，因此 Zab 提供了比常规原子广播更强的顺序保证。更具体地说，Zab 保证领导者广播的更改按照发送的顺序进行传递，并且先前领导者的所有更改都会在已建立的领导者广播自己的更改之前传递给已建立的领导者。</p><p>有一些实现细节可以简化我们的实现并为我们提供出色的性能。我们使用 TCP 进行传输，因此消息顺序由网络维护，这使我们能够简化实现。我们使用 Zab 选择的领导者作为 ZooKeeper 领导者，以便创建事务的同一进程也会提议它们。我们使用日志来跟踪提案,作为内存数据库的预写日志，这样我们就不必将消息写入磁盘两次。</p><p>在正常操作期间，Zab 确实按顺序传递所有消息并且只传递一次，但由于 Zab 不会持久记录传递的每条消息的 id，因此 Zab 可能会在恢复期间重新传递消息。因为我们使用幂等事务，所以只要按顺序交付，多次交付是可以接受的。事实上，ZooKeeper 要求 Zab 至少重新传送上次快照开始后传送的所有消息。</p><h3 id="43-复制数据库"><a class="markdownIt-Anchor" href="#43-复制数据库"></a> 4.3 复制数据库</h3><p>每个副本在内存中都有一个 ZooKeeper 状态的副本。当 ZooKeeper 服务器从崩溃中恢复时，它需要恢复此内部状态。在运行服务器一段时间后，重放所有已传递的消息以恢复状态将花费非常长的时间，因此 ZooKeeper 使用定期快照，并且只需要自快照启动以来重新传递消息。我们将 ZooKeeper 快照称为模糊快照，因为我们不锁定 ZooKeeper 状态来拍摄快照；相反，我们对树进行深度优先扫描，自动读取每个 znode 的数据和元数据并将它们写入磁盘。由于生成的模糊快照可能应用了快照生成期间传递的状态更改的某些子集，因此结果可能与 ZooKeeper 在任何时间点的状态都不对应。但是，由于状态更改是幂等的，因此只要按顺序应用状态更改，我们就可以应用两次。</p><p>例如，假设在 ZooKeeper 数据树中，两个节点 /foo 和 /goo 的值分别为 f1 和 g1，并且在模糊快照开始时都位于版本 1，并且以下状态更改流的格式为 &lt;transactionType， path， value， new-version&gt;：</p><p>&lt;SetDataTXN, /foo, f2, 2&gt;</p><p>&lt;SetDataTXN, /goo, g2, 2&gt;</p><p>&lt;SetDataTXN, /foo, f3, 3&gt;</p><p>处理这些状态更改后，/foo 和 /goo 的值 f3 和 g2 分别为版本 3 和 2。然而，模糊快照可能记录了 /foo 和 /goo 的值 f3 和 g1 分别为版本 3 和 1，这不是 ZooKeeper 数据树的有效状态。如果服务器崩溃并使用此快照恢复，并且 Zab 重新传递状态更改，则结果状态对应于崩溃之前服务的状态。</p><h3 id="44-客户端-服务器交互"><a class="markdownIt-Anchor" href="#44-客户端-服务器交互"></a> 4.4 客户端-服务器交互</h3><p>当服务器处理写入请求时，它还会发送并清除与与该更新相对应的任何监视相关的通知。服务器按顺序处理写入，不会同时处理其他写入或读取。这确保了通知的严格连续性。请注意，服务器在本地处理通知。只有客户端连接的服务器才会跟踪并触发该客户端的通知。</p><p>读取请求在每台服务器上本地处理。每个读取请求都会被处理并使用 zxid 进行标记，该 zxid 对应于服务器看到的最后一个事务。该 zxid 定义读请求相对于写请求的部分顺序。通过在本地处理读取，我们获得了出色的读取性能，因为它只是本地服务器上的内存中操作，并且没有磁盘活动或协议协议可以运行。这种设计选择对于实现我们以读取为主的工作负载实现卓越性能的目标至关重要。</p><p>使用快速读取的一个缺点是不能保证读取操作的优先顺序。也就是说，即使已提交对同一 znode 的更新更新，读取操作也可能返回过时的值。并非所有应用程序都需要优先顺序，但对于确实需要优先顺序的应用程序，我们已经实现了同步。该原语异步执行，并在所有待处理写入其本地副本后由领导者排序。为了保证给定的读取操作返回最新更新的值，客户端在读取操作后调用同步。客户端操作的 FIFO 顺序保证与同步的全局保证一起使读取操作的结果能够反映发出同步之前发生的任何更改。在我们的实现中，我们不需要原子地广播同步，因为我们使用基于领导者的算法，我们只需将同步操作放在领导者和执行同步调用的服务器之间的请求队列的末尾。为了使其发挥作用，追随者必须确保领导者仍然是领导者。如果有待提交的事务，则服务器不会怀疑领导者。如果挂起队列为空，则领导者需要发出一个空事务来提交，并在该事务之后命令同步。这有一个很好的特性，即当领导者处于负载状态时，不会生成额外的广播流量。在我们的实现中，设置了超时，以便领导者在追随者放弃他们之前意识到自己不是领导者，因此我们不会发出空事务。</p><p>ZooKeeper 服务器按照 FIFO 顺序处理来自客户端的请求。响应包括响应相关的 zxid。即使在无活动间隔期间的心跳消息也包含客户端连接到的服务器看到的最后一个 zxid。如果客户端连接到新服务器，则该新服务器通过对照客户端的最后一个 zxid 来检查客户端的最后一个 zxid，以确保其 ZooKeeper 数据的视图至少与客户端的视图一样新。如果客户端的视图比服务器更新，则在服务器赶上之前，服务器不会重新建立与客户端的会话。保证客户端能够找到具有系统最新视图的另一台服务器，因为客户端只能看到已复制到大多数 ZooKeeper 服务器的更改。此行为对于保证持久性非常重要。</p><p>为了检测客户端会话失败，ZooKeeper 使用超时。如果在会话超时期间没有其他服务器从客户端接收到任何内容，则领导者确定已发生故障。如果客户端发送重新任务的频率足够高，则无需发送任何其他消息。否则，客户端将在低活动期间发送检测信号消息。如果客户端无法与服务器通信以发送请求或检测信号，它将连接到其他 ZooKeeper 服务器以重新建立其会话。为了防止会话计时，ZooKeeper 客户端库在会话空闲 s/3 毫秒后发送检测信号，如果会话在 2s/3 毫秒内没有收到来自服务器的消息，则切换到新服务器，其中 s 是会话超时（以毫秒为单位）。</p><h2 id="5-相关工作"><a class="markdownIt-Anchor" href="#5-相关工作"></a> 5 相关工作</h2><p>ZooKeeper 的目标是提供一种服务来缓解分布式应用程序中协调进程的问题。为了实现这一目标，它的设计借鉴了之前的协调服务、容错系统、分布式算法和文件系统的思想。</p><p>我们并不是第一个提出分布式应用程序协调系统的人。一些早期的系统提出了一种用于事务应用程序的分布式锁服务，以及用于在计算机集群中共享信息。最近，Chubby 提出了一个系统来管理分布式应用程序的咨询锁 。 Chubby 与 ZooKeeper 有着共同的几个目标。它还具有类似文件系统的接口，并使用一致协议来保证副本的一致性。但是，ZooKeeper 不是锁服务。客户端可以使用它来实现锁，但其API中没有锁操作。与 Chubby 不同，ZooKeeper 允许客户端连接到任何 ZooKeeper 服务器，而不仅仅是领导者。ZooKeeper 客户端可以使用其本地副本来提供数据并管理监视，因为它的一致性模型比 Chubby 轻松得多。这使得ZooKeeper能够提供比Chubby更高的性能，从而允许应用程序更广泛地使用ZooKeeper。</p><p>文献中已经提出了容错系统，其目标是缓解构建容错分布式应用程序的问题。ISIS 是一种早期系统。 ISIS系统将抽象类型规范转换为容错的分布式对象，从而使容错机制对用户透明。Horus 和 Ensemble 是从 ISIS 演变而来的系统。 ZooKeeper 采用 ISIS 虚拟同步的概念。最后，Totem 保证了利用局域网硬件广播的架构中消息传递的总顺序。ZooKeeper 适用于各种网络拓扑，这促使我们依赖服务器进程之间的 TCP 连接，而不是假设任何特殊的拓扑或硬件功能。我们也不会公开 ZooKeeper 内部使用的任何集成通信。</p><p>构建容错服务的一项重要技术是状态机复制，而 Paxos 是一种能够高效实现异步系统复制状态机的算法。我们使用的算法具有 Paxos 的一些特性，但它将共识所需的事务日志记录与数据树恢复所需的预写日志记录相结合，以实现高效的实现。已经提出了用于实际实现拜占庭容错复制状态机的协议。ZooKeeper 并不假设服务器可以是拜占庭式的，但我们确实采用校验和和健全性检查等机制来捕获非恶意的拜占庭式错误。克莱门特等人，讨论一种在不修改当前服务器代码库的情况下使 ZooKeeper 完全具有拜占庭容错能力的方法。迄今为止，我们还没有观察到使用完全拜占庭容错协议可以避免的生产错误。</p><p>Boxwood 是一个使用分布式锁服务器的系统。 Boxwood 为应用程序提供了更高级别的抽象，并且它依赖于基于 Paxos 的分布式锁服务。与 Boxwood 一样，ZooKeeper 是用于构建分布式系统的组件。但是，ZooKeeper 具有高性能要求，并且在客户端应用程序中使用得更广泛。ZooKeeper 公开了应用程序用于实现高级基元的较低级别基元。</p><p>ZooKeeper 类似于一个小型文件系统，但它只提供文件系统操作的一小部分，并添加了大多数文件系统中不存在的功能，例如排序保证和条件写入。然而，ZooKeeper watch在思想上与 AFS 的缓存回调相似。</p><p>Sinfonia 引入了迷你事务，这是构建可扩展分布式系统的新范例。 Sinfonia 被设计用来存储应用程序数据，而 ZooKeeper 则存储应用程序元数据。ZooKeeper 将其状态完全复制并保存在内存中，以实现高性能和一致的延迟。我们使用文件系统（如操作和排序）来实现类似于小型事务的功能。znode 是一个方便的抽象，我们在它上面添加了watch，这是 Sinfonia 中缺少的功能。Dynamo 允许客户端获取相对少量（小于 1M）的数据并将其放入分布式键值存储中。与 ZooKeeper 不同，Dynamo 中的密钥空间不是分层的。Dynamo 也不为写入提供强大的持久性和一致性保证，而是解决读取冲突。</p><p>DepSpace 使用元组空间来提供拜占庭容错服务。与 ZooKeeper 一样，DepSpace 使用简单的服务器接口在客户端实现强同步原语。虽然DepSpace的性能远低于ZooKeeper，但它提供了更强的容错性和机密性保证。</p><h2 id="6-总结"><a class="markdownIt-Anchor" href="#6-总结"></a> 6 总结</h2><p>ZooKeeper 通过向客户端公开无等待对象，采用无等待方法来解决分布式系统中的进程协调问题。我们发现 ZooKeeper 对于 Yahoo! 内部和外部的多个应用程序非常有用。ZooKeeper 通过使用watch的快速读取（这两个操作均由本地副本提供服务），为读取为主的工作负载实现了每秒数十万次操作的吞吐量值。尽管我们对读取和监视的一致性保证似乎很弱，但我们已经通过我们的用例表明，这种组合使我们能够在客户端实现高效和复杂的协调协议，即使读取不是优先顺序的，并且数据对象的实现是无等待的。事实证明，无等待属性对于高性能至关重要。</p><p>虽然我们只描述了几个应用程序，但还有许多其他应用程序使用 ZooKeeper。我们相信这样的成功是由于其简单的界面和可以通过这种界面实现的强大抽象。此外，由于 ZooKeeper 的高吞吐量，应用程序可以广泛使用它，而不仅仅是粗粒度锁定。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>mit6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft面试</title>
    <link href="/2024/03/24/raft%E9%9D%A2%E8%AF%95/"/>
    <url>/2024/03/24/raft%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="口撕raft"><a class="markdownIt-Anchor" href="#口撕raft"></a> 口撕Raft</h1><h2 id="1raft协议什么作用"><a class="markdownIt-Anchor" href="#1raft协议什么作用"></a> 1.Raft协议什么作用</h2><p>Raft是一种分布式一致性算法，主要用于管理分布式系统中的复制日志。其设计的主要目标是易于理解和实现，同时保证系统的一致性和可用性。</p><p>在分布式系统中，由于网络延迟、节点故障等问题，确保所有节点的状态保持一致是一个非常大的挑战。Raft协议就是为了解决这个问题而设计的。</p><ol><li>**领导者选举：**在Raft协议中，系统的所有操作都有领导者来进行。当系统启动或者当前的领导者失效时，Raft协议能够通过领导者选举过程来选举出一个新的领导者。</li><li>**日志复制：**领导者负责将系统的状态变更（即操作或者事务）以日志条目的形式复制到其它节点。Raft协议保证了所有的日志复制操作都是由领导者来协调的，这大大简化了复制过程。</li><li>**保证一致性：**Raft协议通过一系列的机制来保证系统的一致性。无论何时，只要大多数节点都可用，Raft协议都能保证系统的一致性。</li><li>**故障恢复：**当一个节点崩溃并重新启动后，Raft协议能够帮助这个节点恢复其状态，重新加入到系统中来。</li></ol><p>总的来说，Raft协议在分布式系统中起到了关键的作用，它使得构建高可用、一致性的分布式系统成为可能。</p><h2 id="2详细介绍raft流程"><a class="markdownIt-Anchor" href="#2详细介绍raft流程"></a> 2.详细介绍Raft流程</h2><ol><li>**启动：**当集群启动时，所有的节点都处于跟随者状态。这时，它们等待领导者发送心跳消息</li><li>**选举：**如果跟随者在一段时间内（称为选举超时时间）没有收到领导者的心跳消息，它们会认为领导者已经失效，并启动领导者选举。每个跟随者都会自增其任期号，切换到候选人状态，然后向所有其他节点发送请求投票的消息。</li><li>**投票：**当一个节点收到请求投票的消息时，如果它没有给别的候选人投过票，并且请求者的任期号不小于自己的任期号，且请求者的日志至少和自己一样新，那么它就会投票给这个请求者。否则，它会拒绝投票。</li><li>**当选：**一个候选人如果在一次选举中收到了大多数节点的投票，那么它就成为了新的领导者。然后，它会开始向所有节点发送心跳消息，阻止他们新的选举。</li><li>**领导者的工作：**领导者接收到客户端的请求后，将请求作为一个新的日志条目添加到自己的日志中，然后尝试将这个日志条目复制到所有其他节点的日志中。。</li><li>**日志复制：**领导者通过心跳消息来复制日志条目。每个心跳消息中都包含了需要复制的日志条目。当一个跟随者收到心跳消息后，它会将其中的日志条目添加到自己的日志中。</li><li>**日志提交：**当一个日志条目呗复制到了大多数节点的日志中，领导者就认为这个日志条目已经被提交，然后它会通知所有节点将这个日志条目应用到自己的状态机。</li><li>**领导者失效和重新选举：**如果一个领导者失效（崩溃或者网络问题），那么当跟随者超过选举超时时间没有收到领导者的心跳消息时，它们就会开始新的领导者选举。</li><li>**安全性：**为了保证系统的一致性，Raft协议在领导者选举和日志复制等过程中加入了一些安全性措施。例如，一个候选人在领导者选举中只有在其日志至少和大多数节点一样新时，才能赢得选举。</li><li>**持久化：**节点会定期将自己的信息，比如当前任期号、投票信息、日志条目和快照，持久化到硬盘。这是为了确保即使节点崩溃或者重启，也能从硬盘恢复到最新的状态。</li><li>**恢复：**当节点重启时，它首先从硬盘中读取持久化的信息，恢复其任期号、投票信息、日志条目和快照。然后，它会以跟随者的身份开始运行，等待领导者的心跳消息。</li><li>**日志压缩：**随着时间的推移，每个节点的日志可能会变得非常大，因此需要进行压缩。这个过程被称为快照，在快照过程中，节点将当前的系统状态（状态机的状态）保存下来，并清除所有已被应用且索引值小于这个状态的日志条目。快照也需要持久化存储，以防节点重启时丢失状态。</li></ol><h3 id="3follower会响应client的读写操作吗"><a class="markdownIt-Anchor" href="#3follower会响应client的读写操作吗"></a> 3.follower会响应client的读写操作吗</h3><p>在Raft协议中，跟随者节点通常不直接响应客户端的读写请求。所有的读写请求都应该由领导者节点处理。这样设计的主要原因是保持系统的一致性。因为只有领导者节点才能确保它拥有过最新和完整的系统状态。</p><p>对于写请求，客户端的请求首先会被发送到领导者节点，然后领导者把这个更新操作作为一个新的日志条目，然后通过日志复制过程，将这个新的日志条目复制到所有的跟随者节点。只有当大多数节点都写入了这个日志条目，领导者才会认为这个操作已经完成，然后应用这个操作到系统的状态机，并将结果返回给客户端。</p><p>对于读请求，也通常由领导者节点直接处理。因为只有领导者才能确保它的状态是最新的。</p><p>但是也有一些优化的方法可以让跟随者处理读请求，以减轻领导者的负载。一种方法是领导者在响应客户端的读请求之前，首先向所有的跟随者发送一条心跳消息，等所有的跟随者都恢复后，再响应客户端的读请求。这样可以确保跟随者的状态和领导者是一致的。然后跟随者就可以直接响应来自客户端的读请求。</p><h2 id="4超过半数的决策机制如何保证leader日志的完整性"><a class="markdownIt-Anchor" href="#4超过半数的决策机制如何保证leader日志的完整性"></a> 4.超过半数的决策机制如何保证leader日志的完整性</h2><p>在Raft协议中，领导者维护的日志的完整性通过多数投票机制进行保障。这主要体现在两个方面：</p><ol><li>领导者选举：在选举新的领导者时，只有当候选人的日志至少和大部分节点的日志一样新，它才能得到足够多的票数称为领导者。这就确保了新领导者的日志中包含了所有已经提交的日志项。</li><li>日志复制：领导者在接收到客户端的命令后，将命令作为新的日志项添加到其日志中，然后尝试将这个日志项复制到其他的跟随者节点。一旦这个日志项被复制到大多数的服务器上，它就被认为时已经提交的。领导者会将已提交的日志项应用到状态机，然后客户端返回结果。</li></ol><p>通过这样的方式，超过半数的决策机制确保了领导者日志的完整性，确保了在领导者发生更换的时候，新的领导者的日志包含了所有已经提交的日志项，从而避免了数据丢失。同时，只有当一个日志项被大多数的服务器复制，它才被认为时已经提交的，这样就能确保数据的一致性。</p><h2 id="5为什么使用log不直接写入状态机"><a class="markdownIt-Anchor" href="#5为什么使用log不直接写入状态机"></a> 5.为什么使用log，不直接写入状态机</h2><ol><li>Raft系统之所以对log关注这么多的一个原因时，log时leader用来对操作排序的一种手段。这对复制状态机而言至关重要，对于这些复制状态机来说，所有副本不仅要执行相同的操作，还需要用相同的顺序执行这些操作。而log与其他很多事物，共同构成了Leader对接收到的客户端操作分配顺序的机制。比如说，我由10个客户端同时向Leader发出请求，Leader必须对这些请求确定一个顺序，并确保所有其他的副本都遵从这个顺序。实际上，log时一些按照数字编号的槽位，槽位的数字表示了leader选择的顺序。</li><li>Log的另一个用途是，在一个副本收到了操作，但是还没有执行操作时。该副本需要将这个操作存放在某处，直到收到了Leader发送的新的commit号才执行。所以，对于Raft的Follower来说，Log时用来存放临时操作的地方。Follower收到了这些临时的操作，但是还不确定这些操作是否被commit了。我们将会看到，这些操作可能会被抛弃。</li><li>Log的另一个用途是用在Leader节点，我（Robert教授）很喜欢这个特性。Leader需要在它的Log中记录操作，因为这些操作可能需要重传给Follower。如果一些Follower由于网络原因或者其他原因短时间离线了或者丢了一些消息，Leader需要能够向Follower重传丢失的Log消息。所以，Leader也需要一个地方来存放客户端请求的拷贝。即使对那些已经commit的请求，为了能够向丢失了相应操作的副本重传，也需要存储在Leader的Log中。</li><li>所有节点都需要保存Log还有一个原因，就是它可以帮助重启的服务器恢复状态。你可能的确需要一个故障了的服务器在修复后，能重新加入到Raft集群，要不然你就永远少了一个服务器。比如对于一个3节点的集群来说，如果一个节点故障重启之后不能自动加入，那么当前系统只剩2个节点，那将不能再承受任何故障，所以我们需要能够重新并入故障重启了的服务器。对于一个重启的服务器来说，会使用存储在磁盘中的Log。每个Raft节点都需要将Log写入到它的磁盘中，这样它故障重启之后，Log还能保留。而这个Log会被Raft节点用来从头执行其中的操作进而重建故障前的状态，并继续以这个状态运行。所以，Log也会被用来持久化存储操作，服务器可以依赖这些操作来恢复状态。</li></ol><h2 id="6如何解决split-vote的问题"><a class="markdownIt-Anchor" href="#6如何解决split-vote的问题"></a> 6.如何解决split vote的问题</h2><p>分票(split vote): 这是一个选举问题，在Raft等一致性协议中可能会遇到。当一个集群中没有一个节点能够得到大多数节点的选票，从而无法选举出新的领导者时，我们就称之为发生了分票。这通常是由于网络延迟，节点启动时间不一致或者其他原因导致的。</p><ol><li>随机选举超时时间</li><li>选举失败后的重新选举</li><li>票的限制性投票</li></ol><h2 id="7paxos"><a class="markdownIt-Anchor" href="#7paxos"></a> 7.Paxos</h2><p>Paxos协议是基于消息传递的，并且有三种角色：proposers（提议者），acceptors（接受者）和learners（学习者）。一个节点可以扮演这三种角色中的一个或多个。</p><ol><li>Proposers：提议者提出一个提议，这个提议包含了一个提议编号（N）和一个值（V）。提议者首先发送一个请求，请求在一组接受者中获得对提议编号N的承诺。如果提议者从大多数接受者那里受到了承诺，那么它就可以向这些接受者发送一个新请求，要求它们接受提议（N，V）。</li><li>Acceptors：接受者是Paxos协议中的主要角色。一个接受者可以接受多个提议者的建议。但是，一旦它已经对某个提议编号N做出了承诺，就不能再接受任何编号小于N的提议。</li><li>Learners:学习者角色是用来学习呗接受者接受的提议。再大多数的Paxos应用中，每个节点都充当了学习者的角色，这个每个节点都能了解到被接受的提议。</li></ol><p>虽然Paxos协议在理论上是一个很好的解决一致性问题的方法， 但是在实际中并不常用。这是因为它的原始版本相当复杂，难以理解和实现。此外，它不支持更复杂的功能，如集群成员管理和日志复制等。因此，许多系统采用了Paxos的变体或其他替代方案，如Raft协议等</p><p>Paxos算法流程可分为两个阶段，即准备和提议阶段</p><p>1.准备阶段：</p><ul><li>提议者选择一个提议编号N，并将准备请求发送给接受者群体中的大多数或全部节点，该请求包含提议编号N。</li><li>接受者收到准备请求后，如果此请求的提议编号N大于该接受者已经恢复过的所有准备请求的编号，那么该接受者承诺不再接受任何编号小于N的提议，并将自己上一次接受的提议回复给提议者。</li></ul><p>2.提议阶段</p><ul><li>提议者如果收到了大多数接受者的回复，那么就会开始第二阶段，发送接受请求给大多数或全部接受者。该请求包含提议编号N和一个值V，如果提议者收到的回复中有接受者已接受的提议，那么该值V应该是所有回复中编号最大的已接受提议的值，否则V可以是提议者自己决定的值。</li><li>接受者收到接受请求后，如果此请求的提议编号N不小于该接受者已经回复过的所有准备请求的编号，那么接受者就接受这个提议，即该提议称为接受者接受的提议。</li></ul><p>Paxos算法的基本思想是只要有一个提议被大多数接受者接受，那么该提议的值就被决定下来。但在实际过程中可能存在多个提议者同时提交提议的情况，因此可能出现一个值被确定后，仍有提议者不知情而继续提交新的提议，所以这个算法要确保任何新的提议的值必须等于已经被决定的值，这就需要接受者做出承诺，不再接受编号小于N的任何提议，确保已决定的值不会被更改。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>raft</tag>
      
      <tag>分布式算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GFS</title>
    <link href="/2024/03/23/GFS/"/>
    <url>/2024/03/23/GFS/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="gfs"><a class="markdownIt-Anchor" href="#gfs"></a> GFS</h1><h2 id="概要"><a class="markdownIt-Anchor" href="#概要"></a> 概要</h2><p>我们设计并实现了google文件系统，这是一个可扩展的分布式文件系统，适用于大型分布式数据密集型应用程序。它在廉价的商用硬件上运行时提供容错性，并为大量客户机提供高聚合性能。</p><p>虽然与以前的分布式文件系统有许多相同的目标，但我们的设计是由对应用程序工作负载和技术环境的观察(包括当前的和预期的)驱动的，这反映了与早期文件系统假设的明显背离。这促使我们重新审视传统的选择，并探索完全不同的设计要点。</p><p>文件系统已成功满足我们的存储需求。它在谷歌内部被广泛部署为存储平台，用于生成和处理我们的服务所使用的数据，以及需要大量数据集的研究和开发工作。迄今为止最大的集群在1000多台机器上的数千个磁盘上提供了数百tb的存储，并且可以由数百个客户机并发访问。</p><p>在本文中，我们介绍了为支持分布式应用程序而设计的文件系统接口扩展，讨论了我们设计的许多方面，并报告了来自微基准测试和实际使用的测量结果。</p><h2 id="介绍"><a class="markdownIt-Anchor" href="#介绍"></a> 介绍</h2><p>我们设计并实现了谷歌文件系统(GFS)，以满足谷歌快速增长的数据处理需求。GFS与以前的分布式文件系统有许多相同的目标，比如性能、可伸缩性、可靠性和可用性。然而，它的设计是由我们的应用程序工作负载和技术环境的关键观察驱动的，包括当前的和预期的，这反映了与早期一些文件系统设计假设的明显背离。我们重新审视了传统的选择，并在设计空间中探索了截然不同的观点。</p><p>首先，组件故障是常态，而不是例外。文件系统由数百甚至数千台存储机器组成，这些存储机器由廉价的商品部件组成，并由相当数量的客户机访问。组件的数量和质量实际上保证了一些组件在任何给定的时间都不能正常工作，一些组件将无法从当前的故障中恢复。我们已经看到了由应用程序错误、操作系统错误、人为错误以及磁盘、内存、连接器、网络和电源故障引起的问题。因此，持续监控、错误检测、容错和自动恢复必须是系统的组成部分。</p><p>其次，按照传统标准，文件是巨大的。多gb文件很常见。每个文件通常包含许多应用程序对象，例如web文档。当我们经常处理由数十亿个对象组成的tb级快速增长的数据集时，管理数十亿个接近kb大小的文件是非常笨拙的，即使文件系统可以支持它。因此，必须重新考虑设计假设和参数，例如I/O操作和块大小。</p><p>第三，大多数文件都是通过附加新数据而不是覆盖现有数据来改变的。在文件中随机写实际上是不存在的。一旦写入，文件就只能被读取，而且通常只能按顺序读取。各种数据都具有这些特征。有些可能构成数据分析程序扫描的更大的存储库。有些可能是由运行的应用程序不断生成的数据流。有些可能是档案资料。有些可能是在一台机器上产生的中间结果，在另一台机器上处理，无论是同时处理还是稍后处理。考虑到这种对大文件的访问模式，追加成为性能优化和原子性保证的重点。而在客户端缓存数据块就失去了吸引力。</p><p>第四，共同设计应用程序和文件系统API通过增加我们的灵活性使整个系统受益。例如，我们放宽了GFS的一致性模型，以极大地简化文件系统，而不会给应用程序带来繁重的负担。我们还引入了原子追加操作，以便多个客户机可以并发地追加到一个文件，而无需在它们之间进行额外的同步。这些将在本文后面进行更详细的讨论。</p><p>目前部署了多个GFS集群用于不同的目的。最大的数据库有超过1000个存储节点，超过300 TB的磁盘存储，并且在不同的机器上有数百个客户端连续地大量访问。</p><h2 id="设计概况"><a class="markdownIt-Anchor" href="#设计概况"></a> 设计概况</h2><h3 id="假设"><a class="markdownIt-Anchor" href="#假设"></a> 假设</h3><p>在为我们的需求设计文件系统的过程中，我们一直受到既有挑战又有机会的假设的指导。我们之前提到了一些关键的观察结果，现在更详细地列出我们的假设。</p><ul><li>该系统是由许多经常失效的廉价商品组件构建而成的。它必须不断地监控自身，并在常规基础上检测、容忍组件故障，并迅速从组件故障中恢复。</li><li>系统存储少量的大文件。我们期望有几百万个文件，每个文件的大小通常为100mb或更大。多gb文件是常见的情况，应该有效地管理。必须支持小文件，但我们不需要针对它们进行优化。</li><li>工作负载主要包括两种类型的读:大的流读和小的随机读。在大型流读取中，单个操作通常读取数百kb，更常见的是1mb或更多。来自同一客户机的连续操作通常读取文件的连续区域。一个小的随机读取通常以一些任意偏移量读取几个kb。注重性能的应用程序通常对它们的小读取进行批处理和排序，以便在文件中稳定地前进，而不是来回移动。</li><li>这些工作负载还有许多大的、顺序的写操作，将数据附加到文件中。典型的操作大小与读操作大小相似。一旦写入，文件就很少再被修改。支持在文件中的任意位置进行小的写操作，但不一定要高效。</li><li>系统必须有效地为并发追加到同一文件的多个客户端实现定义良好的语义。我们的文件通常用作生产者-消费者队列或用于多路合并。数百个生产者，每台机器运行一个，将并发地附加到一个文件。具有最小同步开销的原子性是必不可少的。该文件可以稍后读取，或者消费者可以同时读取该文件。</li><li>高持续带宽比低延迟更重要。我们的大多数目标应用程序都非常重视以高速率批量处理数据，而很少有对单个读或写有严格的响应时间要求。</li></ul><h3 id="接口"><a class="markdownIt-Anchor" href="#接口"></a> 接口</h3><p>GFS提供了一个熟悉的文件系统接口，尽管它没有实现像POSIX这样的标准API。文件在目录中按层次结构组织，并由路径名标识。我们支持创建、删除、打开、关闭、读取、写入文件等常用操作</p><p>此外，GFS还具有快照和记录追加操作。快照以较低的成本创建文件或目录树的副本。记录追加允许多个客户端并发地将数据追加到同一个文件，同时保证每个客户端追加的原子性。这对于实现多路合并结果和生产者-消费者队列非常有用，因为许多客户机可以在不附加锁定的情况下同时挂起它们。我们发现这些类型的文件在构建大型分布式应用程序时是无价的。快照和记录追加将分别在3.4节和3.3节中进一步讨论。</p><h3 id="架构"><a class="markdownIt-Anchor" href="#架构"></a> 架构</h3><p>一个GFS文件系统是由多个块服务器和多个主服务器组成，并由多个客户端访问，如图1所示。这些机器通常都是运行用户级服务器进程的普通Linux机器。在同一台机器上同时运行chunkserver和客户机是很容易的，只要机器资源允许，并且运行可能不可靠的应用程序代码所导致的较低的可靠性是可以接受的。</p><p><img src="../imgs/GFS/image-20240323170452675.png" alt="图1：GFS架构" /></p><p>文件被分成固定大小的块。它由一个不可变的、全局唯一的64位块句柄来标识，这个句柄是在创建块时由主机分配的。chunkserver将块以Linux文件的形式存储在本地磁盘上，并通过块句柄和字节范围指定读取或写入块数据。为了提高可靠性，每个块都在多个块服务器上复制。默认情况下，我们存储三个副本，不过用户可以为文件名称空间的不同区域指定不同的复制级别。</p><p>主服务器维护所有文件系统元数据。这包括名称空间、访问控制信息、从文件到块的映射以及块的当前位置。它还控制系统范围的活动，如块租赁管理、孤立块的垃圾收集和块服务器之间的块迁移。主服务器定期与HeartBeat消息中的每个chunkserver通信，向其提供指令并收集其状态。</p><p>链接到每个应用程序中的GFS客户端代码实现文件系统API，并与主服务器和块服务器通信，以代表应用程序读取或写入数据。客户端与主服务器交互进行元数据操作，但所有承载数据的通信都直接到chunkserver。我们不提供POSIX API，因此不需要挂钩到Linux vnode层。</p><p>客户端和chunkserver都不缓存文件数据。客户机缓存提供的好处很少，因为大多数应用程序都要处理巨大的文件，或者工作集太大而无法缓存。没有它们可以通过消除缓存一致性问题来简化客户端和整个系统。(不过，客户端确实会缓存元数据。)chunkserver不需要缓存文件数据，因为块存储为本地文件，因此Linux的缓冲区缓存已经将频繁访问的数据保存在内存中。</p><h3 id="单个master"><a class="markdownIt-Anchor" href="#单个master"></a> 单个master</h3><p>拥有单个主节点极大地简化了我们的设计，并使主节点能够使用全局知识做出复杂的块放置和复制决策。然而，我们必须尽量减少它对读写的参与，这样它才不会成为瓶颈。客户端从不通过主服务器读写文件数据。相反，客户端询问主服务器它应该联系哪个块服务器。它将这些信息缓存一段有限的时间，并直接与chunkserver交互以进行许多后续操作。</p><p>让我们参照图1来解释一个简单读取的交互。首先，使用固定的块大小，客户机将应用程序指定的文件名和字节偏移量转换为文件中的块索引。然后，它向主机发送一个包含文件名和块索引的请求。主服务器返回相应的块句柄和副本的位置。客户端使用文件名和块索引作为键来缓存这些信息。</p><p>然后，客户端向其中一个副本(很可能是最近的副本)发送请求。请求指定块句柄和该块中的字节范围。在缓存的信息过期或文件被重新打开之前，对同一块的进一步读取不需要更多的客户机-主交互。实际上，客户端通常在同一个请求中请求多个数据块，而主服务器也可以在被请求的数据块之后立即包含数据块的信息。这些额外的信息避免了未来的几个客户机-主交互，几乎没有额外的成本。</p><h3 id="块大小"><a class="markdownIt-Anchor" href="#块大小"></a> 块大小</h3><p>块大小是关键的设计参数之一。我们选择64 MB，这比典型的文件系统块大小大得多。每个块副本以普通Linux文件的形式存储在chunkserver上，仅在需要时进行扩展。惰性空间分配避免了由于内部碎片而造成的空间浪费，这可能是对这种方法最大的反对意见</p><p>大块大小提供了几个重要的优势。首先，它减少了客户端与主服务器交互的需要，因为对同一块进行读写只需要向主服务器发出一次初始请求以获取块位置信息。这种减少对于我们的工作负载来说尤其重要，因为应用程序大多是顺序地读取和写入大量数据。即使是小的随机读取，客户端也可以轻松地缓存所有的块位置信息为多TB的工作集。其次，由于在较大的块上，客户端更有可能在给定的块上执行许多操作，因此可以通过在较长时间内保持与块服务器的持久TCP连接来减少网络开销。第三，它减少了存储在主服务器上的元数据的大小。这允许我们将元数据保存在内存中，这反过来又带来了其他优势，我们将在第2.6.1节中讨论。</p><p>另一方面，大块大小(即使使用惰性空间分配)也有其缺点。小文件由少量块组成，可能只有一个块。如果许多客户端访问同一个文件，存储这些块的块服务器可能会成为热点。在实践中，热点并不是一个主要问题，因为我们的应用程序大多是按顺序读取大的多块文件</p><p>然而，当批处理队列系统首次使用GFS时，热点确实出现了:可执行文件作为单个块文件写入GFS，然后同时在数百台机器上启动。存储此可执行文件的几个块服务器由于数百个同时请求而超载。我们通过使用更高的复制因子来存储这些可执行文件，并通过使批处理队列系统错开应用程序启动时间来解决这个问题。一个潜在的长期解决方案是允许客户机在这种情况下从其他客户机读取数据。</p><h3 id="元数据"><a class="markdownIt-Anchor" href="#元数据"></a> 元数据</h3><p>master存储三种主要类型的元数据:文件和块名称空间、从文件到块的映射以及每个块副本的位置。所有元数据都保存在主机内存中。前两种类型(名称空间和文件到块映射)也通过将变化记录到存储在主机本地磁盘上的操作日志并在远程机器上复制来保持持久化。使用日志允许我们简单、可靠地更新主状态，并且在主崩溃时不会冒不一致的风险。主服务器不持久化存储块位置信息。相反，它会在主启动时询问每个chunkserver有关其chunks的信息，以及每当一个chunkserver加入集群时。</p><h4 id="内存数据结构"><a class="markdownIt-Anchor" href="#内存数据结构"></a> 内存数据结构</h4><p>由于元数据存储在内存中，所以主操作速度很快。此外，主服务器可以在后台周期性地扫描其整个状态，这既简单又有效。这种周期性扫描用于实现块垃圾收集、出现chunkserver故障时的重新复制以及块迁移，以平衡chunkserver之间的负载和磁盘空间使用。第4.3节和4.4节将进一步讨论这些活动</p><p>这种只使用内存的方法的一个潜在问题是，块的数量以及整个系统的容量受到主服务器拥有多少内存的限制。这在实践中并不是一个严重的限制。master为每个64mb的块维护少于64字节的元数据。大多数块都是满的，因为大多数文件包含许多块，只有最后一个块可能被部分填充。类似地，文件名称空间数据通常需要每个文件少于64字节，因为它使用前缀压缩紧凑地存储文件名。</p><p>如果有必要支持更大的文件系统，向主服务器添加额外内存的成本与将元数据存储在内存中所获得的简单性、可靠性、性能和灵活性相比是微不足道的。</p><h4 id="块位置"><a class="markdownIt-Anchor" href="#块位置"></a> 块位置</h4><p>主服务器不会持久记录哪些块服务器拥有给定块的副本。它只是在启动时轮询块服务器以获取该信息。此后，主服务器可以使自己保持最新状态，因为它控制所有块的放置，并使用常规的HeartBeat消息监视块服务器状态</p><p>我们最初试图将块位置信息持久地保存在主服务器上，但我们认为在启动时从chunkserver请求数据要简单得多，之后定期请求数据。这消除了在chunkserver加入和离开集群、更改名称、失败、重新启动等过程中保持主服务器和chunkserver同步的问题。在拥有数百台服务器的集群中，这些事件经常发生。</p><p>理解这种设计决策的另一种方法是认识到，chunkserver对它自己的磁盘上有什么块或没有什么块拥有最终决定权。试图在主服务器上维护这些信息的一致视图是没有意义的，因为chunkserver上的错误可能会导致块自动消失(例如，磁盘可能坏掉并被禁用)，或者操作员可能会重命名chunkserver</p><h4 id="操作日志"><a class="markdownIt-Anchor" href="#操作日志"></a> 操作日志</h4><p>操作日志记录了元数据重大变更的历史记录。这是GFS的核心。它不仅是元数据的唯一持久记录，而且还用作定义并发操作顺序的逻辑时间线。文件和块，以及它们的版本(参见第4.5节)，都是由它们被创建时的逻辑时间唯一且永久地标识的。</p><p>由于操作日志是至关重要的，我们必须可靠地存储它，并且在元数据更改持久化之前，不让更改对客户机可见。否则，即使块本身幸存下来，我们也会有效地丢失整个文件系统或最近的客户端操作。因此，我们在多台远程机器上复制它，并且只有在本地和远程将相应的日志记录刷新到磁盘之后才响应客户机操作。主服务器在刷新之前将多个日志记录批处理在一起，从而减少刷新和复制对整个系统吞吐量的影响</p><p>主服务器通过回放操作日志恢复文件系统状态。为了最小化启动时间，我们必须保持日志较小。每当日志增长超过一定大小时，主服务器就会检查其状态，以便通过从本地磁盘加载最新的检查点并在此之后仅重播有限数量的日志记录来进行恢复。检查点采用类似b树的紧凑形式，可以直接映射到内存中，并用于名称空间查找，而无需进行额外的解析。这进一步加快了恢复速度并提高了可用性。</p><p>因为构建检查点可能需要一段时间，所以master的内部状态是这样构建的，即可以创建新的检查点，而不会延迟传入的突变。主服务器切换到新的日志文件，并在一个单独的线程中创建新的检查点。新的检查点包括转换前的所有突变。对于拥有几百万个文件的集群，可以在一分钟左右的时间内创建它。完成后，将其写入本地和远程磁盘。</p><p>恢复只需要最新的完整检查点和后续的日志文件。旧的检查点和日志文件可以自由删除，但我们保留了一些以防止灾难。检查点期间的失败不会影响正确性，因为恢复代码会检测并跳过不完整的检查点。</p><h3 id="一致性模型"><a class="markdownIt-Anchor" href="#一致性模型"></a> 一致性模型</h3><p>GFS有一个宽松的一致性模型，可以很好地支持我们的高度分布式应用程序，但实现起来仍然相对简单和高效。现在我们讨论GFS的保证以及它们对应用程序的意义。我们还强调了GFS如何维持这些保证，但将细节留给本文的其他部分。</p><h4 id="gfs担保"><a class="markdownIt-Anchor" href="#gfs担保"></a> GFS担保</h4><p>文件名称空间的变化(例如，文件创建)是原子性的。命名空间锁定保证原子性和正确性(章节4.1);主操作日志定义了这些操作的全局总顺序(章节2.6.3)。</p><p>数据突变后文件区域的状态取决于突变的类型、成功还是失败以及是否存在并发突变。表1总结了结果。如果所有客户端总是看到相同的数据，无论他们从哪个副本读取，那么文件区域就是一致的。如果一个文件数据突变是一致的，那么在它之后定义一个区域，并且客户端将看到整个突变所写的内容。当一个突变成功而不受并发写入器的干扰时，受影响的区域就被定义了(并且暗示是一致的):所有客户端都将始终看到突变所写的内容。并发成功的突变使区域未定义，但保持一致:所有客户端都看到相同的数据，但它可能不反映任何一个突变所写的内容。通常，它由来自多个突变的混合片段组成。失败的突变使区域不一致(因此也是未定义的):不同的客户端可能在不同的时间看到不同的数据。我们将在下面描述应用程序如何区分已定义的区域和未定义的区域。应用程序不需要进一步区分不同类型的未定义区域。</p><p><img src="../imgs/GFS/image-20240323172113185.png" alt="表1" /></p><p>数据变化可能是写入或追加记录。写操作导致在应用程序指定的文件偏移量处写入数据。记录追加导致数据(“记录”)至少自动追加一次，即使在并发突变存在的情况下，但在GFS选择的偏移量(3.3节)。(相反，“常规”追加只是在客户端认为是文件当前结束的偏移量处进行写操作。)偏移量返回给客户端，并标记包含该记录的已定义区域的开始。此外，GFS可以在两者之间插入填充或记录重复。它们占用的区域被认为是不一致的，并且通常与用户数据量相比显得微不足道。</p><p>在一系列成功的突变之后，保证被突变的文件区域被定义，并包含由最后一次突变写入的数据。GFS通过(a)在其所有副本上以相同的顺序对块应用突变(章节3.1)，以及(b)使用块版本号来检测任何由于在其chunkserver关闭时错过突变而变得过时的副本(章节4.5)来实现这一点。失效副本将永远不会涉及到突变，也不会给客户端请求主服务器的块位置。他们是垃圾收集在最早的机会。</p><p>由于客户端缓存块位置，因此它们可能会在更新该信息之前从过时的副本中读取数据。该窗口受缓存项超时和下次打开文件的限制，该文件将从缓存中清除该文件的所有块信息。此外，由于我们的大多数文件都是仅追加的，过期的副本通常返回块的过早结束，而不是过时的数据。当读取器重新尝试并联系主服务器时，它将立即获得当前块的位置。</p><p>在成功的突变之后很长一段时间，组件故障当然仍然会损坏或破坏数据。GFS通过主服务器和所有chunkserver之间的定期握手来识别故障的chunkserver，并通过校验和来检测数据损坏(章节5.2)。一旦问题出现，数据会尽快从有效的副本中恢复(章节4.3)。只有在GFS做出反应之前(通常在几分钟内)所有副本都丢失时，块才会不可逆转地丢失。即使在这种情况下，它也变得不可用，而不是损坏:应用程序接收到明显的错误，而不是损坏的数据。</p><h4 id="对应用的影响"><a class="markdownIt-Anchor" href="#对应用的影响"></a> 对应用的影响</h4><p>GFS应用程序可以使用一些其他用途已经需要的简单技术来适应宽松的一致性模型:依赖追加而不是覆盖、检查点和编写自我验证、自我识别的记录。</p><p>实际上，我们所有的应用程序都是通过追加而不是覆盖来改变文件的。在一种典型的用法中，编写器从头到尾生成一个文件。它在写入所有数据后自动将文件重命名为永久名称，或者定期检查成功写入了多少数据。检查点还可能包括应用程序级别的校验和。读取器只验证和处理文件区域，直到最后一个检查点，该检查点已知处于定义状态。不考虑一致性和并发性问题，这种方法对我们很有帮助。对于应用程序故障，追加操作比随机写操作更有效，更有弹性。检查点允许写入器以增量方式重新启动，并防止读取器处理从应用程序的角度来看仍然不完整的已成功写入的文件数据。</p><p>在另一种典型使用中，许多写入器并发地挂起到一个文件，用于合并结果或作为生产者-消费者队列。Record append的“至少追加一次”语义保留了每个写入器的输出。读者按如下方式处理偶尔出现的填充和重复。编写者准备的每条记录都包含额外的信息，如校验和，以便验证其有效性。阅读器可以使用校验和识别并丢弃多余的填充和记录片段。如果它不能容忍偶尔的重复(例如，如果它们会触发非幂等操作)，它可以使用记录中的唯一标识符将它们过滤掉，这通常需要为相应的应用程序实体(如web文档)命名。这些记录I/O的功能(除去重复)是在我们的应用程序共享的库代码中，并适用于Google的其他文件接口实现。这样，相同的记录序列，加上很少的重复，总是传递给记录读取器。</p><h2 id="系统交互"><a class="markdownIt-Anchor" href="#系统交互"></a> 系统交互</h2><p>我们设计这个系统是为了尽量减少master对所有操作的参与。在此背景下，我们现在描述客户端、主服务器和块服务器如何交互以实现数据突变、原子记录追加和快照。</p><h3 id="租约和突变顺序"><a class="markdownIt-Anchor" href="#租约和突变顺序"></a> 租约和突变顺序</h3><p>突变是一种改变数据块内容或元数据的操作，例如写操作或追加操作。每个突变都在所有块的副本上执行。我们使用租约来维护跨副本的一致的突变顺序。主服务器将块租期授予其中一个副本，我们称之为主服务器。主节点为数据块的所有突变选择一个serialorder。当应用突变时，所有副本都遵循这个顺序。因此，全局mutationorder首先由master选择的租期授予顺序定义，在租期内由primary分配的序列号定义。</p><p>租期机制的设计目的是最小化主服务器上的管理开销。租约的初始超时为60秒。但是，只要数据块被修改，主服务器就可以无限期地请求和接收主服务器的扩展。这些扩展请求和授予承载在主服务器和所有块服务器之间定期交换的HeartBeat消息上。有时，主服务器可能会尝试在租约到期之前撤销租约(例如，当主服务器想要禁用正在重命名的文件的突变时)。即使主服务器失去了与主服务器的通信，它也可以在旧租约到期后安全地将新租约授予另一个副本。</p><p>在图2中，我们通过这些编号的步骤，遵循写操作的控制流来说明这个过程。</p><p><img src="../imgs/GFS/image-20240323174142569.png" alt="图2" /></p><ol><li>客户端询问主服务器哪个chunkserver持有该块的当前租约以及其他副本的位置。如果没有人拥有租约，主服务器就会将租约授予它选择的副本(未显示)。</li><li>主服务器返回主服务器的身份和其他(辅助)副本的位置。客户端缓存这些数据以备将来发生变化。只有当主服务器无法访问或回复它不再持有租约时，它才需要再次与主服务器联系</li><li>客户端将数据推送到所有副本。客户端可以以任何顺序执行此操作。每个chunkserver将数据存储在内部LRU缓冲区缓存中，直到数据被使用或老化。通过将数据流与控制流解耦，我们可以根据网络拓扑来调度昂贵的数据流，而不管哪个chunkserver是主服务器，从而提高性能。第3.2节进一步讨论了这一点。</li><li>一旦所有副本都确认接收到数据，客户机就向主服务器发送写请求。请求标识早先推送到所有副本的数据。主服务器为它接收到的所有突变(可能来自多个客户机)分配连续的序列号，这提供了必要的序列化。它按序列号顺序将突变应用到自己的局部状态。</li><li>主服务器将写请求转发给所有从服务器副本。每个次要副本按照主副本分配的相同序列号顺序应用突变。</li><li>次要服务器都回复主服务器，表明它们已完成操作。</li><li>主服务器响应客户端。在任何副本上遇到的任何错误都会报告给客户端。如果出现错误，则可能在主副本和辅助副本的任意子集上写操作成功。(如果它在主服务器上失败了，它就不会被分配序列号并转发。)客户端请求被认为失败，修改后的区域处于不一致状态。我们的客户端代码通过重新尝试失败的突变来处理此类错误。它将在步骤(3)到步骤(7)上进行一些尝试，然后从写入的开始重新尝试。</li></ol><p>如果应用程序的写操作很大或跨越块边界，GFS客户机代码将其分解为多个写操作。它们都遵循上面描述的控制流，但可能与来自其他客户机的并发操作交叉或覆盖。因此，共享文件区域最终可能包含来自不同客户端的片段，尽管副本将是相同的，因为在所有副本上以相同的顺序成功完成了单个操作。这使得文件区域处于一致但未定义的状态，如2.7节所述。</p><h3 id="数据流"><a class="markdownIt-Anchor" href="#数据流"></a> 数据流</h3><p>我们将数据流与控制流解耦，以有效地利用网络。当控制从客户机流向主服务器，然后流向所有辅助服务器时，数据以流水线方式沿着精心挑选的块服务器链线性推送。我们的目标是充分利用每台机器的网络带宽，避免网络瓶颈和高延迟链接，并最大限度地减少延迟来推送所有数据。</p><p>为了充分利用每台机器的网络带宽，数据沿着块服务器链线性推送，而不是分布在一些其他拓扑结构中(例如，树)。因此，每台机器的全部出站带宽用于尽可能快地传输数据，而不是在多个接收方之间分配。</p><p>为了尽可能避免网络瓶颈和高延迟链路(例如，交换机间链路通常两者都有)，每台机器将数据转发到网络拓扑中“最近的”尚未接收到数据的机器。假设客户端将数据推送到块服务器S1到S4。它将数据发送到最近的块服务器，比如S1。S1转发到最近的块服务器S2，通过最接近S1的S4，比如S2。同样，S2将其转发给S3或S4，哪个更接近S2，依此类推。我们的网络拓扑结构非常简单，可以从IP地址准确地估计“距离”。</p><p>最后，我们通过在TCP连接上进行数据传输来最小化延迟。一旦chunkserver接收到一些数据，它就立即开始转发。流水线对我们特别有帮助，因为我们使用全双工链路的交换网络。立即发送数据不会降低接收速率。在没有网络拥塞的情况下，将B个字节传输到R个副本的理想耗时是B/T + RL，其中T是网络吞吐量，L是两台机器之间传输字节的延迟时间。我们的网络链路通常是100mbps (T)，而L远低于1ms。因此，理想情况下，1mb可以在大约80ms内分配。</p><h3 id="原子记录追加"><a class="markdownIt-Anchor" href="#原子记录追加"></a> 原子记录追加</h3><p>GFS提供了一个称为recordappend的原子追加操作。在传统的写操作中，客户端指定要写入数据的偏移量。并发写到同一区域是不可序列化的:该区域可能最终包含来自多个客户端的数据片段。然而，在recordappend中，客户端只指定数据。在GFS选择的偏移量处，它至少自动地将它发送到文件一次(即，作为一个连续的字节序列)，并将该偏移量返回给客户端。这类似于书面。在Unix中，当多个写入器并发地以0_APPEND模式打开文件时，不存在任何条件。</p><p>记录追加被我们的分布式应用程序大量使用，在这些应用程序中，不同机器上的许多客户端并发地追加同一个文件。如果客户端使用传统的写操作，则需要额外的复杂和昂贵的同步，例如通过分布式锁管理器。在我们的工作负载中，此类文件通常用作多生产者/单消费者队列，或者包含来自许多不同客户机的合并结果。</p><p>记录追加是一种变异，它遵循第3.1节中的控制流，只是在主端增加了一点额外的逻辑。客户端将数据推送到文件最后一个块的所有副本，然后将其请求发送到主服务器。主要检查将记录追加到当前块是否会导致块超过最大大小(64 MB)。如果是，它将块填充到最大大小，告诉辅助服务器也这样做，并回复客户端，指示应该在下一个块上重试该操作。(Record append被限制最多为最大块大小的四分之一，以使最坏情况下的碎片保持在可接受的水平。)如果记录符合最大大小(这是常见的情况)，则主服务器将数据附加到其副本，告诉辅助服务器将数据写入它所处的精确偏移位置，并最终向客户端返回成功。</p><p>如果在任何副本上添加记录失败，则客户端会重试该操作。因此，同一块的副本可能包含不同的数据，可能包括相同记录的全部或部分副本。GFS不保证所有副本在字节方面都是相同的。它只保证数据作为一个原子单元至少写入一次。这个属性很容易从一个简单的观察中得出，即为了使操作报告成功，数据必须在某个块的所有副本上以相同的偏移量写入。此外，在此之后，所有副本至少与记录结束一样长，因此任何未来的记录将被分配更高的偏移量或不同的块，即使不同的副本后来成为主副本。就我们的一致性保证而言，成功的记录追加操作写入数据的区域是定义的(因此是一致的)，而中间区域是不一致的(因此是未定义的)。我们的应用程序可以处理不一致的区域，正如我们在2.7.2节中讨论的那样。</p><h3 id="快照"><a class="markdownIt-Anchor" href="#快照"></a> 快照</h3><p>快照操作几乎是立即生成文件或目录树(“源”)的副本，同时最小化正在进行的更改的任何中断。我们的用户使用它来快速创建庞大数据集的分支副本(通常是这些副本的副本，递归地)，或者在实验可以稍后提交或回滚的更改之前检查当前状态。</p><p>像AFS一样，我们使用标准的写时复制技术来实现快照。当主服务器接收到快照请求时，它首先撤销即将快照的文件中所有未到期的租约。这确保了对这些块的任何后续写操作都需要与主服务器进行交互才能找到租约持有者。这将使主服务器有机会首先创建块的新副本。</p><p>在租约被撤销或过期后，主服务器将操作记录到磁盘。然后，它通过复制源文件或目录树的元数据，将此日志记录应用于其内存状态。新创建的快照文件指向与源文件相同的块。</p><p>在快照操作之后，客户端第一次想要写入块C时，它向主服务器发送一个请求以查找当前的租约持有者。主服务器注意到块C的引用计数大于1。它延迟响应客户端请求，而是选择一个新的块句柄C’。然后，它要求每个拥有当前C副本的chunkserver创建一个名为C '的新块。通过在与原始块服务器相同的chunkserver上创建新块，我们可以确保数据可以在本地复制，而不是通过网络复制(我们的磁盘的速度大约是100 Mb以太网链路的三倍)。从这一点来看，请求处理与任何块的处理没有什么不同:主服务器授予其中一个副本对新块C '的租约，并回复客户端，客户端可以正常写块，而不知道它刚刚从现有块中创建。</p><h2 id="master操作"><a class="markdownIt-Anchor" href="#master操作"></a> master操作</h2><p>主节点执行所有命名空间操作。此外，它管理整个系统的块副本:它做出放置决策，创建新的块和副本，并协调各种系统范围的活动以保持块完全复制，平衡所有块服务器之间的负载，并回收未使用的存储。我们现在讨论每一个主题。</p><h3 id="命名空间管理和锁"><a class="markdownIt-Anchor" href="#命名空间管理和锁"></a> 命名空间管理和锁</h3><p>许多主操作可能需要很长时间:例如，快照操作必须撤销快照覆盖的所有块的chunkserver租约。我们不希望在其他主操作运行时延迟它们。因此，我们允许多个操作处于活动状态，并在名称空间的区域上使用锁来确保正确的序列化。</p><p>与许多传统文件系统不同，GES没有列出该目录中所有文件的每个目录数据结构。它也不支持同一文件或目录的别名(即Unix术语中的硬链接或符号链接)。GFS逻辑上将其命名空间表示为将完整路径名映射到元数据的查找表。通过前缀压缩，这个表可以有效地在内存中表示。命名空间树中的每个节点(绝对文件名或绝对目录名)都有一个关联的读写锁。</p><p>每个主操作在运行前都会获取一组锁。通常，如果它涉及/d1/d2/…/dn/leaf，它将获取目录名/d1， /d1/d2，…，/d1/d2/…的读锁。/dn，并在完整的路径名/d1/d2/…/dn/leaf上设置读锁或写锁。注意，根据操作的不同，叶子可以是文件或目录。</p><p>现在我们将演示这种锁定机制如何防止在将/home/user快照到/save/user时创建/home/user/foo文件。快照操作获取/home和/save上的读锁，/home/user和/save/user上的写锁。文件创建需要在/home和/home/user上获得读锁，在/home/user/foo上获得写锁。这两个操作将被正确序列化，因为它们试图在/home/user上获得冲突的锁。文件创建不需要在父目录上加写锁，因为没有类似于orinode的“目录”数据结构需要保护以免被修改。名称上的读锁足以保护父目录不被删除。</p><p>这种锁定方案的一个很好的特性是，它允许在同一目录中并发地进行修改。例如，可以在同一目录中并发地执行多个文件创建:每个文件都获得目录名上的读锁和文件名上的写锁。目录名上的读锁足以防止目录被删除、重命名或快照。文件名上的写锁序列化两次创建同名文件的尝试。</p><p>由于名称空间可以有许多节点，因此会惰性地分配读写锁对象，并在不使用时删除它们。此外，锁是按照一致的总顺序获取的，以防止死锁:它们首先在名称空间树中按级别排序，然后在同一级别内按字典顺序排序</p><h3 id="副本放置"><a class="markdownIt-Anchor" href="#副本放置"></a> 副本放置</h3><p>GFS集群在多个级别上高度分布。它通常有数百个块服务器分布在许多机器机架上。这些块服务器反过来可能被来自相同或不同轨道的数百个客户端访问。不同轨道上的两台机器之间的通信可以通过一个或多个网络交换机。此外，进出机架的带宽可能小于机架内所有机器的总带宽。多级分布对数据的可伸缩性、可靠性和可用性提出了独特的挑战。</p><p>块副本放置策略有两个目的:最大限度地提高数据的可靠性和可用性，最大限度地提高网络带宽利用率。对于这两种情况，将副本分散到机器上是不够的，这只能防止磁盘或机器故障，并充分利用每台机器的网络带宽。我们还必须跨机架散布块副本。这确保了即使整个机架损坏或故障(例如，由于网络交换机或电源电路等共享资源的故障)，块的一些副本仍然存在并保持可用。这也意味着数据块的流量，尤其是读取，可以利用多个机架的聚合带宽。另一方面，写流量必须流经多个机架，这是我们愿意做出的权衡。</p><h3 id="创建-重新复制-再平衡"><a class="markdownIt-Anchor" href="#创建-重新复制-再平衡"></a> 创建、重新复制、再平衡</h3><p>创建块副本有三个原因:块创建、重新复制和再平衡。</p><p>当主服务器创建一个块时，它选择在哪里放置最初的空副本。它考虑了几个因素:(1)我们希望将新的副本放置在磁盘空间利用率低于平均水平的块服务器上。(2)我们希望限制每个chunkserver上“最近”创建的数量，尽管创建本身很便宜，但它可靠地预测了即将到来的繁重写流量，因为块是在写请求时创建的，而在我们的“附加一次读多次”工作负载中，一旦它们被完全写入，它们通常实际上是只读的。(3)如上所述，我们希望在机架上分散块的副本。</p><p>只要可用副本的数量低于用户指定的目标，主服务器就会重新复制一个块。发生这种情况的原因有很多:块服务器不可用，报告其副本可能损坏，其中一个磁盘因错误而禁用，或者复制目标增加。需要重新复制的每个块都基于几个因素进行优先级排序。一个是它离复制目标有多远。例如，我们给予丢失两个副本的块比只丢失一个副本的块更高的优先级。此外，我们更倾向于首先为活文件重新复制块，而不是属于最近删除的文件的块(参见第4.4节)。最后，为了最小化故障对运行应用程序的影响，我们提高了阻塞客户端进程的任何块的优先级。</p><p>master选择优先级最高的块，并通过指示一些chunkserver直接从现有的有效副本复制块数据来“克隆”它。放置新副本的目标与创建副本的目标类似:均衡磁盘空间利用率，限制任何单个chunkserver上的活动克隆操作，以及跨机架分布副本。为了防止克隆流量压倒客户端流量，主服务器限制了集群和每个块服务器的活动克隆操作的数量。此外，每个chunkserver通过限制对源chunkserver的读请求来限制它在每个克隆操作上花费的带宽量</p><p>最后，主服务器定期重新平衡副本:它检查当前副本分布并移动副本以获得更好的磁盘空间和负载平衡。此外，通过这个过程，主服务器逐渐填满一个新的chunkserver，而不是立即用新的块和随之而来的沉重的写流量淹没它。新副本的放置标准与上面讨论的相似。此外，主服务器还必须选择要删除的现有副本。通常，它倾向于删除空闲空间低于平均水平的块服务器上的那些块服务器，以便均衡磁盘空间使用。</p><h3 id="垃圾回收"><a class="markdownIt-Anchor" href="#垃圾回收"></a> 垃圾回收</h3><p>文件删除后，GFS不会立即回收可用的物理存储。它仅在文件和块级别的常规垃圾收集期间惰性地执行此操作。我们发现这种方法使系统更简单，更可靠。</p><h4 id="机制"><a class="markdownIt-Anchor" href="#机制"></a> 机制</h4><p>当应用程序删除一个文件时，主机会立即记录删除操作，就像其他更改一样。但是，不是立即回收资源，而是将文件重命名为包含删除时间戳的隐藏名称。在主服务器对文件系统名称空间进行常规扫描期间，如果这些隐藏文件存在超过三天(时间间隔是可配置的)，它将删除它们。在此之前，文件仍然可以在新的特殊名称下读取，并且可以通过将其重命名为正常名称来恢复删除。当从名称空间中删除隐藏文件时，将擦除其内存中的元数据。这有效地切断了它与所有块的链接。</p><p>在对块命名空间进行类似的常规扫描时，主服务器会识别孤立的块(即无法从任何文件访问的块)，并擦除这些块的元数据。在与主服务器定期交换的HeartBeat消息中，每个chunkserver报告它拥有的块的一个子集，主服务器用不再出现在主元数据中的所有块的标识进行回复。chunkserver可以自由地删除这些块的副本。</p><h4 id="讨论"><a class="markdownIt-Anchor" href="#讨论"></a> 讨论</h4><p>尽管分布式垃圾收集是一个难题，在编程语言的上下文中需要复杂的解决方案，但在我们的示例中它非常简单。我们可以很容易地识别所有对块的引用:它们位于由主服务器专门维护的文件到块的映射中。我们也可以很容易地识别所有的块副本:它们是每个块服务器上指定目录下的Linux文件。任何不为主机所知的副本都是“垃圾”。</p><p>与急于删除相比，垃圾收集存储回收方法有几个优点。首先，它在组件故障常见的大规模分布式系统中简单可靠。在一些块服务器上创建块可能会成功，而在其他块服务器上则不能，从而留下主服务器不知道存在的副本。副本删除消息可能会丢失，并且主服务器必须记住在失败时重新发送它们，无论是它自己的还是块服务器的。垃圾收集提供了一种统一且可靠的方式来清理任何已知无用的副本。其次，它将存储回收合并到主服务器的常规后台活动中，例如定期扫描名称-空间和与块服务器的握手。因此，它是分批完成的，成本是平摊的。此外，只有在主人相对自由的情况下才会这样做。对于需要及时关注的客户端请求，主服务器可以更迅速地作出响应。第三，回收存储的延迟提供了一个安全网，防止意外的、不可逆转的删除。</p><p>在我们的经验中，主要的缺点是，当存储空间很紧时，延迟有时会妨碍用户优化使用。重复创建和删除临时文件的应用程序可能无法立即重用存储。如果已删除的文件再次显式删除，我们通过加速存储回收来解决这些问题。我们还允许用户对名称空间的不同部分应用不同的复制和回收策略。例如，用户可以指定在某个目录树中存储文件中的所有块而不进行复制，并且任何被删除的文件将立即且不可撤销地从文件系统状态中删除。</p><h3 id="失效副本检测"><a class="markdownIt-Anchor" href="#失效副本检测"></a> 失效副本检测</h3><p>如果块服务器发生故障，并且在它关闭时错过了对块的更改，则块副本可能会过时。对于每个块，主服务器维护一个块版本号，以区分最新副本和过期副本。</p><p>每当主服务器授予一个块的新租约时，它都会增加块的版本号，并通知最新的副本。主服务器和这些副本都在它们的持久状态中记录新的版本号。这发生在任何客户机收到通知之前，因此在它可以开始向块写入之前。如果另一个副本当前不可用，则不会提高其块版本号。当chunkserver重新启动时，主服务器将检测到这个chunkserver有一个过时的副本，并报告它的块集及其相关的版本号。如果主服务器看到的版本号大于其记录中的版本号，则主服务器认为它在授予租约时失败，因此采用较高的版本作为最新版本。</p><p>主服务器在其常规垃圾收集中删除过时的副本。在此之前，当它应答客户端请求块信息时，它有效地认为陈旧的副本根本不存在。作为另一种保护措施，当主服务器通知客户端哪个chunkserver持有某个块的租约，或者在克隆操作中指示一个chunkserver从另一个chunkserver读取该块时，主服务器包含了块的版本号。客户端或块服务器在执行操作时验证版本号，以便始终访问最新的数据。</p><h2 id="容错与诊断"><a class="markdownIt-Anchor" href="#容错与诊断"></a> 容错与诊断</h2><p>我们在设计系统时面临的最大挑战之一是处理频繁的组件故障。部件的质量和数量加在一起，使这些问题成为常态，而不是例外:我们不能完全相信机器，也不能完全相信磁盘。组件故障可能导致系统不可用，或者更糟的是数据损坏。我们将讨论如何应对这些挑战，以及我们在系统中内置的工具，以便在不可避免地出现问题时进行诊断。</p><h3 id="高可用"><a class="markdownIt-Anchor" href="#高可用"></a> 高可用</h3><p>在GFS集群中的数百台服务器中，某些服务器在任何给定时间都不可用。我们通过两种简单而有效的策略来保持整个系统的高可用性:快速恢复和复制</p><h4 id="快速恢复"><a class="markdownIt-Anchor" href="#快速恢复"></a> 快速恢复</h4><p>主服务器和chunkserver都被设计为重新存储它们的状态并在几秒钟内启动，无论它们如何终止。实际上，我们不区分正常终止和异常终止;服务器通常通过终止进程来关闭。客户机和其他服务器会遇到一个小问题，因为它们会超时处理未完成的请求，重新连接到重新启动的服务器，然后重试。第6.2.2节报告观察到的启动时间。</p><h4 id="块复制"><a class="markdownIt-Anchor" href="#块复制"></a> 块复制</h4><p>如前所述，每个块被复制到不同机架上的多个块服务器上。用户可以为文件命名空间的不同部分指定不同的复制级别。默认值是3。当chunkserver脱机或通过校验和验证检测损坏的副本时，主服务器根据需要克隆现有副本以保持每个块的完全复制(参见5.2节)。尽管复制已经为我们提供了很好的服务，但我们正在探索其他形式的跨服务器冗余，例如奇偶校验或擦除码，以满足我们不断增长的只读存储需求。我们预计，在我们非常松散耦合的系统中实现这些更复杂的冗余方案是具有挑战性的，但也是可以管理的，因为我们的流量主要是追加和读取，而不是小的随机写入。</p><h4 id="主节点复制"><a class="markdownIt-Anchor" href="#主节点复制"></a> 主节点复制</h4><p>复制主状态是为了提高可靠性。它的操作日志和检查点被复制到多台机器上。只有在其日志记录被刷新到本地磁盘和所有主副本上后，才认为状态的突变已提交。为简单起见，一个主进程仍然负责所有的突变以及在内部改变系统的后台活动，如垃圾收集。当它失败时，它几乎可以立即重新启动。如果它的机器或磁盘发生故障，监视GFS外部的基础设施就会在其他地方启动一个新的主进程，并使用复制的操作日志。客户端只使用主服务器的规范名称(例如gfs-test)，这是一个DNS别名，如果主服务器被重新定位到另一台机器上，则可以更改该别名。</p><p>此外，“影子”主服务器提供对文件系统的只读访问，即使主服务器关闭时也是如此。它们是影子，而不是镜子，因为它们可能会稍微落后于主光源，通常是几分之一秒。它们增强了没有主动变化的文件或不介意得到稍微陈旧的结果的应用程序的读可用性。实际上，由于文件内容是从chunkserver读取的，所以应用程序不会观察到过时的文件内容。在短窗口内可能过时的是文件元数据，如目录内容或访问控制信息。</p><p>为了保持自己的信息，一个shadowmaster读取一个不断增长的操作日志的副本，并将相同的更改顺序应用到它的数据结构中，就像primary所做的那样。与主服务器一样，它在启动时轮询块服务器(之后很少轮询)以定位块副本，并与它们频繁交换握手消息以监视它们的状态。它仅在由主服务器决定创建和删除副本而产生的副本位置更新时依赖于主服务器。</p><h3 id="数据完整性"><a class="markdownIt-Anchor" href="#数据完整性"></a> 数据完整性</h3><p>每个chunkserver使用校验和来检测存储数据的损坏。考虑到GFS集群通常在数百台机器上有数千个磁盘，它经常会遇到磁盘故障，导致读取和写入路径上的数据损坏或丢失。(原因之一见第7节。)我们可以使用其他块副本从损坏中恢复，但是通过比较跨块服务器的副本来检测损坏是不切实际的。此外，不同的副本可能是合法的:GFS突变的语义，特别是前面讨论的原子记录追加，不能保证相同的副本。因此，每个chunkserver必须通过维护校验和来独立地验证其副本的完整性。</p><p>一个块被分成64 KB的块。每个都有一个相应的32位校验和。与其他元数据一样，校验和保存在内存中，并使用日志进行持久存储。与用户数据分离。</p><p>对于读取，chunkserver在返回任何数据给请求者(无论是客户端还是另一个chunkserver)之前，验证与读取范围重叠的数据锁的校验和。因此，块服务器不会将损坏传播到其他机器。如果一个块与recordedchecksum不匹配，chunkserver返回一个错误给requestoland，并将不匹配报告给master。作为响应，请求者将从其他副本读取数据，而主服务器将从另一个副本克隆数据块。在一个有效的newreplica到位之后，master指示报告不匹配的chunkserver删除它的副本。</p><p>校验和对读性能的影响很小，原因如下。由于我们的大多数读取至少跨越几个块，因此我们只需要读取和校验相对少量的额外数据以进行验证。GES客户端代码通过尝试在校验和块边界上对齐读取来进一步减少这种开销。此外，chunkserver上的校验和查找和比较不需要任何io，校验和计算通常可以与io重叠。</p><p>校验和计算在很大程度上优化了附加到块末尾的写操作(而不是覆盖现有数据的写操作)，因为它们在我们的工作负载中占主导地位。我们只是增量地更新最后一个部分校验和块的校验和，并为任何由追加部分填充的全新校验和块计算新的校验和。即使最后的部分校验和块已经损坏，我们现在也无法检测到它，新的校验和值将与存储的数据不匹配，并且在下次读取块时将像往常一样检测到损坏。</p><p>相反，如果写操作覆盖了块的现有范围，我们必须读取并验证被覆盖范围的第一个和最后一个块，然后执行写操作，最后计算并记录新的校验和。如果我们在部分覆盖第一个和最后一个块之前不验证它们，那么新的校验和可能会隐藏存在于未被覆盖的区域中的损坏。</p><p>在空闲期间，chunkserver可以扫描和验证非活动块的内容。这允许我们检测很少被读取的块中的损坏。一旦检测到损坏，主服务器就可以创建一个新的未损坏的副本，并删除损坏的副本。这可以防止不活动但损坏的块副本欺骗主服务器，使其认为它有足够的有效块副本。</p><h3 id="诊断工具"><a class="markdownIt-Anchor" href="#诊断工具"></a> 诊断工具</h3><p>广泛而详细的诊断日志记录在问题隔离、调试和性能分析方面提供了显著的帮助，同时只产生最小的成本。如果没有日志，就很难理解机器之间短暂的、不可重复的交互。GFS服务器生成诊断日志，这些日志记录了许多重要事件(例如chunkserver上升和下降)以及所有RPC请求和应答。这些诊断日志可以随意删除，不会影响系统的正确性。然而，我们尽量在空间允许的范围内保留这些日志。</p><p>RPC日志包括在网络上发送的准确的请求和响应，但正在读取或写入的文件数据除外。通过将请求与应答进行匹配并整理不同机器上的RPC记录，我们可以重建整个交互历史以诊断问题。日志还可以作为负载测试和性能分析的跟踪。</p><p>日志记录对性能的影响很小(而且远远超过了它的好处)，因为这些日志是按顺序异步写入的。最近的事件也保存在内存中，可用于连续在线监视。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>Google文件系统展示了在商品硬件上支持大规模数据处理工作负载所必需的质量。虽然有些设计决策是特定于我们独特的环境，但许多设计决策可能适用于类似规模和成本意识的数据处理任务。</p><p>我们首先根据当前和预期的应用程序工作负载和技术环境重新检查传统的文件系统假设。我们的观察导致了设计空间中完全不同的观点。我们将组件故障视为常态，而不是异常，优化主要追加(可能并发)然后读取(通常顺序)的大文件，扩展和放松标准文件系统接口，以改进整个系统。</p><p>我们的系统通过持续监控、复制关键数据和快速自动恢复提供容错功能。块复制允许我们容忍块服务器故障。这些故障的频率激发了一种新的在线修复机制，该机制定期和透明地修复损坏并尽快补偿丢失的副本。此外，我们使用校验和来检测磁盘或IDE子系统级别的数据损坏，鉴于系统中的磁盘数量，这种情况变得非常常见。</p><p>我们的设计为执行各种任务的许多并发读取器和写入器提供了高聚合吞吐量。我们通过分离文件系统控制(通过主服务器)和数据传输(直接在块服务器和客户端之间传递)来实现这一点。通过较大的块大小和块租约(将权限委托给数据突变中的主副本)，可以最大限度地减少主操作的参与。这使得一个简单的、集中式的主机不会成为瓶颈成为可能。我们相信，网络堆栈的改进将解除当前对单个客户端看到的写吞吐量的限制。</p><p>GFS已经成功地满足了我们的存储需求，并在Google内部广泛用作研发和生产数据处理的存储平台。它是一个重要的工具，使我们能够继续创新，并在整个网络的规模上解决问题。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>6.824</tag>
      
      <tag>分布式系统</tag>
      
      <tag>data storage</tag>
      
      <tag>容错</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>21st-March</title>
    <link href="/2024/03/21/21st-March/"/>
    <url>/2024/03/21/21st-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="滴滴面经"><a class="markdownIt-Anchor" href="#滴滴面经"></a> 滴滴面经</h1><h2 id="计网"><a class="markdownIt-Anchor" href="#计网"></a> 计网</h2><h3 id="键入网址到网页显示期间发生了什么"><a class="markdownIt-Anchor" href="#键入网址到网页显示期间发生了什么"></a> 键入网址到网页显示，期间发生了什么？</h3><h4 id="1http"><a class="markdownIt-Anchor" href="#1http"></a> 1.HTTP</h4><p>浏览器做的第一步工作就是解析URL</p><p><img src="../imgs/21st-March/3.jpg" alt="URL 解析" /></p><p>所以图中的长长的 URL 实际上是请求服务器里的文件资源。</p><p>对 <code>URL</code> 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。</p><p><img src="../imgs/21st-March/4.jpg" alt="HTTP 的消息格式" /></p><h4 id="2dns"><a class="markdownIt-Anchor" href="#2dns"></a> 2.DNS</h4><p>通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 <code>Web</code> 服务器。</p><p>但在发送之前，还有一项工作需要完成，那就是<strong>查询服务器域名对应的 IP 地址</strong>，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。</p><p>比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。</p><p>所以，有一种服务器就专门保存了 <code>Web</code> 服务器域名与 <code>IP</code> 的对应关系，它就是 <code>DNS</code> 服务器。</p><p>DNS 中的域名都是用<strong>句点</strong>来分隔的，比如 <code>www.server.com</code>，这里的句点代表了不同层次之间的<strong>界限</strong>。</p><p>在域名中，<strong>越靠右</strong>的位置表示其层级<strong>越高</strong>。</p><p>毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。</p><p>实际上域名最后还有一个点，比如 <code>www.server.com.</code>，这个最后的一个点代表根域名。</p><p>也就是，<code>.</code> 根域是在最顶层，它的下一层就是 <code>.com</code> 顶级域，再下面是 <code>server.com</code>。</p><p>所以域名的层级关系类似一个树状结构：</p><ul><li>根 DNS 服务器（.）</li><li>顶级域 DNS 服务器（.com）</li><li>权威 DNS 服务器（<a href="http://server.com">server.com</a>）</li></ul><ol><li>客户端首先会发出一个 DNS 请求，问 <a href="http://www.server.com">www.server.com</a> 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。</li><li>本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 <a href="http://www.server.com">www.server.com</a>，则它直接返回 IP 地址。如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 <a href="http://www.server.com">www.server.com</a> 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。</li><li>根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“<a href="http://www.server.com">www.server.com</a> 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”</li><li>本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 <a href="http://www.server.com">www.server.com</a> 的 IP 地址吗？”</li><li>顶级域名服务器说：“我给你负责 <a href="http://www.server.com">www.server.com</a> 区域的权威 DNS 服务器的地址，你去问它应该能问到”。</li><li>本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” <a href="http://server.com">server.com</a> 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。</li><li>权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。</li><li>本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。</li></ol><h4 id="3协议栈"><a class="markdownIt-Anchor" href="#3协议栈"></a> 3.协议栈</h4><p>从DNS中获取到IP之后，就可以把HTTP的传输工作交给操作系统中的协议栈</p><p>协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。</p><p><img src="../imgs/21st-March/7.jpg" alt="协议栈" /></p><p>应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作。</p><p>协议栈的下面一半是用 IP 协议控制网络包收发操作，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。</p><p>此外 IP 中还包括 <code>ICMP</code> 协议和 <code>ARP</code> 协议。</p><ul><li><code>ICMP</code> 用于告知网络包传送过程中产生的错误以及各种控制信息。</li><li><code>ARP</code> 用于根据 IP 地址查询相应的以太网 MAC 地址。</li></ul><p>IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。</p><h4 id="4tcp"><a class="markdownIt-Anchor" href="#4tcp"></a> 4.TCP</h4><p>HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议。</p><blockquote><p>TCP 包头格式</p></blockquote><p>我们先看看 TCP 报文头部的格式：</p><p><img src="../imgs/21st-March/8.jpg" alt="TCP 包头格式" /></p><p>首先，<strong>源端口号</strong>和<strong>目标端口</strong>号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。</p><p>接下来有包的<strong>序</strong>号，这个是为了解决包乱序的问题。</p><p>还有应该有的是<strong>确认号</strong>，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。</p><p>接下来还有一些<strong>状态位</strong>。例如 <code>SYN</code> 是发起一个连接，<code>ACK</code> 是回复，<code>RST</code> 是重新连接，<code>FIN</code> 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。</p><p>还有一个重要的就是<strong>窗口大小</strong>。TCP 要做<strong>流量控制</strong>，通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我。</p><blockquote><p>TCP 传输数据之前，要先三次握手建立连接</p></blockquote><p>在 HTTP 传输数据之前，首先需要 TCP 建立连接，TCP 连接的建立，通常称为<strong>三次握手</strong>。</p><p>这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。</p><p><img src="../imgs/21st-March/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png" alt="TCP 三次握手" /></p><ul><li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li><li>然后客户端主动发起连接 <code>SYN</code>，之后处于 <code>SYN-SENT</code> 状态。</li><li>服务端收到发起的连接，返回 <code>SYN</code>，并且 <code>ACK</code> 客户端的 <code>SYN</code>，之后处于 <code>SYN-RCVD</code> 状态。</li><li>客户端收到服务端发送的 <code>SYN</code> 和 <code>ACK</code> 之后，发送对 <code>SYN</code> 确认的 <code>ACK</code>，之后处于 <code>ESTABLISHED</code> 状态，因为它一发一收成功了。</li><li>服务端收到 <code>ACK</code> 的 <code>ACK</code> 之后，处于 <code>ESTABLISHED</code> 状态，因为它也一发一收了。</li></ul><p>所以三次握手目的是<strong>保证双方都有发送和接收的能力</strong>。</p><blockquote><p>TCP 报文生成</p></blockquote><p>TCP 协议里面会有两个端口，一个是浏览器监听的端口（通常是随机生成的），一个是 Web 服务器监听的端口（HTTP 默认端口号是 <code>80</code>， HTTPS 默认端口号是 <code>443</code>）。</p><p>在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。</p><p>至此，网络包的报文如下图。</p><p><img src="../imgs/21st-March/13.jpg" alt="TCP 层报文" /></p><h4 id="5ip"><a class="markdownIt-Anchor" href="#5ip"></a> 5.IP</h4><p>TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成<strong>网络包</strong>发送给通信对象。</p><blockquote><p>IP 包头格式</p></blockquote><p>我们先看看 IP 报文头部的格式：</p><p><img src="../imgs/21st-March/14.jpg" alt="IP 包头格式" /></p><p>在 IP 协议里面需要有<strong>源地址 IP</strong> 和 <strong>目标地址 IP</strong>：</p><ul><li>源地址IP，即是客户端输出的 IP 地址；</li><li>目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。</li></ul><p>因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的<strong>协议号</strong>，要填写为 <code>06</code>（十六进制），表示协议为 TCP。</p><blockquote><p>假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？</p></blockquote><p>当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。</p><p>这个时候就需要根据<strong>路由表</strong>规则，来判断哪一个网卡作为源地址 IP。</p><blockquote><p>IP 报文生成</p></blockquote><p>至此，网络包的报文如下图。</p><p><img src="../imgs/21st-March/17.jpg" alt="IP 层报文" /></p><h4 id="6两点传输-mac"><a class="markdownIt-Anchor" href="#6两点传输-mac"></a> 6.两点传输 —— MAC</h4><p>生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 <strong>MAC 头部</strong>。</p><blockquote><p>MAC 包头格式</p></blockquote><p>MAC 头部是以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息。</p><p><img src="../imgs/21st-March/18.jpg" alt="MAC 包头格式" /></p><p>在 MAC 包头里需要<strong>发送方 MAC 地址</strong>和<strong>接收方目标 MAC 地址</strong>，用于<strong>两点之间的传输</strong>。</p><p>一般在 TCP/IP 通信里，MAC 包头的<strong>协议类型</strong>只使用：</p><ul><li><code>0800</code> ： IP 协议</li><li><code>0806</code> ： ARP 协议</li></ul><blockquote><p>MAC 发送方和接收方如何确认?</p></blockquote><p><strong>发送方</strong>的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。</p><p><strong>接收方</strong>的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。</p><p>所以先得搞清楚应该把包发给谁，这个只要查一下<strong>路由表</strong>就知道了。在路由表中找到相匹配的条目，然后把包发给 <code>Gateway</code> 列中的 IP 地址就可以了。</p><blockquote><p>既然知道要发给谁，按如何获取对方的 MAC 地址呢？</p></blockquote><p>不知道对方 MAC 地址？不知道就喊呗。</p><p>此时就需要 <code>ARP</code> 协议帮我们找到路由器的 MAC 地址。</p><p><img src="../imgs/21st-March/19.jpg" alt="ARP 广播" /></p><p>ARP 协议会在以太网中以<strong>广播</strong>的形式，对以太网所有的设备喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。</p><p>然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。</p><p>如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。</p><blockquote><p>好像每次都要广播获取，这不是很麻烦吗？</p></blockquote><p>放心，在后续操作系统会把本次查询结果放到一块叫做 <strong>ARP 缓存</strong>的内存空间留着以后用，不过缓存的时间就几分钟。</p><p>也就是说，在发包时：</p><ul><li>先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。</li><li>而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。</li></ul><blockquote><p>MAC 报文生成</p></blockquote><p>至此，网络包的报文如下图。</p><p><img src="../imgs/21st-March/21.jpg" alt="MAC 层报文" /></p><h4 id="7出口-网卡"><a class="markdownIt-Anchor" href="#7出口-网卡"></a> 7.出口 —— 网卡</h4><p>网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方。因此，我们需要将<strong>数字信息转换为电信号</strong>，才能在网线上传输，也就是说，这才是真正的数据发送过程。</p><p>负责执行这一操作的是<strong>网卡</strong>，要控制网卡还需要靠<strong>网卡驱动程序</strong>。</p><p>网卡驱动获取网络包之后，会将其<strong>复制</strong>到网卡内的缓存区中，接着会在其<strong>开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列</strong>。</p><p><img src="../imgs/21st-March/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png" alt="数据包" /></p><h4 id="8送别者-交换机"><a class="markdownIt-Anchor" href="#8送别者-交换机"></a> 8.送别者 —— 交换机</h4><p>下面来看一下包是如何通过交换机的。交换机的设计是将网络包<strong>原样</strong>转发到目的地。交换机工作在 MAC 层，也称为<strong>二层网络设备</strong>。</p><blockquote><p>交换机的包接收操作</p></blockquote><p>首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块将电信号转换为数字信号。</p><p>然后通过包末尾的 <code>FCS</code> 校验错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。</p><p>计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中。因此，和网卡不同，<strong>交换机的端口不具有 MAC 地址</strong>。</p><p>将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。</p><p>交换机的 MAC 地址表主要包含两个信息：</p><ul><li>一个是设备的 MAC 地址，</li><li>另一个是该设备连接在交换机的哪个端口上。</li></ul><p><img src="../imgs/21st-March/23.jpg" alt="交换机的 MAC 地址表" /></p><p>举个例子，如果收到的包的接收方 MAC 地址为 <code>00-02-B3-1C-9C-F9</code>，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 <code>3</code> 号端口上，然后就可以通过交换电路将包发送到相应的端口了。</p><p>所以，<strong>交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口</strong>。</p><blockquote><p>当 MAC 地址表找不到指定的 MAC 地址会怎么样？</p></blockquote><p>地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。</p><p>这种情况下，交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包。</p><p>这样做不会产生什么问题，因为以太网的设计本来就是将包发送到整个网络的，然后<strong>只有相应的接收者才接收包，而其他设备则会忽略这个包</strong>。</p><p>有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”</p><p>其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。</p><p>局域网中每秒可以传输上千个包，多出一两个包并无大碍。</p><p>此外，如果接收方 MAC 地址是一个<strong>广播地址</strong>，那么交换机会将包发送到除源端口之外的所有端口。</p><p>以下两个属于广播地址：</p><ul><li>MAC 地址中的 <code>FF:FF:FF:FF:FF:FF</code></li><li>IP 地址中的 <code>255.255.255.255</code></li></ul><h2 id="出境大门-路由器"><a class="markdownIt-Anchor" href="#出境大门-路由器"></a> 出境大门 —— 路由器</h2><blockquote><p>路由器与交换机的区别</p></blockquote><p>网络包经过交换机之后，现在到达了<strong>路由器</strong>，并在此被转发到下一个路由器或目标设备。</p><p>这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。</p><p>不过在具体的操作过程上，路由器和交换机是有区别的。</p><ul><li>因为<strong>路由器</strong>是基于 IP 设计的，俗称<strong>三层</strong>网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；</li><li>而<strong>交换机</strong>是基于以太网设计的，俗称<strong>二层</strong>网络设备，交换机的端口不具有 MAC 地址。</li></ul><blockquote><p>路由器基本原理</p></blockquote><p>路由器的端口具有 MAC 地址，因此它就能够成为以太网的发送方和接收方；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。</p><p>当转发包时，首先路由器端口会接收发给自己的以太网包，然后<strong>路由表</strong>查询转发目标，再由相应的端口作为发送方将以太网包发送出去。</p><blockquote><p>路由器的包接收操作</p></blockquote><p>首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 <code>FCS</code> 进行错误校验。</p><p>如果没问题则检查 MAC 头部中的<strong>接收方 MAC 地址</strong>，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。</p><p>总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。</p><blockquote><p>查询路由表确定输出端口</p></blockquote><p>完成包接收操作之后，路由器就会<strong>去掉</strong>包开头的 MAC 头部。</p><p><strong>MAC 头部的作用就是将包送达路由器</strong>，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会<strong>被丢弃</strong>。</p><p>接下来，路由器会根据 MAC 头部后方的 <code>IP</code> 头部中的内容进行包的转发操作。</p><p>转发操作分为几个阶段，首先是查询<strong>路由表</strong>判断转发目标。</p><p><img src="../imgs/21st-March/24.jpg" alt="路由器转发" /></p><p>具体的工作流程根据上图，举个例子。</p><p>假设地址为 <code>10.10.1.101</code> 的计算机要向地址为 <code>192.168.1.100</code> 的服务器发送一个包，这个包先到达图中的路由器。</p><p>判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。</p><p>路由匹配和前面讲的一样，每个条目的子网掩码和 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。</p><p>如第二条目的子网掩码 <code>255.255.255.0</code> 与 <code>192.168.1.100</code> IP 做 <strong>&amp; 与运算</strong>后，得到结果是 <code>192.168.1.0</code> ，这与第二条目的目标地址 <code>192.168.1.0</code> 匹配，该第二条目记录就会被作为转发目标。</p><p>实在找不到匹配路由时，就会选择<strong>默认路由</strong>，路由表中子网掩码为 <code>0.0.0.0</code> 的记录表示「默认路由」。</p><blockquote><p>路由器的发送操作</p></blockquote><p>接下来就会进入包的<strong>发送操作</strong>。</p><p>首先，我们需要根据<strong>路由表的网关列</strong>判断对方的地址。</p><ul><li>如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，<strong>还未抵达终点</strong>，还需继续需要路由器转发。</li><li>如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明<strong>已抵达终点</strong>。</li></ul><p>知道对方的 IP 地址之后，接下来需要通过 <code>ARP</code> 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。</p><p>路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。</p><p>接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 <code>0800</code> （十六进制）表示 IP 协议。</p><p>网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。</p><p>发送出去的网络包会通过<strong>交换机</strong>到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。</p><p>接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。</p><h4 id="9服务器-与-客户端"><a class="markdownIt-Anchor" href="#9服务器-与-客户端"></a> 9.服务器 与 客户端</h4><p>数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，查看是否和服务器自己的 MAC 地址符合，符合就将包收起来。</p><p>接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。</p><p>于是，扒开 TCP 的头，里面有序列号，需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号。</p><p>于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。</p><p>服务器的 HTTP 进程看到，原来这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里。</p><p>HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。</p><p>穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。</p><p>最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。</p><p>客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！</p><p>于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！</p><p>最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。</p><h3 id="https如何防止中间人篡改报文的"><a class="markdownIt-Anchor" href="#https如何防止中间人篡改报文的"></a> Https如何防止中间人篡改报文的</h3><p>HTTPS 从协议上解决了 HTTP 时代的中间人攻击问题，但是 HTTPS 在用户主动信任了伪造证书的时候也会发生中间人攻击（比如早期的 12306 需要手动信任证书），HTTPS 中间人攻击流程如下：</p><ol><li>客户端用HTTPS连接服务器的443端口</li><li>服务器下发自己的数字证书给客户端</li><li>黑客劫持了服务器的真实证书，并伪造了一个假的证书给浏览器</li><li>浏览器可以发现得到的网站证书是假的，但是浏览器选择信任</li><li>浏览器生成随机对称密钥A，用伪造的证书中的公钥加密发往服务器</li><li>黑客同样可以劫持这个请求，得到浏览器的对称密钥A，从而能够监听或者篡改通信数据</li><li>黑客利用服务器的真实公钥讲客户端的对称密钥A加密发往服务器</li><li>服务器利用私钥解密这个对称密钥A之后与黑客通信</li><li>黑客利用对称密钥A解密服务器的数据，篡改之后利用对称密钥A加密发给客户端</li><li>客户端收到的数据已经是不安全的了</li></ol><h2 id="os"><a class="markdownIt-Anchor" href="#os"></a> OS</h2><h3 id="进程和线程区别引入go的gmp调度"><a class="markdownIt-Anchor" href="#进程和线程区别引入go的gmp调度"></a> 进程和线程区别–引入Go的GMP调度</h3><p>进程、线程和协程是计算机程序执行的三个不同层次。</p><p><strong>进程（Process）</strong>： 进程是操作系统进行资源分配和调度的基本单位，是一个独立运行的程序实体。每个进程拥有独立的内存空间、文件描述符、寄存器状态等资源。进程之间的资源是相互隔离的，因此进程间通信需要通过操作系统提供的特定机制（如管道、消息队列、共享内存等）进行。由于进程拥有独立的资源，所以进程间的切换和调度开销较大。</p><p><strong>线程（Thread）</strong>： 线程是操作系统调度执行的最小单位，是进程内的一个执行流。一个进程可以拥有多个线程，这些线程共享进程的资源（如内存空间、文件描述符等）。由于线程共享相同的资源，线程间通信相对简单，可以直接通过共享变量、锁等方式进行。线程相较于进程，上下文切换和调度开销较小。但多个线程并发执行时，需要处理好同步和互斥问题，以避免数据不一致或竞争条件。</p><p><strong>协程（Coroutine</strong>）： 协程是一种用户态的轻量级线程，它的调度和切换完全由程序控制，不依赖于操作系统的调度。协程之间共享线程的资源，因此协程间通信也可以通过共享变量、锁等方式进行。协程的优势在于能够轻松地实现高并发，因为协程切换和调度的开销非常小。协程适用于I/O密集型任务，通过异步I/O可以有效地提高程序的性能。</p><p><strong>联系</strong></p><ul><li>线程属于进程，多个线程共享进程的资源。一个进程可以包含多个线程，这些线程共同完成任务，提高程序的并发性。</li><li>协程属于线程，多个协程共享线程的资源。一个线程可以包含多个协程，这些协程协同完成任务，提高程序的性能。</li><li>进程、线程和协程在执行程序时，都需要面对同步、互斥和通信等问题。在实际应用中，可以根据需求和场景选择合适的执行实体来实现最优的性能和资源利用。</li></ul><h3 id="gmp模型"><a class="markdownIt-Anchor" href="#gmp模型"></a> GMP模型？</h3><h4 id="ggoroutine"><a class="markdownIt-Anchor" href="#ggoroutine"></a> G（goroutine）</h4><p>go语言中的协程goroutine的缩写，相当于操作系统中的进程控制块。其中存折goroutine的运行时栈信息，CPU的一些寄存器的值以及执行的函数指令等。sched字段保存了goroutine的上下文。goroutine切换的时候不同于线程有OS来负责这部分数据，而是由一个gobuf结构体来保存。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> g <span class="hljs-keyword">struct</span> &#123;<br>  stack       stack   <span class="hljs-comment">// 描述真实的栈内存，包括上下界</span><br><br>  m              *m     <span class="hljs-comment">// 当前的 m</span><br>  sched          gobuf   <span class="hljs-comment">// goroutine 切换时，用于保存 g 的上下文      </span><br>  param          unsafe.Pointer <span class="hljs-comment">// 用于传递参数，睡眠时其他 goroutine 可以设置 param，唤醒时该goroutine可以获取</span><br>  atomicstatus   <span class="hljs-type">uint32</span><br>  stackLock      <span class="hljs-type">uint32</span> <br>  goid           <span class="hljs-type">int64</span>  <span class="hljs-comment">// goroutine 的 ID</span><br>  waitsince      <span class="hljs-type">int64</span> <span class="hljs-comment">// g 被阻塞的大体时间</span><br>  lockedm        *m     <span class="hljs-comment">// G 被锁定只在这个 m 上运行</span><br>&#125;<br></code></pre></td></tr></table></figure><p>gobuf 保存了当前的栈指针，计数器，还有 g 自身，这里记录自身 g 的指针的目的是为了<strong>能快速的访问到 goroutine 中的信息</strong>。gobuf 的结构如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> gobuf <span class="hljs-keyword">struct</span> &#123;<br>    sp   <span class="hljs-type">uintptr</span><br>    pc   <span class="hljs-type">uintptr</span><br>    g    guintptr<br>    ctxt unsafe.Pointer<br>    ret  sys.Uintreg<br>    lr   <span class="hljs-type">uintptr</span><br>    bp   <span class="hljs-type">uintptr</span> <span class="hljs-comment">// for goEXPERIMENT=framepointer</span><br>&#125;<br></code></pre></td></tr></table></figure><p>M(Machine)</p><p>M代表一个操作系统的主线程，对内核级线程的封装，数量对应真实的 CPU 数。一个 M 直接关联一个 os 内核线程，用于执行 G。M 会优先从关联的 P 的本地队列中直接获取待执行的 G。M 保存了 M 自身使用的栈信息、当前正在 M上执行的 G 信息、与之绑定的 P 信息。</p><p>结构体 M 中，curg代表结构体M当前绑定的结构体 G ；g0 是带有调度栈的 goroutine，普通的 goroutine 的栈是在<strong>堆上</strong>分配的可增长的栈，但是 g0 的栈是 <strong>M 对应的线程</strong>的栈。与调度相关的代码，会先切换到该 goroutine 的栈中再执行。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> m <span class="hljs-keyword">struct</span> &#123;<br>    g0      *g     <span class="hljs-comment">// 带有调度栈的goroutine</span><br><br>    gsignal       *g         <span class="hljs-comment">// 处理信号的goroutine</span><br>    tls           [<span class="hljs-number">6</span>]<span class="hljs-type">uintptr</span> <span class="hljs-comment">// thread-local storage</span><br>    mstartfn      <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span><br>    curg          *g       <span class="hljs-comment">// 当前运行的goroutine</span><br>    caughtsig     guintptr <br>    p             puintptr <span class="hljs-comment">// 关联p和执行的go代码</span><br>    nextp         puintptr<br>    id            <span class="hljs-type">int32</span><br>    mallocing     <span class="hljs-type">int32</span> <span class="hljs-comment">// 状态</span><br><br>    spinning      <span class="hljs-type">bool</span> <span class="hljs-comment">// m是否out of work</span><br>    blocked       <span class="hljs-type">bool</span> <span class="hljs-comment">// m是否被阻塞</span><br>    inwb          <span class="hljs-type">bool</span> <span class="hljs-comment">// m是否在执行写屏蔽</span><br><br>    printlock     <span class="hljs-type">int8</span><br>    incgo         <span class="hljs-type">bool</span><br>    fastrand      <span class="hljs-type">uint32</span><br>    ncgocall      <span class="hljs-type">uint64</span>      <span class="hljs-comment">// cgo调用的总数</span><br>    ncgo          <span class="hljs-type">int32</span>       <span class="hljs-comment">// 当前cgo调用的数目</span><br>    park          note<br>    alllink       *m <span class="hljs-comment">// 用于链接allm</span><br>    schedlink     muintptr<br>    mcache        *mcache <span class="hljs-comment">// 当前m的内存缓存</span><br>    lockedg       *g <span class="hljs-comment">// 锁定g在当前m上执行，而不会切换到其他m</span><br>    createstack   [<span class="hljs-number">32</span>]<span class="hljs-type">uintptr</span> <span class="hljs-comment">// thread创建的栈</span><br>&#125;<br></code></pre></td></tr></table></figure><p>P(Processor)</p><p>Processor 代表了 M 所需的上下文环境，代表 M 运行 G 所需要的资源。是处理用户级代码逻辑的处理器，可以将其看作一个局部调度器使 go 代码在一个线程上跑。当 P 有任务时，就需要创建或者唤醒一个系统线程来执行它队列里的任务，所以 P 和 M 是相互绑定的。P 可以根据实际情况开启协程去工作，它包含了运行 goroutine 的资源，如果线程想运行 goroutine，必须先获取 P，P 中还包含了可运行的 G 队列。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> p <span class="hljs-keyword">struct</span> &#123;<br>    lock mutex<br><br>    id          <span class="hljs-type">int32</span><br>    status      <span class="hljs-type">uint32</span> <span class="hljs-comment">// 状态，可以为pidle/prunning/...</span><br>    link        puintptr<br>    schedtick   <span class="hljs-type">uint32</span>     <span class="hljs-comment">// 每调度一次加1</span><br>    syscalltick <span class="hljs-type">uint32</span>     <span class="hljs-comment">// 每一次系统调用加1</span><br>    sysmontick  sysmontick <br>    m           muintptr   <span class="hljs-comment">// 回链到关联的m</span><br>    mcache      *mcache<br>    racectx     <span class="hljs-type">uintptr</span><br><br>    goidcache    <span class="hljs-type">uint64</span> <span class="hljs-comment">// goroutine的ID的缓存</span><br>    goidcacheend <span class="hljs-type">uint64</span><br><br>    <span class="hljs-comment">// 可运行的goroutine的队列</span><br>    runqhead <span class="hljs-type">uint32</span><br>    runqtail <span class="hljs-type">uint32</span><br>    runq     [<span class="hljs-number">256</span>]guintptr<br><br>    runnext guintptr <span class="hljs-comment">// 下一个运行的g</span><br><br>    sudogcache []*sudog<br>    sudogbuf   [<span class="hljs-number">128</span>]*sudog<br><br>    palloc persistentAlloc <span class="hljs-comment">// per-P to avoid mutex</span><br><br>    pad [sys.CacheLineSize]<span class="hljs-type">byte</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="gmp的调度流程"><a class="markdownIt-Anchor" href="#gmp的调度流程"></a> GMP的调度流程？</h4><p><img src="../imgs/21st-March/63e223e84757feff33526e36.jpg" alt="GMP调度" /></p><ul><li>每个P有个局部队列，局部队列保存待执行的goroutine，当M绑定的P的局部队列已经满了之后就会把就会把goroutine放到全局队列</li><li>每个P和一个M绑定，M是真正的执行P中goroutine的实体，M从绑定的P中的局部队列获取G来执行</li><li>当M绑定的P的局部队列为空时，M会从全局队列获取到本地队列来执行G，当从全局队列中没有获取到可执行的G时候，M会从其他P的局部队列中偷取G来执行，这种从其他P偷的方式称为work stealing</li><li>当G因系统调用阻塞时会阻塞M，此时P回合M解绑即hand off，并寻找新的idle的M，若没有idle的M就会新建一个M</li><li>当G因 channel 或者 network I/O 阻塞时，不会阻塞 M，M 会寻找其他 runnable 的 G；当阻塞的 G 恢复后会重新进入 runnable 进入 P 队列等待执行</li></ul><h2 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> Mysql</h2><h3 id="mysql索引的对比"><a class="markdownIt-Anchor" href="#mysql索引的对比"></a> MySQL索引的对比</h3><h4 id="怎样的索引的数据结构是好的"><a class="markdownIt-Anchor" href="#怎样的索引的数据结构是好的"></a> 怎样的索引的数据结构是好的？</h4><p>MySQL 的数据是持久化的，意味着数据（索引+记录）是保存到磁盘上的，因为这样即使设备断电了，数据也不会丢失。</p><p>磁盘是一个慢的离谱的存储设备，有多离谱呢？</p><p>人家内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的，也就是说读取同样大小的数据，磁盘中读取的速度比从内存中读取的速度要慢上万倍，甚至几十万倍。</p><p>磁盘读写的最小单位是<strong>扇区</strong>，扇区的大小只有 <code>512B</code> 大小，操作系统一次会读写多个扇区，所以<strong>操作系统的最小读写单位是块（Block）。Linux 中的块大小为 <code>4KB</code></strong>，也就是一次磁盘 I/O 操作会直接读写 8 个扇区。</p><p>由于数据库的索引是保存到磁盘上的，因此当我们通过索引查找某行数据的时候，就需要先从磁盘读取索引到内存，再通过索引从磁盘中找到某行数据，然后读入到内存，也就是说查询过程中会发生多次磁盘 I/O，而磁盘 I/O 次数越多，所消耗的时间也就越大。</p><p>所以，我们希望索引的数据结构能在尽可能少的磁盘的 I/O 操作中完成查询工作，因为磁盘 I/O 操作越少，所消耗的时间也就越小。</p><p>另外，MySQL 是支持范围查找的，所以索引的数据结构不仅要能高效地查询某一个记录，而且也要能高效地执行范围查找。</p><p>所以，要设计一个适合 MySQL 索引的数据结构，至少满足以下要求：</p><ul><li>能在尽可能少的磁盘的 I/O 操作中完成查询工作；</li><li>要能高效地查询某一个记录，也要能高效地执行范围查找；</li></ul><p>分析完要求后，我们针对每一个数据结构分析一下。</p><h4 id="二分查找树"><a class="markdownIt-Anchor" href="#二分查找树"></a> 二分查找树</h4><p>用数组来实现线性排序的数据虽然简单好用，但是插入新元素的时候性能太低。</p><p>因为插入一个元素，需要将这个元素之后的所有元素后移一位，如果这个操作发生在磁盘中呢？这必然是灾难性的。因为磁盘的速度比内存慢几十万倍，所以我们不能用一种线性结构将磁盘排序。</p><p>其次，有序的数组在使用二分查找的时候，每次查找都要不断计算中间的位置。</p><p><strong>二叉查找树的特点是一个节点的左子树的所有节点都小于这个节点，右子树的所有节点都大于这个节点</strong>，这样我们在查询数据时，不需要计算中间节点的位置了，只需将查找的数据与节点的数据进行比较。</p><p>假设，我们查找索引值为 key 的节点：</p><ol><li>如果 key 大于根节点，则在右子树中进行查找；</li><li>如果 key 小于根节点，则在左子树中进行查找；</li><li>如果 key 等于根节点，也就是找到了这个节点，返回根节点即可。</li></ol><p>另外，二叉查找树解决了插入新节点的问题，因为二叉查找树是一个跳跃结构，不必连续排列。这样在插入的时候，新节点可以放在任何位置，不会像线性结构那样插入一个元素，所有元素都需要向后排列。</p><p>因此，二叉查找树解决了连续结构插入新元素开销很大的问题，同时又保持着天然的二分结构。</p><p>那是不是二叉查找树就可以作为索引的数据结构了呢？</p><p>不行不行，二叉查找树存在一个极端情况，会导致它变成一个瘸子！</p><p><strong>当每次插入的元素都是二叉查找树中最大的元素，二叉查找树就会退化成了一条链表，查找数据的时间复杂度变成了 O(n)</strong></p><p>由于树是存储在磁盘中的，访问每个节点，都对应一次磁盘 I/O 操作（<em>假设一个节点的大小「小于」操作系统的最小读写单位块的大小</em>），也就是说<strong>树的高度就等于每次查询数据时磁盘 IO 操作的次数</strong>，所以树的高度越高，就会影响查询性能。</p><p>二叉查找树由于存在退化成链表的可能性，会使得查询操作的时间复杂度从 O(logn) 升为 O(n)。</p><p>而且会随着插入的元素越多，树的高度也变高，意味着需要磁盘 IO 操作的次数就越多，这样导致查询性能严重下降，再加上不能范围查询，所以不适合作为数据库的索引结构。</p><h4 id="自平衡二叉树"><a class="markdownIt-Anchor" href="#自平衡二叉树"></a> 自平衡二叉树</h4><p>为了解决二叉查找树会在极端情况下退化成链表的问题，后面就有人提出<strong>平衡二叉查找树（AVL 树）</strong>。</p><p>主要是在二叉查找树的基础上增加了一些条件约束：<strong>每个节点的左子树和右子树的高度差不能超过 1</strong>。也就是说节点的左子树和右子树仍然为平衡二叉树，这样查询操作的时间复杂度就会一直维持在 O(logn) 。</p><p>除了平衡二叉查找树，还有很多自平衡的二叉树，比如红黑树，它也是通过一些约束条件来达到自平衡，不过红黑树的约束条件比较复杂，不是本篇的重点重点，大家可以看《数据结构》相关的书籍来了解红黑树的约束条件。</p><p>下面是红黑树插入节点的过程，这左旋右旋的操作，就是为了自平衡。</p><p><img src="../imgs/21st-March/b2628d1248e41207a08871f7bfac3522.gif" alt="红黑树" /></p><p><strong>不管平衡二叉查找树还是红黑树，都会随着插入的元素增多，而导致树的高度变高，这就意味着磁盘 I/O 操作次数多，会影响整体数据查询的效率</strong>。</p><p>根本原因是因为它们都是二叉树，也就是每个节点只能保存 2 个子节点 ，如果我们把二叉树改成 M 叉树（M&gt;2）呢？</p><p>比如，当 M=3 时，在同样的节点个数情况下，三叉树比二叉树的树高要矮。</p><p>因此，<strong>当树的节点越多的时候，并且树的分叉数 M 越大的时候，M 叉树的高度会远小于二叉树的高度</strong>。</p><h4 id="b树"><a class="markdownIt-Anchor" href="#b树"></a> B树</h4><p>自平衡二叉树虽然能保持查询操作的时间复杂度在O(logn)，但是因为它本质上是一个二叉树，每个节点只能有 2 个子节点，那么当节点个数越多的时候，树的高度也会相应变高，这样就会增加磁盘的 I/O 次数，从而影响数据查询的效率。</p><p>为了解决降低树的高度的问题，后面就出来了 B 树，它不再限制一个节点就只能有 2 个子节点，而是允许 M 个子节点 (M&gt;2)，从而降低树的高度。</p><p>B 树的每一个节点最多可以包括 M 个子节点，M 称为 B 树的阶，所以 B 树就是一个多叉树。</p><p>假设 M = 3，那么就是一棵 3 阶的 B 树，特点就是每个节点最多有 2 个（M-1个）数据和最多有 3 个（M个）子节点，超过这些要求的话，就会分裂节点，</p><p>假设我们在上图一棵 3 阶的 B 树中要查找的索引值是 9 的记录那么步骤可以分为以下几步：</p><ol><li>与根节点的索引(4，8）进行比较，9 大于 8，那么往右边的子节点走；</li><li>然后该子节点的索引为（10，12），因为 9 小于 10，所以会往该节点的左边子节点走；</li><li>走到索引为9的节点，然后我们找到了索引值 9 的节点。</li></ol><p>可以看到，一棵 3 阶的 B 树在查询叶子节点中的数据时，由于树的高度是 3 ，所以在查询过程中会发生 3 次磁盘 I/O 操作。</p><p>而如果同样的节点数量在平衡二叉树的场景下，树的高度就会很高，意味着磁盘 I/O 操作会更多。所以，B 树在数据查询中比平衡二叉树效率要高。</p><p>但是 B 树的每个节点都包含数据（索引+记录），而用户的记录数据的大小很有可能远远超过了索引数据，这就需要花费更多的磁盘 I/O 操作次数来读到「有用的索引数据」。</p><p>而且，在我们查询位于底层的某个节点（比如 A 记录）过程中，「非 A 记录节点」里的记录数据会从磁盘加载到内存，但是这些记录数据是没用的，我们只是想读取这些节点的索引数据来做比较查询，而「非 A 记录节点」里的记录数据对我们是没用的，这样不仅增多磁盘 I/O 操作次数，也占用内存资源。</p><p>另外，如果使用 B 树来做范围查询的话，需要使用中序遍历，这会涉及多个节点的磁盘 I/O 问题，从而导致整体速度下降。</p><h4 id="b树-2"><a class="markdownIt-Anchor" href="#b树-2"></a> B+树</h4><p>B+ 树就是对 B 树做了一个升级，MySQL 中索引的数据结构就是采用了 B+ 树，B+ 树结构如下图：</p><p><img src="../imgs/21st-March/b6678c667053a356f46fc5691d2f5878.png" alt="B+树" /></p><p>B+ 树与 B 树差异的点，主要是以下这几点：</p><ul><li>叶子节点（最底部的节点）才会存放实际数据（索引+记录），非叶子节点只会存放索引；</li><li>所有索引都会在叶子节点出现，叶子节点之间构成一个有序链表；</li><li>非叶子节点的索引也会同时存在在子节点中，并且是在子节点中所有索引的最大（或最小）。</li><li>非叶子节点中有多少个子节点，就有多少个索引；</li></ul><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><h3 id="单链表反转acm模式"><a class="markdownIt-Anchor" href="#单链表反转acm模式"></a> 单链表反转（acm模式）</h3><p><img src="../imgs/21st-March/image-20240321221955244.png" alt="单链表反转" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br>    <span class="hljs-type">int</span> val;<br>    ListNode *next;<br>    <span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> _val): <span class="hljs-built_in">val</span>(_val),<span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>)&#123;&#125;;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">(ListNode* head)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span>(head) &#123;<br>        cout&lt;&lt;head-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>        head = head-&gt;next;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>&#125;<br><span class="hljs-function">ListNode* <span class="hljs-title">reverse</span><span class="hljs-params">(ListNode *head)</span> </span>&#123;<br>    ListNode* pre = <span class="hljs-literal">nullptr</span>,*cur = head;<br>    <span class="hljs-keyword">while</span>(cur) &#123;<br>        ListNode* temp = cur-&gt;next;<br>        cur-&gt;next = pre;<br>        pre = cur;<br>        cur = temp;<br>    &#125;<br>    <span class="hljs-keyword">return</span> pre;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n) &#123;<br>        <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) &#123;<br>            cout&lt;&lt;<span class="hljs-string">&quot;list is empty&quot;</span>&lt;&lt;endl;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        ListNode* dummyhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>        ListNode* cur = dummyhead;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>;i &lt; n; i++) &#123;<br>            <span class="hljs-type">int</span> x;<br>            cin&gt;&gt;x;<br>            cur-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(x);<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">print</span>(dummyhead-&gt;next);<br>        ListNode* rev = <span class="hljs-built_in">reverse</span>(dummyhead-&gt;next);<br>        <span class="hljs-built_in">print</span>(rev);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="最长公共子序列acm模式"><a class="markdownIt-Anchor" href="#最长公共子序列acm模式"></a> 最长公共子序列（acm模式）</h3><p><img src="../imgs/21st-March/image-20240321222257592.png" alt="最长公共子序列" /></p><p>主要是状态转移方程</p><p><img src="../imgs/21st-March/image-20240321230254740.png" alt="状态转移方程" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    string s1,s2;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;s1&gt;&gt;s2)&#123;<br>        <span class="hljs-type">int</span> n1 = s1.<span class="hljs-built_in">size</span>(),n2 = s2.<span class="hljs-built_in">size</span>();<br>        vector&lt;vector&lt;<span class="hljs-type">int</span>&gt;&gt; <span class="hljs-built_in">dp</span>(n1+<span class="hljs-number">1</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-type">int</span>&gt;(n2+<span class="hljs-number">1</span>,<span class="hljs-number">0</span>));<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;i &lt;= n1;i++) &#123;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> j = <span class="hljs-number">1</span>;j &lt;= n2;j++) &#123;<br>                <span class="hljs-keyword">if</span>(s1[i<span class="hljs-number">-1</span>] == s2[j<span class="hljs-number">-1</span>]) &#123;<br>                    dp[i][j] = dp[i<span class="hljs-number">-1</span>][j<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>                &#125;<span class="hljs-keyword">else</span> &#123;<br>                    dp[i][j] = <span class="hljs-built_in">max</span>(dp[i<span class="hljs-number">-1</span>][j],dp[i][j<span class="hljs-number">-1</span>]);<br>                &#125;<br>            &#125;<br>        &#125;<br>        cout&lt;&lt;dp[n1][n2]&lt;&lt;endl;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二叉树的高度"><a class="markdownIt-Anchor" href="#二叉树的高度"></a> 二叉树的高度</h3><p><img src="../imgs/21st-March/image-20240321232133046.png" alt="二叉树的高度" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;bits/stdc++.h&gt;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TreeNode</span> &#123;<br>    <span class="hljs-type">char</span> val;<br>    TreeNode* left;<br>    TreeNode* right;<br>    <span class="hljs-built_in">TreeNode</span>(<span class="hljs-type">char</span> val) : <span class="hljs-built_in">val</span>(val), <span class="hljs-built_in">left</span>(<span class="hljs-literal">nullptr</span>), <span class="hljs-built_in">right</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><span class="hljs-function">TreeNode* <span class="hljs-title">buildTree</span><span class="hljs-params">(string&amp; preorder,string&amp; inorder,<span class="hljs-type">int</span> preStart,<span class="hljs-type">int</span> inStart,<span class="hljs-type">int</span> inEnd,unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt;&amp; indexMap)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (preStart &gt; preorder.<span class="hljs-built_in">size</span>() - <span class="hljs-number">1</span> || inStart &gt; inEnd) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>    &#125;<br>    <br>    <span class="hljs-type">char</span> rootval = preorder[preStart];<br>    TreeNode *root= <span class="hljs-keyword">new</span> <span class="hljs-built_in">TreeNode</span>(rootval);<br>    <span class="hljs-type">int</span> rootIndex = indexMap[rootval];<br>    <br>    root-&gt;left = <span class="hljs-built_in">buildTree</span>(preorder,inorder,preStart+<span class="hljs-number">1</span>,inStart,rootIndex - <span class="hljs-number">1</span>,indexMap);<br>    root-&gt;right = <span class="hljs-built_in">buildTree</span>(preorder,inorder,preStart + rootIndex - inStart + <span class="hljs-number">1</span>,rootIndex + <span class="hljs-number">1</span>,inEnd,indexMap);<br><br>    <span class="hljs-keyword">return</span> root;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">getHeight</span><span class="hljs-params">(TreeNode* root)</span> </span>&#123;<br>    <span class="hljs-keyword">if</span> (root == <span class="hljs-literal">nullptr</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br><br>    <span class="hljs-type">int</span> leftHeight = <span class="hljs-built_in">getHeight</span>(root-&gt;left);<br>    <span class="hljs-type">int</span> rightHeight = <span class="hljs-built_in">getHeight</span>(root-&gt;right);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(leftHeight, rightHeight) + <span class="hljs-number">1</span>;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-keyword">while</span>(cin&gt;&gt;n) &#123;<br>        string preorder, inorder;<br>        cin &gt;&gt; preorder &gt;&gt; inorder;<br>        unordered_map&lt;<span class="hljs-type">char</span>, <span class="hljs-type">int</span>&gt; indexMap;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            indexMap[inorder[i]] = i;<br>        &#125;<br>        TreeNode* root = <span class="hljs-built_in">buildTree</span>(preorder, inorder, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, n<span class="hljs-number">-1</span>, indexMap);<br>        <span class="hljs-type">int</span> height = <span class="hljs-built_in">getHeight</span>(root);<br>        cout &lt;&lt; height &lt;&lt; <span class="hljs-string">&#x27;\n&#x27;</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>20th-March</title>
    <link href="/2024/03/20/20th-March/"/>
    <url>/2024/03/20/20th-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="每日八股"><a class="markdownIt-Anchor" href="#每日八股"></a> 每日八股</h1><h2 id="计网"><a class="markdownIt-Anchor" href="#计网"></a> 计网</h2><h3 id="http11-http2-http3演变"><a class="markdownIt-Anchor" href="#http11-http2-http3演变"></a> HTTP/1.1、HTTP/2、HTTP/3演变</h3><h4 id="http11-相比-http10提高了什么性能"><a class="markdownIt-Anchor" href="#http11-相比-http10提高了什么性能"></a> HTTP/1.1 相比 HTTP/1.0提高了什么性能？</h4><ul><li>使用长连接的方式改善了HTTP/1.0短连接造成的性能开销</li><li>支持管道网络运输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</li></ul><p>但HTTP/1.1还是有性能瓶颈：</p><ul><li>请求/响应头部（Header）未经压缩就发送，首部信息越多延迟越大。只能压缩<code>Body</code>的部分</li><li>发送冗长的首部。每次互相发送相同的首部造成的浪费较多</li><li>服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是队头阻塞</li><li>没有请求优先级控制</li><li>请求只能从客户端开始，服务器只能被动响应</li></ul><h4 id="http2做了什么优化"><a class="markdownIt-Anchor" href="#http2做了什么优化"></a> HTTP/2做了什么优化？</h4><p>HTTP/2协议是基于HTTPS的，所以HTTP/2的安全性也是有保障的。</p><ul><li>头部压缩</li><li>二进制格式</li><li>并发传输</li><li>服务器主动推送资源</li></ul><p>1.头部压缩</p><p>HTTP/2会压缩头，如果你同时发出多个请求，他们的头是一样的或是相似，那么，协议会帮你消除重复的部分。</p><p>这就是所谓的HPACK算法:在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送重复的字段了，只发送索引号，这样就提高速度了。</p><p>2.二进制格式</p><p>HTTP/2不再像HTTP/1.1里的纯文本形式的文本，而是全面采用了二进制格式，头信息和数据体都是二进制，并且统称为帧：头信息帧和数据帧</p><p>这样虽然对人不友好，但是对计算机非常友好，因为计算机只懂二进制，那么收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这<strong>增加了数据传输的效率</strong>。</p><p>比如状态码 200 ，在 HTTP/1.1 是用 ‘2’‘0’‘0’ 三个字符来表示（二进制：00110010 00110000 00110000），共用了 3 个字节，在 HTTP/2 对于状态码 200 的二进制编码是 10001000，只用了 1 字节就能表示，相比于 HTTP/1.1 节省了 2 个字节，</p><p>3.并发传输</p><p>我们都知道HTTP/1.1的实现是基于请求-响应模型的。同一个连接中，HTTP完成一个事务（请求与响应），才能处理下一个事务，也就是说在发出请求等待响应的过程中，是没办法做其他事情的，如果响应迟迟不来，那么后续的请求是无法发送的，也造成了对头阻塞的问题</p><p>而HTTP/2就引出了Stream概念，多个Stream复用在一条TCP连接</p><p><img src="../imgs/20th-March/stream.png" alt="Stream" /></p><p>从上图可以看到，1个TCP连接包含多个Stream，Stream里可以包含1个或多个Message，Message对应HTTP/1中的请求或响应，由HTTP头部和Body构成。Message里包含一条或者多个Frame，Frame是HTTP/2最小单位，以二进制压缩格式存放HTTP/1中的内容。</p><p>针对不同的HTTP请求用独一无二的Stream ID来区分，接收端可以通过Stream ID有序组装成HTTP消息，不同Stream的帧是可以乱序发送的，因此可以并发不同的Stream，也就是HTTP/2可以并行交错地发送请求和响应。</p><p>4.服务器推送</p><p>HTTP/2还在一定程度上改善了传统的请求-应答工作模式，服务端不再是被动地响应，可以主动向客户端发送信息。</p><p>客户端和服务器<strong>双方都可以建立 Stream</strong>， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p><h4 id="http2有什么缺陷"><a class="markdownIt-Anchor" href="#http2有什么缺陷"></a> HTTP/2有什么缺陷？</h4><p>HTTP/2通过Stream的并发能力，解决了HTTP1/1队头阻塞的问题，看似很完美了，但是HTTP/2还是存在“队头阻塞”的问题，不过是在TCP这一层。</p><p><strong>HTTP/2 是基于 TCP 协议来传输数据的，TCP 是字节流协议，TCP 层必须保证收到的字节数据是完整且连续的，这样内核才会将缓冲区里的数据返回给 HTTP 应用，那么当「前 1 个字节数据」没有到达时，后收到的字节数据只能存放在内核缓冲区里，只有等到这 1 个字节数据到达时，HTTP/2 应用层才能从内核中拿到数据，这就是 HTTP/2 队头阻塞问题。</strong></p><p><img src="../imgs/20th-March/tcp%E9%98%9F%E5%A4%B4%E9%98%BB%E5%A1%9E.gif" alt="TCP队头阻塞" /></p><p>图中发送方发送了很多个 packet，每个 packet 都有自己的序号，你可以认为是 TCP 的序列号，其中 packet 3 在网络中丢失了，即使 packet 4-6 被接收方收到后，由于内核中的 TCP 数据不是连续的，于是接收方的应用层就无法从内核中读取到，只有等到 packet 3 重传后，接收方的应用层才可以从内核中读取到数据，这就是 HTTP/2 的队头阻塞问题，是在 TCP 层面发生的。</p><p>所以，一旦发生了丢包现象，就会触发 TCP 的重传机制，这样在一个 TCP 连接中的<strong>所有的 HTTP 请求都必须等待这个丢了的包被重传回来</strong>。</p><h4 id="http3-做了哪些优化"><a class="markdownIt-Anchor" href="#http3-做了哪些优化"></a> HTTP/3 做了哪些优化？</h4><p>从TCP改成了UDP</p><p>UDP 发送是不管顺序，也不管丢包的，所以不会出现像 HTTP/2 队头阻塞的问题。大家都知道 UDP 是不可靠传输的，但基于 UDP 的 <strong>QUIC 协议</strong> 可以实现类似 TCP 的可靠性传输。</p><ul><li>无队头阻塞</li><li>更快的连接建立</li><li>连接迁移</li></ul><p>1.无队头阻塞</p><p>QUIC协议也有类似HTTP/2 Stream与多路复用的概念，也是可以在同一条连接上并发传输多个Stream，Stream可以认为就是一条HTTP请求。</p><p>QUIC有自己的一套机制可以保证传输的可靠性的。当某个流发生丢包时，只会阻塞这个流，其他流不会受到影响，因此不存在队头阻塞问题。这与HTTP/2不同，HTTP/2只要某个流中的数据包丢失了，其他流也会因此受影响。</p><p>所以，QUIC 连接上的多个 Stream 之间并没有依赖，都是独立的，某个流发生丢包了，只会影响该流，其他流不受影响。</p><p><img src="../imgs/20th-March/quic%E6%97%A0%E9%98%BB%E5%A1%9E.jpeg" alt="QUIC多路复用" /></p><p><img src="../imgs/20th-March/http2%E9%98%BB%E5%A1%9E.jpeg" alt="TCP队头阻塞" /></p><p>2.更快的连接建立</p><p>对于HTTP/1和HTTP/2协议，TCP和TLS是分层的，分别属于内核实现的传输层，openssl层库实现的表示层，因此它们难以合并在一起，需要分批次来我收，先TCP握手再TLS握手。</p><p>HTTP/3再传输数据前虽然需要QUIC协议握手，但是这个握手过程只需要1RTT，握手的目的是为确认双方的连接ID，连接迁移就是基于连接ID实现的。</p><p>但是HTTP/3的QUIC协议并不是与TLS分层，而是QUIC内部包含了TLS，它再自己的帧会携带TLS里的“记录”，再加上QUIC使用的是TLS/1.3，因此只需要1个RTT就可以同时完成建立连接与密钥协商</p><p><img src="../imgs/20th-March/28-HTTP3%E4%BA%A4%E4%BA%92%E6%AC%A1%E6%95%B0.jpeg" alt="TCP HTTPS（TLS/1.3） 和 QUIC HTTPS " /></p><p>3.连接迁移</p><p>基于TCP传输协议的HTTP协议，由于是通过四元组确定一条TCP连接。</p><p><img src="../imgs/20th-March/format,png-20230309231026577.png" alt="TCP 四元组" /></p><p>那么当移动设备的网络从4G切换到WIFI时，意味着IP地址变化了，那么久必须要断开连接，然后重新建立连接。而建立连接的过程包含 TCP 三次握手和 TLS 四次握手的时延，以及 TCP 慢启动的减速过程，给用户的感觉就是网络突然卡顿了一下，因此连接的迁移成本是很高的。</p><p>而 QUIC 协议没有用四元组的方式来“绑定”连接，而是通过<strong>连接 ID</strong> 来标记通信的两个端点，客户端和服务器可以各自选择一组 ID 来标记自己，因此即使移动设备的网络变化后，导致 IP 地址变化了，只要仍保有上下文信息（比如连接 ID、TLS 密钥等），就可以“无缝”地复用原连接，消除重连的成本，没有丝毫卡顿感，达到了<strong>连接迁移</strong>的功能。</p><p>所以， QUIC 是一个在 UDP 之上的<strong>伪</strong> TCP + TLS + HTTP/2 的多路复用的协议。</p><p>QUIC 是新协议，对于很多网络设备，根本不知道什么是 QUIC，只会当做 UDP，这样会出现新的问题，因为有的网络设备是会丢掉 UDP 包的，而 QUIC 是基于 UDP 实现的，那么如果网络设备无法识别这个是 QUIC 包，那么就会当作 UDP包，然后被丢弃。</p><h3 id="什么是tcp"><a class="markdownIt-Anchor" href="#什么是tcp"></a> 什么是TCP？</h3><p>TCP是面向连接的、可靠的、基于字节流的传输层通信协议</p><ul><li>面向连接：一定是一对一才能连接，不能像UDP协议可以一个主机同时向多个主机发送消息，也就是一对多是无法做到的</li><li>可靠的：无论网络链路中出现了怎样的链路变化，TCP都可以保证一个报文一定能够到达接收端</li><li>字节流：用户消息通过 TCP 协议传输时，消息可能会被操作系统「分组」成多个的 TCP 报文，如果接收方的程序如果不知道「消息的边界」，是无法读出一个有效的用户消息的。并且 TCP 报文是「有序的」，当「前一个」TCP 报文没有收到的时候，即使它先收到了后面的 TCP 报文，那么也不能扔给应用层去处理，同时对「重复」的 TCP 报文会自动丢弃。</li></ul><h3 id="udp和tcp有什么区别呢分别的应用场景是"><a class="markdownIt-Anchor" href="#udp和tcp有什么区别呢分别的应用场景是"></a> UDP和TCP有什么区别呢？分别的应用场景是？</h3><p>UDP不提供复杂的控制机制，利用IP提供面向无连接的通信服务。</p><ul><li>目标和源端口：主要是告诉UDP协议应该把报文发给哪个进程。</li><li>包长度：该字段保存了UDP首部的长度跟数据的长度之和</li><li>校验和：校验和是为了提供可靠的UDP首部和数据而设计，防止收到再网络传输中受损的UDP包</li></ul><p><img src="../imgs/20th-March/format,png-20230309230439961.png" alt="UDP 头部格式" /></p><p><img src="../imgs/20th-March/format,png-20230309230534096.png" alt="TCP 头格式" /></p><p>区别：</p><p>1.连接</p><ul><li>TCP是面向连接的传输层协议，传输数据前先要建立连接</li><li>UDP是不需要连接，即刻传输数据。</li></ul><p>2.服务对象</p><ul><li>TCP是一对一的两点服务，即一条连接只有两个端点</li><li>UDP支持一对一、一对多、多对多的交互通信</li></ul><p>3.可靠性</p><ul><li>TCP是可靠交付数据的，数据可以无差错、不丢失、不重复、按序到达。</li><li>UDP是尽最大努力交付，不保证可靠交付数据，但是可以基于UDP传输协议实现一个可靠的传输协议，比如QUIC协议</li></ul><p>4.拥塞控制，流量控制</p><ul><li>TCP由拥塞控制和流量控制机制，保证数据传输的安全性</li><li>UDP则没有，即使网络非常拥堵了，也不会影响UDP的发送速率。</li></ul><p>5.首部开销</p><ul><li>TCP首部长度较长，会有一定的开销，首部在没有使用选项时是20个字节，如果使用了选项字段则会变长的。</li><li>UDP首部只有8个字节，并且是固定不变的，开销较小</li></ul><ol start="6"><li>传输方式</li></ol><ul><li>TCP 是流式传输，没有边界，但保证顺序和可靠。</li><li>UDP 是一个包一个包的发送，是有边界的，但可能会丢包和乱序。</li></ul><p>7.分片不同</p><ul><li>TCP 的数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片。</li><li>UDP 的数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层。</li></ul><p><strong>TCP 和 UDP 应用场景：</strong></p><p>由于 TCP 是面向连接，能保证数据的可靠性交付，因此经常用于：</p><ul><li><code>FTP</code> 文件传输；</li><li>HTTP / HTTPS；</li></ul><p>由于 UDP 面向无连接，它可以随时发送数据，再加上 UDP 本身的处理既简单又高效，因此经常用于：</p><ul><li>包总量较少的通信，如 <code>DNS</code> 、<code>SNMP</code> 等；</li><li>视频、音频等多媒体通信；</li><li>广播通信；</li></ul><h3 id="tcp重传-流量控制-拥塞控制"><a class="markdownIt-Anchor" href="#tcp重传-流量控制-拥塞控制"></a> TCP重传、流量控制、拥塞控制</h3><p>TCP 实现可靠传输的方式之一，是通过序列号与确认应答。</p><p>在 TCP 中，当发送端的数据到达接收主机时，接收端主机会返回一个确认应答消息，表示已收到消息。</p><p>但在错综复杂的网络，并不一定能如上图那么顺利能正常的数据传输，万一数据在传输过程中丢失了呢？</p><p>所以 TCP 针对数据包丢失的情况，会用<strong>重传机制</strong>解决。</p><p>接下来说说常见的重传机制：</p><ul><li>超时重传</li><li>快速重传</li><li>SACK</li><li>D-SACK</li></ul><h3 id="超时重传"><a class="markdownIt-Anchor" href="#超时重传"></a> 超时重传</h3><p>重传机制的其中一个方式，就是在发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 <code>ACK</code> 确认应答报文，就会重发该数据，也就是我们常说的<strong>超时重传</strong>。</p><p>TCP 会在以下两种情况发生超时重传：</p><ul><li>数据包丢失</li><li>确认应答丢失</li></ul><p><img src="../imgs/20th-March/5.jpg" alt="超时重传的两种情况" /></p><p>超时触发重传存在的问题是，超时周期可能相对较长。那是不是可以有更快的方式呢？</p><p>于是就可以用「快速重传」机制来解决超时重发的时间等待。</p><h3 id=""><a class="markdownIt-Anchor" href="#"></a> <a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0">#</a>快速重传</h3><p>TCP 还有另外一种<strong>快速重传（Fast Retransmit）机制</strong>，它<strong>不以时间为驱动，而是以数据驱动重传</strong>。</p><p>快速重传机制，是如何工作的呢？其实很简单，一图胜千言。</p><p><img src="../imgs/20th-March/10.jpg" alt="快速重传机制" /></p><p>在上图，发送方发出了 1，2，3，4，5 份数据：</p><ul><li>第一份 Seq1 先送到了，于是就 Ack 回 2；</li><li>结果 Seq2 因为某些原因没收到，Seq3 到达了，于是还是 Ack 回 2；</li><li>后面的 Seq4 和 Seq5 都到了，但还是 Ack 回 2，因为 Seq2 还是没有收到；</li><li><strong>发送端收到了三个 Ack = 2 的确认，知道了 Seq2 还没有收到，就会在定时器过期之前，重传丢失的 Seq2。</strong></li><li>最后，收到了 Seq2，此时因为 Seq3，Seq4，Seq5 都收到了，于是 Ack 回 6 。</li></ul><p>所以，快速重传的工作方式是当收到三个相同的 ACK 报文时，会在定时器过期之前，重传丢失的报文段。</p><p>快速重传机制只解决了一个问题，就是超时时间的问题，但是它依然面临着另外一个问题。就是<strong>重传的时候，是重传一个，还是重传所有的问题。</strong></p><p>举个例子，假设发送方发了 6 个数据，编号的顺序是 Seq1 ~ Seq6 ，但是 Seq2、Seq3 都丢失了，那么接收方在收到 Seq4、Seq5、Seq6 时，都是回复 ACK2 给发送方，但是发送方并不清楚这连续的 ACK2 是接收方收到哪个报文而回复的， 那是选择重传 Seq2 一个报文，还是重传 Seq2 之后已发送的所有报文呢（Seq2、Seq3、 Seq4、Seq5、 Seq6） 呢？</p><ul><li>如果只选择重传 Seq2 一个报文，那么重传的效率很低。因为对于丢失的 Seq3 报文，还得在后续收到三个重复的 ACK3 才能触发重传。</li><li>如果选择重传 Seq2 之后已发送的所有报文，虽然能同时重传已丢失的 Seq2 和 Seq3 报文，但是 Seq4、Seq5、Seq6 的报文是已经被接收过了，对于重传 Seq4 ～Seq6 折部分数据相当于做了一次无用功，浪费资源。</li></ul><p>可以看到，不管是重传一个报文，还是重传已发送的报文，都存在问题。</p><p>为了解决不知道该重传哪些 TCP 报文，于是就有 <code>SACK</code> 方法。</p><h3 id="sack-方法"><a class="markdownIt-Anchor" href="#sack-方法"></a> SACK 方法</h3><p>还有一种实现重传机制的方式叫：<code>SACK</code>（ Selective Acknowledgment）， <strong>选择性确认</strong>。</p><p>这种方式需要在 TCP 头部「选项」字段里加一个 <code>SACK</code> 的东西，它<strong>可以将已收到的数据的信息发送给「发送方」</strong>，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以<strong>只重传丢失的数据</strong>。</p><p>如下图，发送方收到了三次同样的 ACK 确认报文，于是就会触发快速重发机制，通过 <code>SACK</code> 信息发现只有 <code>200~299</code> 这段数据丢失，则重发时，就只选择了这个 TCP 段进行重复。</p><p><img src="../imgs/20th-March/11.jpg" alt="选择性确认" /></p><h3 id="duplicate-sack"><a class="markdownIt-Anchor" href="#duplicate-sack"></a> Duplicate SACK</h3><p>Duplicate SACK 又称 <code>D-SACK</code>，其主要<strong>使用了 SACK 来告诉「发送方」有哪些数据被重复接收了。</strong></p><p>下面举例两个栗子，来说明 <code>D-SACK</code> 的作用。</p><p><img src="../imgs/20th-March/12.jpg" alt="ACK 丢包" /></p><ul><li>「接收方」发给「发送方」的两个 ACK 确认应答都丢失了，所以发送方超时后，重传第一个数据包（3000 ~ 3499）</li><li><strong>于是「接收方」发现数据是重复收到的，于是回了一个 SACK = 3000~3500</strong>，告诉「发送方」 3000~3500 的数据早已被接收了，因为 ACK 都到了 4000 了，已经意味着 4000 之前的所有数据都已收到，所以这个 SACK 就代表着 <code>D-SACK</code>。</li><li>这样「发送方」就知道了，数据没有丢，是「接收方」的 ACK 确认报文丢了。</li></ul><p><img src="../imgs/20th-March/13.jpg" alt="网络延时" /></p><ul><li>数据包（1000~1499） 被网络延迟了，导致「发送方」没有收到 Ack 1500 的确认报文。</li><li>而后面报文到达的三个相同的 ACK 确认报文，就触发了快速重传机制，但是在重传后，被延迟的数据包（1000~1499）又到了「接收方」；</li><li><strong>所以「接收方」回了一个 SACK=1000~1500，因为 ACK 已经到了 3000，所以这个 SACK 是 D-SACK，表示收到了重复的包。</strong></li><li>这样发送方就知道快速重传触发的原因不是发出去的包丢了，也不是因为回应的 ACK 包丢了，而是因为网络延迟了。</li></ul><p>可见，<code>D-SACK</code> 有这么几个好处：</p><ol><li>可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了;</li><li>可以知道是不是「发送方」的数据包被网络延迟了;</li><li>可以知道网络中是不是把「发送方」的数据包给复制了;</li></ol><h2 id="流量控制"><a class="markdownIt-Anchor" href="#流量控制"></a> 流量控制</h2><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p><p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，<strong>TCP 提供一种机制可以让「发送方」根据「接收方」的实际接收能力控制发送的数据量，这就是所谓的流量控制。</strong></p><p>下面举个栗子，为了简单起见，假设以下场景：</p><ul><li>客户端是接收方，服务端是发送方</li><li>假设接收窗口和发送窗口相同，都为 <code>200</code></li><li>假设两个设备在整个传输过程中都保持相同的窗口大小，不受外界影响</li></ul><h2 id="拥塞控制"><a class="markdownIt-Anchor" href="#拥塞控制"></a> 拥塞控制</h2><blockquote><p>为什么要有拥塞控制呀，不是有流量控制了吗？</p></blockquote><p>前面的流量控制是避免「发送方」的数据填满「接收方」的缓存，但是并不知道网络的中发生了什么。</p><p>一般来说，计算机网络都处在一个共享的环境。因此也有可能会因为其他主机之间的通信使得网络拥堵。</p><p><strong>在网络出现拥堵时，如果继续发送大量数据包，可能会导致数据包时延、丢失等，这时 TCP 就会重传数据，但是一重传就会导致网络的负担更重，于是会导致更大的延迟以及更多的丢包，这个情况就会进入恶性循环被不断地放大…</strong></p><p>所以，TCP 不能忽略网络上发生的事，它被设计成一个无私的协议，当网络发送拥塞时，TCP 会自我牺牲，降低发送的数据量。</p><p>于是，就有了<strong>拥塞控制</strong>，控制的目的就是<strong>避免「发送方」的数据填满整个网络。</strong></p><p>为了在「发送方」调节所要发送数据的量，定义了一个叫做「<strong>拥塞窗口</strong>」的概念。</p><blockquote><p>什么是拥塞窗口？和发送窗口有什么关系呢？</p></blockquote><p><strong>拥塞窗口 cwnd</strong>是发送方维护的一个的状态变量，它会根据<strong>网络的拥塞程度动态变化的</strong>。</p><p>我们在前面提到过发送窗口 <code>swnd</code> 和接收窗口 <code>rwnd</code> 是约等于的关系，那么由于加入了拥塞窗口的概念后，此时发送窗口的值是swnd = min(cwnd, rwnd)，也就是拥塞窗口和接收窗口中的最小值。</p><p>拥塞窗口 <code>cwnd</code> 变化的规则：</p><ul><li>只要网络中没有出现拥塞，<code>cwnd</code> 就会增大；</li><li>但网络中出现了拥塞，<code>cwnd</code> 就减少；</li></ul><blockquote><p>那么怎么知道当前网络是否出现了拥塞呢？</p></blockquote><p>其实只要「发送方」没有在规定时间内接收到 ACK 应答报文，也就是<strong>发生了超时重传，就会认为网络出现了拥塞。</strong></p><blockquote><p>拥塞控制有哪些控制算法？</p></blockquote><p>拥塞控制主要是四个算法：</p><ul><li>慢启动</li><li>拥塞避免</li><li>拥塞发生</li><li>快速恢复</li></ul><h4 id="慢启动"><a class="markdownIt-Anchor" href="#慢启动"></a> 慢启动</h4><p>TCP在刚建立连接完成后，首先是有个慢启动的过程，这个慢启动的意思就是一点一点的提高发送数据包的数量如果一上来就发大量的数据，就是再给网络添堵。</p><p><strong>当发送方每收到一个 ACK，拥塞窗口 cwnd 的大小就会加 1。</strong></p><ul><li>连接建立完成后，一开始初始化 <code>cwnd = 1</code>，表示可以传一个 <code>MSS</code> 大小的数据。</li><li>当收到一个 ACK 确认应答后，cwnd 增加 1，于是一次能够发送 2 个</li><li>当收到 2 个的 ACK 确认应答后， cwnd 增加 2，于是就可以比之前多发2 个，所以这一次能够发送 4 个</li><li>当这 4 个的 ACK 确认到来的时候，每个确认 cwnd 增加 1， 4 个确认 cwnd 增加 4，于是就可以比之前多发 4 个，所以这一次能够发送 8 个。</li></ul><p>可以看出慢启动算法，发包的个数是<strong>指数性的增长</strong>。</p><blockquote><p>那慢启动涨到什么时候是个头呢？</p></blockquote><p>有一个叫慢启动门限 <code>ssthresh</code> （slow start threshold）状态变量。</p><ul><li>当 <code>cwnd</code> &lt; <code>ssthresh</code> 时，使用慢启动算法。</li><li>当 <code>cwnd</code> &gt;= <code>ssthresh</code> 时，就会使用「拥塞避免算法」。</li></ul><h4 id="拥塞避免算法"><a class="markdownIt-Anchor" href="#拥塞避免算法"></a> 拥塞避免算法</h4><p>前面说道，当拥塞窗口 <code>cwnd</code> 「超过」慢启动门限 <code>ssthresh</code> 就会进入拥塞避免算法。</p><p>一般来说 <code>ssthresh</code> 的大小是 <code>65535</code> 字节。</p><p>那么进入拥塞避免算法后，它的规则是：<strong>每当收到一个 ACK 时，cwnd 增加 1/cwnd。</strong></p><p>接上前面的慢启动的栗子，现假定 <code>ssthresh</code> 为 <code>8</code>：</p><ul><li>当 8 个 ACK 应答确认到来时，每个确认增加 1/8，8 个 ACK 确认 cwnd 一共增加 1，于是这一次能够发送 9 个 <code>MSS</code> 大小的数据，变成了<strong>线性增长。</strong></li></ul><p>所以，我们可以发现，拥塞避免算法就是将原本慢启动算法的指数增长变成了线性增长，还是增长阶段，但是增长速度缓慢了一些。</p><p>就这么一直增长着后，网络就会慢慢进入了拥塞的状况了，于是就会出现丢包现象，这时就需要对丢失的数据包进行重传。</p><p>当触发了重传机制，也就进入了「拥塞发生算法」。</p><h3 id="-2"><a class="markdownIt-Anchor" href="#-2"></a> <a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html#%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F">#</a>拥塞发生</h3><p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p><ul><li>超时重传</li><li>快速重传</li></ul><p>这两种使用的拥塞发送算法是不同的，接下来分别来说说。</p><blockquote><p>发生超时重传的拥塞发生算法</p></blockquote><p>当发生了「超时重传」，则就会使用拥塞发生算法。</p><p>这个时候，ssthresh 和 cwnd 的值会发生变化：</p><ul><li><code>ssthresh</code> 设为 <code>cwnd/2</code>，</li><li><code>cwnd</code> 重置为 <code>1</code> （是恢复为 cwnd 初始化值，我这里假定 cwnd 初始化值 1）</li></ul><p><img src="../imgs/20th-March/29.jpg" alt="拥塞发送 —— 超时重传" /></p><p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。这真是一旦「超时重传」，马上回到解放前。但是这种方式太激进了，反应也很强烈，会造成网络卡顿。</p><p>就好像本来在秋名山高速漂移着，突然来个紧急刹车，轮胎受得了吗。。。</p><blockquote><p>发生快速重传的拥塞发生算法</p></blockquote><p>还有更好的方式，前面我们讲过「快速重传算法」。当接收方发现丢了一个中间包的时候，发送三次前一个包的 ACK，于是发送端就会快速地重传，不必等待超时再重传。</p><p>TCP 认为这种情况不严重，因为大部分没丢，只丢了一小部分，则 <code>ssthresh</code> 和 <code>cwnd</code> 变化如下：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li><li>进入快速恢复算法</li></ul><h3 id="快速恢复"><a class="markdownIt-Anchor" href="#快速恢复"></a> 快速恢复</h3><p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p><p>正如前面所说，进入快速恢复之前，<code>cwnd</code> 和 <code>ssthresh</code> 已被更新了：</p><ul><li><code>cwnd = cwnd/2</code> ，也就是设置为原来的一半;</li><li><code>ssthresh = cwnd</code>;</li></ul><p>然后，进入快速恢复算法如下：</p><ul><li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li><li>重传丢失的数据包；</li><li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li><li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li></ul><p>快速恢复算法的变化过程如下图：</p><p><img src="../imgs/20th-March/%E6%8B%A5%E5%A1%9E%E5%8F%91%E7%94%9F-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0.drawio.png" alt="快速重传和快速恢复" /></p><h2 id="mysql"><a class="markdownIt-Anchor" href="#mysql"></a> Mysql</h2><h3 id="事务有哪些特性"><a class="markdownIt-Anchor" href="#事务有哪些特性"></a> 事务有哪些特性？</h3><p>事务是由MySQL的引擎来实现的，我们常见的InnoDB引擎它是支持事务的。</p><p>不过并不是所有的引擎都能支持事务，比如 MySQL 原生的 MyISAM 引擎就不支持事务，也正是这样，所以大多数 MySQL 的引擎都是用 InnoDB。</p><p>事务看起来感觉简单，但是要实现事务必须要遵守 4 个特性，分别如下：</p><ul><li>**原子性（Atomicity）：**一个事务中的所有操作，要么全部完成，要么全部不完成，不会结束在中间的某个环节，而且事务在执行过程中发生错误，会被回滚到事务开始前的状态。</li><li>**一致性（Consistency）：**是指事务操作前和操作后，数据满足完整性约束，数据库保持一致性状态。比如，用户 A 和用户 B 在银行分别有 800 元和 600 元，总共 1400 元，用户 A 给用户 B 转账 200 元，分为两个步骤，从 A 的账户扣除 200 元和对 B 的账户增加 200 元。一致性就是要求上述步骤操作后，最后的结果是用户 A 还有 600 元，用户 B 有 800 元，总共 1400 元，而不会出现用户 A 扣除了 200 元，但用户 B 未增加的情况（该情况，用户 A 和 B 均为 600 元，总共 1200 元）。</li><li><strong>隔离性（Isolation）</strong>：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致，因为多个事务同时使用相同的数据时，不会相互干扰，每个事务都有一个完整的数据空间，对其他并发事务是隔离的。也就是说，消费者购买商品这个事务，是不影响其他消费者购买的。</li><li><strong>持久性（Durability）</strong>：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><p>InnoDB 引擎通过什么技术来保证事务的这四个特性的呢？</p><ul><li>持久性是通过 redo log （重做日志）来保证的；</li><li>原子性是通过 undo log（回滚日志） 来保证的；</li><li>隔离性是通过 MVCC（多版本并发控制） 或锁机制来保证的；</li><li>一致性则是通过持久性+原子性+隔离性来保证；</li></ul><h2 id="并行事务会引发什么问题"><a class="markdownIt-Anchor" href="#并行事务会引发什么问题"></a> 并行事务会引发什么问题？</h2><p>MySQL 服务端是允许多个客户端连接的，这意味着 MySQL 会出现同时处理多个事务的情况。</p><p>那么<strong>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题</strong>。</p><p>接下来，通过举例子给大家说明，这些问题是如何发生的。</p><h3 id="-3"><a class="markdownIt-Anchor" href="#-3"></a> <a href="https://xiaolincoding.com/mysql/transaction/mvcc.html#%E8%84%8F%E8%AF%BB">#</a>脏读</h3><p><strong>如果一个事务「读到」了另一个「未提交事务修改过的数据」，就意味着发生了「脏读」现象。</strong></p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后再执行更新操作，如果此时事务 A 还没有提交事务，而此时正好事务 B 也从数据库中读取小林的余额数据，那么事务 B 读取到的余额数据是刚才事务 A 更新后的数据，即使没有提交事务。</p><p>因为事务 A 是还没提交事务的，也就是它随时可能发生回滚操作，<strong>如果在上面这种情况事务 A 发生了回滚，那么事务 B 刚才得到的数据就是过期的数据，这种现象就被称为脏读。</strong></p><h3 id="不可重复读"><a class="markdownIt-Anchor" href="#不可重复读"></a> 不可重复读</h3><p><strong>在一个事务内多次读取同一个数据，如果出现前后两次读到的数据不一样的情况，就意味着发生了「不可重复读」现象。</strong></p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库中读取小林的余额数据，然后继续执行代码逻辑处理，<strong>在这过程中如果事务 B 更新了这条数据，并提交了事务，那么当事务 A 再次读取该数据时，就会发现前后两次读到的数据是不一致的，这种现象就被称为不可重复读。</strong></p><h3 id="幻读"><a class="markdownIt-Anchor" href="#幻读"></a> 幻读</h3><p>在一个事务内多次查询某个符合查询条件的记录数量，如果出现前后两次查询到的记录数量不一样的情况，就意味着发生了幻读现象。</p><p>假设有 A 和 B 这两个事务同时在处理，事务 A 先开始从数据库查询账户余额大于 100 万的记录，发现共有 5 条，然后事务 B 也按相同的搜索条件也是查询出了 5 条记录。</p><p>接下来，事务 A 插入了一条余额超过 100 万的账号，并提交了事务，此时数据库超过 100 万余额的账号个数就变为 6。</p><p>然后事务 B 再次查询账户余额大于 100 万的记录，此时查询到的记录数量有 6 条，<strong>发现和前一次读到的记录数量不一样了，就感觉发生了幻觉一样，这种现象就被称为幻读。</strong></p><h2 id="事务的隔离级别有哪些"><a class="markdownIt-Anchor" href="#事务的隔离级别有哪些"></a> 事务的隔离级别有哪些？</h2><p>前面我们提到，当多个事务并发执行时可能会遇到「脏读、不可重复读、幻读」的现象，这些现象会对事务的一致性产生不同程序的影响。</p><ul><li>脏读：读到其他事务未提交的数据；</li><li>不可重复读：前后读取的数据不一致；</li><li>幻读：前后读取的记录数量不一致。</li></ul><p>SQL 标准提出了四种隔离级别来规避这些现象，隔离级别越高，性能效率就越低，这四个隔离级别如下：</p><ul><li><strong>读未提交（*read uncommitted*）</strong>，指一个事务还没提交时，它做的变更就能被其他事务看到；</li><li><strong>读提交（*read committed*）</strong>，指一个事务提交之后，它做的变更才能被其他事务看到；</li><li><strong>可重复读（*repeatable read*）</strong>，指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；</li><li><strong>串行化（*serializable* ）</strong>；会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；</li></ul><p>针对不同的隔离级别，并发事务时可能发生的现象也会不同。</p><ul><li>在「读未提交」隔离级别下，可能发生脏读、不可重复读和幻读现象；</li><li>在「读提交」隔离级别下，可能发生不可重复读和幻读现象，但是不可能发生脏读现象；</li><li>在「可重复读」隔离级别下，可能发生幻读现象，但是不可能脏读和不可重复读现象；</li><li>在「串行化」隔离级别下，脏读、不可重复读和幻读现象都不可能会发生。</li></ul><p>MySQL InnoDB 引擎的默认隔离级别虽然是「可重复读」，但是它很大程度上避免幻读现象（并不是完全解决了）解决的方案有两种：</p><ul><li>针对<strong>快照读</strong>（普通 select 语句），是<strong>通过 MVCC 方式解决了幻读</strong>，因为可重复读隔离级别下，事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，即使中途有其他事务插入了一条数据，是查询不出来这条数据的，所以就很好了避免幻读问题。</li><li>针对<strong>当前读</strong>（select … for update 等语句），是<strong>通过 next-key lock（记录锁+间隙锁）方式解决了幻读</strong>，因为当执行 select … for update 语句的时候，会加上 next-key lock，如果有其他事务在 next-key lock 锁范围内插入了一条记录，那么这个插入语句就会被阻塞，无法成功插入，所以就很好了避免幻读问题。</li></ul><h2 id="read-view-在-mvcc-里如何工作的"><a class="markdownIt-Anchor" href="#read-view-在-mvcc-里如何工作的"></a> Read View 在 MVCC 里如何工作的？</h2><p>我们需要了解两个知识：</p><ul><li>Read View 中四个字段作用；</li><li>聚簇索引记录中两个跟事务有关的隐藏列；</li></ul><p>那 Read View 到底是个什么东西？</p><p><img src="../imgs/20th-March/readview%E7%BB%93%E6%9E%84.drawio.png" alt="mvcc" /></p><p>Read View 有四个重要的字段：</p><ul><li>m_ids ：指的是在创建 Read View 时，当前数据库中「活跃事务」的<strong>事务 id 列表</strong>，注意是一个列表，<strong>“活跃事务”指的就是，启动了但还没提交的事务</strong>。</li><li>min_trx_id ：指的是在创建 Read View 时，当前数据库中「活跃事务」中事务 <strong>id 最小的事务</strong>，也就是 m_ids 的最小值。</li><li>max_trx_id ：这个并不是 m_ids 的最大值，而是<strong>创建 Read View 时当前数据库中应该给下一个事务的 id 值</strong>，也就是全局事务中最大的事务 id 值 + 1；</li><li>creator_trx_id ：指的是<strong>创建该 Read View 的事务的事务 id</strong>。</li></ul><p>知道了 Read View 的字段，我们还需要了解聚簇索引记录中的两个隐藏列。</p><p><img src="../imgs/20th-March/f595d13450878acd04affa82731f76c5.png" alt="隐藏列" /></p><p>对于使用 InnoDB 存储引擎的数据库表，它的聚簇索引记录中都包含下面两个隐藏列：</p><ul><li>trx_id，当一个事务对某条聚簇索引记录进行改动时，就会<strong>把该事务的事务 id 记录在 trx_id 隐藏列里</strong>；</li><li>roll_pointer，每次对某条聚簇索引记录进行改动时，都会把旧版本的记录写入到 undo 日志中，然后<strong>这个隐藏列是个指针，指向每一个旧版本记录</strong>，于是就可以通过它找到修改前的记录。</li></ul><p>在创建 Read View 后，我们可以将记录中的 trx_id 划分这三种情况：</p><p><img src="../imgs/20th-March/ReadView.drawio.png" alt="trx_id" /></p><p>一个事务去访问记录的时候，除了自己的更新记录总是可见之外，还有这几种情况：</p><ul><li>如果记录的 trx_id 值小于 Read View 中的 <code>min_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>前</strong>已经提交的事务生成的，所以该版本的记录对当前事务<strong>可见</strong>。</li><li>如果记录的 trx_id 值大于等于 Read View 中的 <code>max_trx_id</code> 值，表示这个版本的记录是在创建 Read View <strong>后</strong>才启动的事务生成的，所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id 值在 Read View 的<code>min_trx_id</code>和<code>max_trx_id</code>之间，需要判断 <code>trx_id</code> 是否在 m_ids 列表中：<ul><li>如果记录的 trx_id <strong>在</strong> <code>m_ids</code> 列表中，表示生成该版本记录的活跃事务依然活跃着（还没提交事务），所以该版本的记录对当前事务<strong>不可见</strong>。</li><li>如果记录的 trx_id <strong>不在</strong> <code>m_ids</code>列表中，表示生成该版本记录的活跃事务已经被提交，所以该版本的记录对当前事务<strong>可见</strong>。</li></ul></li></ul><p><strong>这种通过「版本链」来控制并发事务访问同一个记录时的行为就叫 MVCC（多版本并发控制）。</strong></p><h2 id="可重复读是如何工作的"><a class="markdownIt-Anchor" href="#可重复读是如何工作的"></a> 可重复读是如何工作的？</h2><p><strong>可重复读隔离级别是启动事务时生成一个 Read View，然后整个事务期间都在用这个 Read View</strong>。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，那这两个事务创建的 Read View 如下：</p><p><img src="../imgs/20th-March/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE-new.png" alt="可重复读ReadView" /></p><p>事务 A 和 事务 B 的 Read View 具体内容如下：</p><ul><li>在事务 A 的 Read View 中，它的事务 id 是 51，由于它是第一个启动的事务，所以此时活跃事务的事务 id 列表就只有 51，活跃事务的事务 id 列表中最小的事务 id 是事务 A 本身，下一个事务 id 则是 52。</li><li>在事务 B 的 Read View 中，它的事务 id 是 52，由于事务 A 是活跃的，所以此时活跃事务的事务 id 列表是 51 和 52，<strong>活跃的事务 id 中最小的事务 id 是事务 A</strong>，下一个事务 id 应该是 53。</li></ul><p>接着，在可重复读隔离级别下，事务 A 和事务 B 按顺序执行了以下操作：</p><ul><li>事务 B 读取小林的账户余额记录，读到余额是 100 万；</li><li>事务 A 将小林的账户余额记录修改成 200 万，并没有提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额还是 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取小林的账户余额记录，读到余额依然还是 100 万；</li></ul><p>事务 B 第一次读小林的账户余额记录，在找到记录后，它会先看这条记录的 trx_id，此时<strong>发现 trx_id 为 50，比事务 B 的 Read View 中的 min_trx_id 值（51）还小，这意味着修改这条记录的事务早就在事务 B 启动前提交过了，所以该版本的记录对事务 B 可见的</strong>，也就是事务 B 可以获取到这条记录。</p><p>接着，事务 A 通过 update 语句将这条记录修改了（还未提交事务），将小林的余额改成 200 万，这时 MySQL 会记录相应的 undo log，并以链表的方式串联起来，形成<strong>版本链</strong>，如下图：</p><p><img src="../imgs/20th-March/%E4%BA%8B%E5%8A%A1ab%E7%9A%84%E8%A7%86%E5%9B%BE2.png" alt="版本链" /></p><p>你可以在上图的「记录的字段」看到，由于事务 A 修改了该记录，以前的记录就变成旧版本记录了，于是最新记录和旧版本记录通过链表的方式串起来，而且最新记录的 trx_id 是事务 A 的事务 id（trx_id = 51）。</p><p>然后事务 B 第二次去读取该记录，<strong>发现这条记录的 trx_id 值为 51，在事务 B 的 Read View 的 min_trx_id 和 max_trx_id 之间，则需要判断 trx_id 值是否在 m_ids 范围内，判断的结果是在的，那么说明这条记录是被还未提交的事务修改的，这时事务 B 并不会读取这个版本的记录。而是沿着 undo log 链条往下找旧版本的记录，直到找到 trx_id 「小于」事务 B 的 Read View 中的 min_trx_id 值的第一条记录</strong>，所以事务 B 能读取到的是 trx_id 为 50 的记录，也就是小林余额是 100 万的这条记录。</p><p>最后，当事物 A 提交事务后，<strong>由于隔离级别时「可重复读」，所以事务 B 再次读取记录时，还是基于启动事务时创建的 Read View 来判断当前版本的记录是否可见。所以，即使事物 A 将小林余额修改为 200 万并提交了事务， 事务 B 第三次读取记录时，读到的记录都是小林余额是 100 万的这条记录</strong>。</p><h2 id="读提交是如何工作的"><a class="markdownIt-Anchor" href="#读提交是如何工作的"></a> 读提交是如何工作的？</h2><p><strong>读提交隔离级别是在每次读取数据时，都会生成一个新的 Read View</strong>。</p><p>也意味着，事务期间的多次读取同一条数据，前后两次读的数据可能会出现不一致，因为可能这期间另外一个事务修改了该记录，并提交了事务。</p><p>那读提交隔离级别是怎么工作呢？我们还是以前面的例子来聊聊。</p><p>假设事务 A （事务 id 为51）启动后，紧接着事务 B （事务 id 为52）也启动了，接着按顺序执行了以下操作：</p><ul><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 修改数据（还没提交事务），将小林的账户余额从 100 万修改成了 200 万；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 100 万；</li><li>事务 A 提交事务；</li><li>事务 B 读取数据（创建 Read View），小林的账户余额为 200 万；</li></ul><h2 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h2><h2 id="quicklist"><a class="markdownIt-Anchor" href="#quicklist"></a> quicklist</h2><p>在 Redis 3.0 之前，List 对象的底层数据结构是双向链表或者压缩列表。然后在 Redis 3.2 的时候，List 对象的底层改由 quicklist 数据结构实现。</p><p>其实 quicklist 就是「双向链表 + 压缩列表」组合，因为一个 quicklist 就是一个链表，而链表中的每个元素又是一个压缩列表。</p><p>在前面讲压缩列表的时候，我也提到了压缩列表的不足，虽然压缩列表是通过紧凑型的内存布局节省了内存开销，但是因为它的结构设计，如果保存的元素数量增加，或者元素变大了，压缩列表会有「连锁更新」的风险，一旦发生，会造成性能下降。</p><p>quicklist 解决办法，<strong>通过控制每个链表节点中的压缩列表的大小或者元素个数，来规避连锁更新的问题。因为压缩列表元素越少或越小，连锁更新带来的影响就越小，从而提供了更好的访问性能。</strong></p><h3 id="-4"><a class="markdownIt-Anchor" href="#-4"></a> <a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#quicklist-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">#</a>quicklist 结构设计</h3><p>quicklist 的结构体跟链表的结构体类似，都包含了表头和表尾，区别在于 quicklist 的节点是 quicklistNode。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklist</span> &#123;</span><br>    <span class="hljs-comment">//quicklist的链表头</span><br>    quicklistNode *head;      <span class="hljs-comment">//quicklist的链表头</span><br>    <span class="hljs-comment">//quicklist的链表尾</span><br>    quicklistNode *tail; <br>    <span class="hljs-comment">//所有压缩列表中的总元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> count;<br>    <span class="hljs-comment">//quicklistNodes的个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> len;       <br>    ...<br>&#125; quicklist;<br></code></pre></td></tr></table></figure><p>接下来看看，quicklistNode 的结构定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> &#123;</span><br>    <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">prev</span>;</span>     <span class="hljs-comment">//前一个quicklistNode</span><br>    <span class="hljs-comment">//下一个quicklistNode</span><br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">quicklistNode</span> *<span class="hljs-title">next</span>;</span>     <span class="hljs-comment">//后一个quicklistNode</span><br>    <span class="hljs-comment">//quicklistNode指向的压缩列表</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">char</span> *zl;              <br>    <span class="hljs-comment">//压缩列表的的字节大小</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> sz;                <br>    <span class="hljs-comment">//压缩列表的元素个数</span><br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count : <span class="hljs-number">16</span>;        <span class="hljs-comment">//ziplist中的元素个数 </span><br>    ....<br>&#125; quicklistNode;<br></code></pre></td></tr></table></figure><p>可以看到，quicklistNode 结构体里包含了前一个节点和下一个节点指针，这样每个 quicklistNode 形成了一个双向链表。但是链表节点的元素不再是单纯保存元素值，而是保存了一个压缩列表，所以 quicklistNode 结构体里有个指向压缩列表的指针 *zl。</p><p><img src="../imgs/20th-March/f46cbe347f65ded522f1cc3fd8dba549.png" alt="quicklist" /></p><p>在向 quicklist 添加一个元素的时候，不会像普通的链表那样，直接新建一个链表节点。而是会检查插入位置的压缩列表是否能容纳该元素，如果能容纳就直接保存到 quicklistNode 结构里的压缩列表，如果不能容纳，才会新建一个新的 quicklistNode 结构。</p><p>quicklist 会控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来规避潜在的连锁更新的风险，但是这并没有完全解决连锁更新的问题。</p><h2 id="listpack"><a class="markdownIt-Anchor" href="#listpack"></a> listpack</h2><p>quicklist 虽然通过控制 quicklistNode 结构里的压缩列表的大小或者元素个数，来减少连锁更新带来的性能影响，但是并没有完全解决连锁更新的问题。</p><p>因为 quicklistNode 还是用了压缩列表来保存元素，压缩列表连锁更新的问题，来源于它的结构设计，所以要想彻底解决这个问题，需要设计一个新的数据结构。</p><p>于是，Redis 在 5.0 新设计一个数据结构叫 listpack，目的是替代压缩列表，它最大特点是 listpack 中每个节点不再包含前一个节点的长度了，压缩列表每个节点正因为需要保存前一个节点的长度字段，就会有连锁更新的隐患。</p><p><strong>我看了 Redis 的 Github，在最新 6.2 发行版本中，Redis Hash 对象、ZSet 对象的底层数据结构的压缩列表还未被替换成 listpack，而 Redis 的最新代码（还未发布版本）已经将所有用到压缩列表底层数据结构的 Redis 对象替换成 listpack 数据结构来实现，估计不久将来，Redis 就会发布一个将压缩列表为 listpack 的发行版本</strong>。</p><h3 id="-5"><a class="markdownIt-Anchor" href="#-5"></a> <a href="https://xiaolincoding.com/redis/data_struct/data_struct.html#listpack-%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1">#</a>listpack 结构设计</h3><p>listpack 采用了压缩列表的很多优秀的设计，比如还是用一块连续的内存空间来紧凑地保存数据，并且为了节省内存的开销，listpack 节点会采用不同的编码方式保存不同大小的数据。</p><p>我们先看看 listpack 结构：</p><p><img src="../imgs/20th-March/4d2dc376b5fd68dae70d9284ae82b73a.png" alt="listpack结构" /></p><p>listpack 头包含两个属性，分别记录了 listpack 总字节数和元素数量，然后 listpack 末尾也有个结尾标识。图中的 listpack entry 就是 listpack 的节点了。</p><p>每个 listpack 节点结构如下：</p><p><img src="../imgs/20th-March/c5fb0a602d4caaca37ff0357f05b0abf.png" alt="listpack entry" /></p><p>主要包含三个方面内容：</p><ul><li>encoding，定义该元素的编码类型，会对不同长度的整数和字符串进行编码；</li><li>data，实际存放的数据；</li><li>len，encoding+data的总长度；</li></ul><p>可以看到，<strong>listpack 没有压缩列表中记录前一个节点长度的字段了，listpack 只记录当前节点的长度，当我们向 listpack 加入一个新元素的时候，不会影响其他节点的长度字段的变化，从而避免了压缩列表的连锁更新问题</strong>。</p><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><p><a href="https://www.nowcoder.com/practice/886370fe658f41b498d40fb34ae76ff9?tpId=295&amp;tqId=1377477&amp;ru=/exam/company&amp;qru=/ta/format-top101/question-ranking&amp;sourceUrl=%2Fexam%2Fcompany"><strong>链表中倒数最后k个结点</strong></a></p><p><img src="../imgs/20th-March/image-20240320214547723.png" alt="链表中倒数最后k个节点" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs C++"><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> &#123;<br> *<span class="hljs-type">int</span> val;<br> *<span class="hljs-keyword">struct</span> <span class="hljs-title class_">ListNode</span> *next;<br> *<span class="hljs-built_in">ListNode</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">val</span>(x), <span class="hljs-built_in">next</span>(<span class="hljs-literal">nullptr</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 代码中的类名、方法名、参数名已经指定，请勿修改，直接返回方法规定的值即可</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * </span><br><span class="hljs-comment">     * @param pHead ListNode类 </span><br><span class="hljs-comment">     * @param k int整型 </span><br><span class="hljs-comment">     * @return ListNode类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">ListNode* <span class="hljs-title">FindKthToTail</span><span class="hljs-params">(ListNode* pHead, <span class="hljs-type">int</span> k)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(pHead == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        ListNode* fast = pHead,*slow = pHead;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            fast = fast-&gt;next;<br>            <span class="hljs-keyword">if</span>(fast == <span class="hljs-literal">nullptr</span>&amp;&amp;i!=k<span class="hljs-number">-1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(fast) &#123;<br>            fast = fast-&gt;next;<br>            slow = slow-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> slow;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">int</span> n;<br>    cin&gt;&gt;n;<br>    ListNode* dummyhead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">-1</span>);<br>    ListNode* curr = dummyhead;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>        <span class="hljs-type">int</span> x;<br>        cin&gt;&gt;x;<br>        curr-&gt;next = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(x);<br>      curr = curr-&gt;next;<br>    &#125;<br>    Solution sol1;<br>    <span class="hljs-type">int</span> k;<br>    cin&gt;&gt;k;<br>    ListNode* ans = sol.<span class="hljs-built_in">FindKthToTail</span>(dummyhead-&gt;next,k);<br>    <span class="hljs-keyword">while</span>(ans) &#123;<br>        cout&lt;&lt;ans-&gt;val&lt;&lt;<span class="hljs-string">&quot; &quot;</span>;<br>      ans = ans-&gt;next;<br>    &#125;<br>    cout&lt;&lt;<span class="hljs-string">&#x27;\n&#x27;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="写在最后"><a class="markdownIt-Anchor" href="#写在最后"></a> 写在最后</h2><p>今天感觉体验还不错 但是不知道过没过 不过过了也得考虑去不去吧</p><p>周五字节 先抠八股和算法 周一美团 重点sql和算法 周二快手 重点看看824</p>]]></content>
    
    
    <categories>
      
      <category>八股</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>19th-March</title>
    <link href="/2024/03/19/19th-March/"/>
    <url>/2024/03/19/19th-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="面经"><a class="markdownIt-Anchor" href="#面经"></a> 面经</h1><p>刚好都是字节国际电商？ 估计问的就差不多，所以偷一下看看</p><h2 id="os"><a class="markdownIt-Anchor" href="#os"></a> OS</h2><h3 id="虚拟内存相关"><a class="markdownIt-Anchor" href="#虚拟内存相关"></a> 虚拟内存相关</h3><h4 id="内存虚拟化是什么有什么目的"><a class="markdownIt-Anchor" href="#内存虚拟化是什么有什么目的"></a> 内存虚拟化是什么，有什么目的？</h4><p>内存虚拟化是一种将物理内存资源抽象、管理和分配的技术。它允许将计算机的物理内存划分为独立的、隔离的虚拟内存块，每个虚拟内存块都有操作系统或虚拟机管理。内存虚拟化可以在多个层次实现，如硬件层、操作系统层或应用程序层。</p><p>目的：</p><ul><li>**资源隔离与共享：**内存虚拟化可以在不同的进程、应用程序或虚拟机之间隔离内存资源，从而提高系统的稳定性和安全性。同时，内存虚拟化还支持灵活地共享内存资源，以实现负载均衡和资源利用率最大化。</li><li>**易用性：**内存虚拟化简化了内存管理，使得程序员无需关注物理内存的具体细节。程序员可以专注于编写代码，而操作系统和硬件负责处理内存分配、回收等问题。</li><li>**容错和回复：**内存虚拟化有助于实现容错和故障恢复。当系统发生故障时，可以将虚拟内存的状态保存到磁盘上，然后再另一台计算机上恢复虚拟内存状态，以实现快速恢复（没太懂？）</li><li>**内存优化：**内存虚拟化支持一些内存优化技术，如按需分配、内存去重和内存压缩。这些技术可以提高内存资源的利用率，降低内存成本。</li><li>**进程保护：**每个进程都有自己的虚拟地址空间，这样就能防止一个进程意外或恶意的访问另一个进程的内存。提高系统的稳定性和安全性。</li></ul><h4 id="物理内存与虚拟内存的映射机制"><a class="markdownIt-Anchor" href="#物理内存与虚拟内存的映射机制"></a> 物理内存与虚拟内存的映射机制</h4><p>物理内存和虚拟内存的映射机制是计算机系统中实现内存虚拟化的关键技术。虚拟内存到物理内存的映射方式一般有分段和分页两种，由于分段机制内存碎片较多，常用的是分页机制。映射过程有内存管理单元（MMU）和操作系统共同完成。</p><ul><li><p>**分页机制：**在分页系统中，虚拟内存和物理内存都被划分为固定大小的单元，称为页。虚拟页的大小和物理页相同，通常为4KB或更大。分页系统的主要目的是将虚拟内存中的页映射到物理内存中的页。</p></li><li><p>**页表：**页表是一种数据结构，用于存储虚拟页到物理页的映射关系。每个进程都有自己的页表，由操作系统管理。页表中的每个条目包含一个虚拟页号和对应的物理页号。当CPU访问虚拟内存时，MMU会使用页表将虚拟地址转换为物理地址。</p></li><li><p>**地址转换：**虚拟地址通常由两部分组成：虚拟页号（VPN）和页内偏移（offset）。虚拟页号用于查找页表中相应的物理页号，而页内偏移表示在物理页中的具体位置。地址抓换过程如下：</p><ol><li>CPU生成一个虚拟地址</li><li>MMU从虚拟地址中提取虚拟页号和页内偏移</li><li>MMU使用VPN在页表中查找对应的物理页号（PPN）</li><li>MMU将物理页号与页内偏移组合成物理地址</li><li>CPU使用物理地址访问物理内存</li></ol></li><li><p>页面置换和缺页中断：当虚拟页尚未加载到物理内存时，发生页面缺失（page fault）。在这种情况下，操作系统需要从磁盘或其他存储设备中加载所需的虚拟页，并将其映射到物理内存。为了腾出空间，操作系统可能需要选择一个已加载的页面，将其换出到磁盘。页面置换算法用于决定哪个页面应该被换出</p></li><li><p>多级页表：多级页表使一种用于减少页表大小的技术。在具有大量虚拟地址空间的系统中，使用单级页表可能导致浪费大量内存。多级页表通过将虚拟地址空间划分为多个层次来减小页表的大小。每个层次都有自己的页表，只有在需要时才会分配。这样可以大大减小内存开销。</p></li><li><p>快表（TLB）：快表，也称为转换后援缓冲（Translation Lookaside Buffer），是一种硬件缓存，用于加速虚拟地址到物理地址的转换过程。TLB将最近使用过的虚拟地址到物理地址的映射存储在高速缓存中，以便快速查找。当MMU需要转换一个虚拟地址时，它首先检查TLB是否包含所需的映射。如何TLB中存在映射，MMU可以避免访问内存中的页表，从而加速地址转换过程。</p></li><li><p>内存分配策略：操作系统使用不同的内存分配策略来管理虚拟内存和物理内存之间的映射。按需分配是一种常用的策略，它旨在进程实际访问虚拟内存时才将虚拟页加载到物理内存。预取是另一种策略，它根据进程的访问模式提前加载可能需要的虚拟页，以减少页面缺失的开销。</p></li><li><p>内存共享：内存共享是一种允许多个进程访问相同物理内存区域的技术。通过将不同 进程的虚拟地址映射到同一物理页，操作系统可以实现内存共享。这种技术在共享库、进程间通信和内存去重等场景中非常有用。</p></li></ul><p>物理内存和虚拟内存的映射机制通过分页、页表、地址转换、多级页表、TLB、内存分配策略等技术实现。这种映射提供了内存虚拟化、进程隔离和内存优化等关键功能。</p><h3 id="进程"><a class="markdownIt-Anchor" href="#进程"></a> 进程</h3><h4 id="进程-线程-协程区别与联系"><a class="markdownIt-Anchor" href="#进程-线程-协程区别与联系"></a> 进程、线程、协程区别与联系</h4><p>进程、线程和协程是计算机程序执行的三个不同层次</p><p>**进程：**进程是操作系统进行资源分配和调度的基本单位，是一个独立运行的程序实体。每个进程拥有独立的内存空间、文件描述符、寄存器状态等资源。进程之间的资源是相互隔离的，因此进程间通信需要通过操作系统提供的特定机制（如管道、消息队列、共享内存等）进行。由于进程拥有独立的资源，所以进程间的切换调度开销较大</p><p>**线程：**线程是操作系统调度执行的最小单位，是进程内的一个执行流。一个进程可以拥有多个线程，这些线程共享进程的资源（如内存空间、文件描述符等）。由于线程共享相同的资源，线程间通信相对简单，可以直接通过共享变量、锁等方式进行。线程相较于进程，上下文切换和调度开销较小。但多个线程并行执行时，需要处理好同步和互斥问题，以避免数据不一致或竞争条件。</p><p>**协程：**协程是一种用户态的轻量级线程，它的调度和切换完全由程序控制，不依赖于操作系统的调度。协程之间共享线程的资源，因此协程间通信也可以通过共享变量、锁等方式进行。协程的优势在于可以轻松地实现高并发，因此协程切换和调度的开销非常小。协程适用于I/O密集型任务，通过异步I/O可以有效地提高程序的性能。</p><p><strong>联系</strong></p><ul><li>线程属于进程，多个线程共享进程的资源，一个进程可以包含多个线程，这些线程共同完成任务，提高程序的并发性。</li><li>协程属于线程，多个协程共享线程的资源。一个线程可以包含多个协程，这些协程共同完成任务，提高程序的并发性。</li><li>进程、线程和协程在执行程序时，都需要面对异步、互斥和通信等问题。在实际应用中，可以根据需求和场景选择合适的执行实体来实现最优的性能和资源利用。</li></ul><h2 id="计网"><a class="markdownIt-Anchor" href="#计网"></a> 计网</h2><h3 id="tcp的确认机制"><a class="markdownIt-Anchor" href="#tcp的确认机制"></a> TCP的确认机制</h3><p>1.确认的作用</p><p>TCP的确认机制用于确保数据的可靠传输。当接收端成功接收到一个数据包时，它会返回一个确认信号（ACK）给发送端。这个确认信号包含了接收端期望接受的下一个数据包的序号。发送端收到确认信号后，就知道之前发送的数据包已经被成功接收，并可以继续发送后续的数据包。</p><p>2.确认的实现方式</p><p>确认信号是通过TCP数据包中的ACK标志位来实现。当ACK标志位被设置为1时，表示该数据包时一个确认信号。确认信号中还包含一个32位的确认号字段，用于指示接收端期望接受的下一个数据包的序号。</p><h3 id="tcp流量控制"><a class="markdownIt-Anchor" href="#tcp流量控制"></a> TCP流量控制</h3><p>发送方不能无脑的发数据给接收方，要考虑接收方处理能力。</p><p>如果一直无脑的发数据给对方，但对方处理不过来，那么就会导致触发重发机制，从而导致网络流量的无端的浪费。</p><p>为了解决这种现象发生，TCP提供了一种机制可以让发送放根据接收方的实际接受能力控制发送的数据量，这就是所谓的流量控制。</p><p><img src="../imgs/19th-March/21.png" alt="流量控制" /></p><ol><li>客户端向服务端发送请求数据报文。</li><li>服务端收到请求报文后，发送确认报文和80字节的数据，于是可用窗口 <code>Usable</code> 减少为 120 字节，同时<code>SND.NXT</code>指针页向右偏移80字节，这意味着下次发送数据的时候，序列号时321.</li><li>客户端收到80字节数据后，于是接收窗口往右移动80字节，<code>RCV.NXT</code>也就指向321，这意味着客户端期望的下一个报文的序列号时321，接着发送确认报文给服务端。</li><li>服务端再次发送了120字节数据，于是可用窗口耗尽为0，服务端无法再继续发送数据。</li><li>客户端收到120字节的数据后，于是接收窗口往右移动 120 字节，<code>RCV.NXT</code> 也就指向 441，接着发送确认报文给服务端。</li><li>服务端收到对 80 字节数据的确认报文后，<code>SND.UNA</code> 指针往右偏移后指向 321，于是可用窗口 <code>Usable</code> 增大到 80。</li><li>服务端收到对 120 字节数据的确认报文后，<code>SND.UNA</code> 指针往右偏移后指向 441，于是可用窗口 <code>Usable</code> 增大到 200。</li><li>服务端可以继续发送了，于是发送了 160 字节的数据后，<code>SND.NXT</code> 指向 601，于是可用窗口 <code>Usable</code> 减少到 40。</li><li>客户端收到 160 字节后，接收窗口往右移动了 160 字节，<code>RCV.NXT</code> 也就是指向了 601，接着发送确认报文给服务端。</li><li>服务端收到对 160 字节数据的确认报文后，发送窗口往右移动了 160 字节，于是 <code>SND.UNA</code> 指针偏移了 160 后指向 601，可用窗口 <code>Usable</code> 也就增大至了 200。</li></ol><h3 id="https是如何建立连接的"><a class="markdownIt-Anchor" href="#https是如何建立连接的"></a> HTTPS是如何建立连接的？</h3><p>1.ClientHello</p><p>首先由客户端向服务器发起加密通信请求，也就是CLientHello请求。</p><p>在这一步，客户端主要向服务器发送以下信息：</p><ul><li>客户端支持的TLS协议版本</li><li>客户端产生的随机数，后面用于生成会话密钥条件之一</li><li>客户端支持的密码套件列表</li></ul><p>2。ServerHello</p><p>服务器收到客户端请求后，向客户端发出相应，主要内容</p><ul><li>确认TLS协议版本，如果浏览器不支持，则关闭加密通信</li><li>服务器生产的随机数，也就是后面用于生成会话密钥的条件之一</li><li>确认的密码套件列表</li><li>服务器的数字证书</li></ul><p>3.客户端回应</p><p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的CA公钥，确认服务器的数字证书的真实性。</p><p>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p><ul><li>一个随机数，会被服务器公钥加密</li><li>加密通信算法改变通知，表示随后信息都将用会话密钥加密通信</li><li>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</li></ul><p>上面第一项的随机数是整个握手阶段的第三个随机数，会发给服务端，所以这个随机数客户端和服务端都是一样的。</p><p>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」。</p><p>4.服务器的最后回应</p><p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p><p>然后，向客户端发送最后的信息：</p><p>（1）加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p><p>（2）服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</p><p>至此，整个 TLS 的握手阶段全部结束。接下来，客户端与服务器进入加密通信，就完全是使用普通的 HTTP 协议，只不过用「会话秘钥」加密内容。</p><h2 id="redis"><a class="markdownIt-Anchor" href="#redis"></a> Redis</h2><h3 id="zset底层原理"><a class="markdownIt-Anchor" href="#zset底层原理"></a> zset底层原理</h3><p>Zset 类型的底层数据结构是由<strong>压缩列表或跳表</strong>实现的：</p><ul><li>如果有序集合的元素个数小于 <code>128</code> 个，并且每个元素的值小于 <code>64</code> 字节时，Redis 会使用<strong>压缩列表</strong>作为 Zset 类型的底层数据结构；</li><li>如果有序集合的元素不满足上面的条件，Redis 会使用<strong>跳表</strong>作为 Zset 类型的底层数据结构；</li></ul><p><strong>在 Redis 7.0 中，压缩列表数据结构已经废弃了，交由 listpack 数据结构来实现了。</strong></p><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">138. 随机链表的复制</a></p><p><img src="../imgs/19th-March/image-20240320000304343.png" alt="随机链表的复制" /></p><p>哈希表实现：</p><p>用哈希表存储每个链表节点 然后再串联next和random</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-comment">/*</span><br><span class="hljs-comment">// Definition for a Node.</span><br><span class="hljs-comment">class Node &#123;</span><br><span class="hljs-comment">public:</span><br><span class="hljs-comment">    int val;</span><br><span class="hljs-comment">    Node* next;</span><br><span class="hljs-comment">    Node* random;</span><br><span class="hljs-comment">    </span><br><span class="hljs-comment">    Node(int _val) &#123;</span><br><span class="hljs-comment">        val = _val;</span><br><span class="hljs-comment">        next = NULL;</span><br><span class="hljs-comment">        random = NULL;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;;</span><br><span class="hljs-comment">*/</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">Node* <span class="hljs-title">copyRandomList</span><span class="hljs-params">(Node* head)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span>(head == <span class="hljs-literal">nullptr</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">nullptr</span>;<br>        Node* cur = head;<br>        unordered_map&lt;Node*,Node*&gt; map;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>            map[cur] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Node</span>(cur-&gt;val);<br>            cur = cur-&gt;next;<br>        &#125;<br>        cur = head;<br>        <span class="hljs-keyword">while</span>(cur != <span class="hljs-literal">nullptr</span>)&#123;<br>            map[cur]-&gt;next = map[cur-&gt;next];<br>            map[cur]-&gt;random = map[cur-&gt;random];<br>            cur = cur-&gt;next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> map[head];<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>明天实现一下在节点后面添加新的节点再脱离一下</p>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>18th-March</title>
    <link href="/2024/03/18/18th-March/"/>
    <url>/2024/03/18/18th-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="1-简介"><a class="markdownIt-Anchor" href="#1-简介"></a> 1 简介</h1><p>晚上收到字节周五约面，所以专心准备项目八股和算法，今天先抠一下项目的细节，从6.824开始</p><h1 id="2-6824"><a class="markdownIt-Anchor" href="#2-6824"></a> 2 6.824</h1><h2 id="可能会问的问题"><a class="markdownIt-Anchor" href="#可能会问的问题"></a> 可能会问的问题</h2><h3 id="mapreduce-qa"><a class="markdownIt-Anchor" href="#mapreduce-qa"></a> mapreduce Q&amp;A</h3><p><font color='red'>1.简单介绍一下mapreduce（开始乱吹）</font></p><p>在二十年以前，分布式系统和分布式计算并不普及，很多公司只是用一台计算机进行操作，但是随着互联网的飞速发展，一台机器的算力已经不足以支撑起快速的计算了，所以就有了分布式这个概念，多台电脑一起完成一个工作。谷歌作为一个国际大公司也是对这方面有着很深刻的研究，他们也会经常要使用并行的计算，而计算必须分布在数百台或者上千台机器，以便在合理的时间内完成，如何并行化计算、分布数据和处理故障等问题，使得单机变成多机的问题十分的复杂。所以就这样，他们受到了map和reduce原语的启发，也就有了mapreduce这么一个简单但强大的支持大规模计算的自动并行化和分布的接口</p><p><font color = 'red'>2.mapreduce是怎么操作的</font></p><p>首先mapreduce库将输入文件分成m个16-64mb的小文件 然后再一个机器集群上启动该程序的副本</p><p>这些副本中有一份是特别的就是master，其余的就是master分配工作的worker。</p><p>被分配map任务的worker线程读取相应输入分割的内容。它们从输入数据中解析键值对，并将每对传递给用户定义的map函数，map产生中间键值对再内存中进行缓冲</p><p>周期性地将缓冲对写入本地磁盘，并通过分区函数划分R个区域。这些缓冲对再本地磁盘上的位置被传递回主服务器，然后再将位置转发给reduce worker</p><p>它使用远程过程调用从map worker的本地磁盘读取缓冲数据。当reduce工作程序读取了所有中间数据后，它按中间键对数据进行排序，以便将所有出现的相同键分组在一起。排序是必要的，因为通常有许多不同的键映射到相同的reduce任务。如果中间数据量太大，内存无法容纳，则使用外部排序。</p><p>reduce worker遍历已排序的中间数据，对于遇到的每个唯一的中间键，它将键和相应的中间值集传递给用户的reduce函数。Reduce函数的输出被附加到这个Reduce分区的最终输出文件中。</p><p>当所有map任务和reduce任务完成后，主程序唤醒用户程序。此时，用户程序中的MapReduce调用返回到用户代码。</p><p><font color = 'red'>3.mapreduce的优化点？</font></p><p>combiner</p><p>状态信息</p><p>我们从这项工作中学到了一些东西。首先，限制编程模型使其易于并行化和分布计算，并使此类计算具有容错性。第二，网络带宽是一种稀缺资源。因此，我们系统中的许多优化都以减少通过网络发送的数据量为目标:局域优化允许我们从本地磁盘读取数据，并将中间数据的单个副本写入本地磁盘以节省网络带宽。第三，冗余执行可用于减少慢机的影响，并处理机器故障和数据丢失</p><h3 id="raft-qa"><a class="markdownIt-Anchor" href="#raft-qa"></a> Raft Q&amp;A</h3><p><font color='red'>简单讲讲Raft？</font></p><p>他是从多副本状态机的角度提出来的，用于管理多副本状态机的日志复制，分为多个子问题：Leader选举，日志同步，安全性，日志压缩，成员变更等</p><p>raft将系统中的角色分为leader，follower，和candidate</p><p>leader：接受客户端请求，并向Follower同步请求日志，当日志同步到大多数节点上后告诉Follower提交日志</p><p>Follower：接受并持久化Leader同步的日志，再Leader告知日志可以提交之后便提交</p><p>Candidate：Leader选举过程中的临时角色</p><p><font color = 'red'>Raft选举过程 日志复制？</font></p><p>Raft 使用心跳（heartbeat）触发Leader选举。当服务器启动时，初始化为Follower。Leader向所有Followers周期性发送heartbeat。如果Follower在选举超时时间内没有收到Leader的heartbeat，就会等待一段随机的时间后发起一次Leader选举。</p><p>Follower将其当前term加一然后转换为Candidate。它首先给自己投票并且给集群中的其他服务器发送 RequestVote RPC （RPC细节参见八、Raft算法总结）。结果有以下三种情况：</p><ul><li>赢得了多数的选票，成功选举为Leader；</li><li>收到了Leader的消息，表示有其它服务器已经抢先当选了Leader；</li><li>没有服务器赢得多数的选票，Leader选举失败，等待选举时间超时后发起下一次选举。</li></ul><p>Leader选出后，就开始接收客户端的请求。Leader把请求作为日志条目（Log entries）加入到它的日志中，然后并行的向其他服务器发起 AppendEntries RPC 复制日志条目。当这条日志被复制到大多数服务器上，Leader将这条日志应用到它的状态机并向客户端返回执行结果。</p><p>快照 持久化 快速恢复</p><p>可以让Follower在回复Leader的AppendEntries消息中，携带3个额外的信息，来加速日志的恢复。这里的回复是指，Follower因为Log信息不匹配，拒绝了Leader的AppendEntries之后的回复。这里的三个信息是指：</p><ul><li>XTerm：这个是Follower中与Leader冲突的Log对应的任期号。在之前（7.1）有介绍Leader会在prevLogTerm中带上本地Log记录中，前一条Log的任期号。如果Follower在对应位置的任期号不匹配，它会拒绝Leader的AppendEntries消息，并将自己的任期号放在XTerm中。如果Follower在对应位置没有Log，那么这里会返回 -1。</li><li>XIndex：这个是Follower中，对应任期号为XTerm的第一条Log条目的槽位号。</li><li>XLen：如果Follower在对应位置没有Log，那么XTerm会返回-1，XLen表示空白的Log槽位数。</li></ul><p>线性一致</p><p>目前看完2B 看明天怎么看一下2C和2D 争取把这个干完有时间再看其他两个</p><h1 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h1><p>算法 八股 项目 都得看看</p><p>算法把那几个dp干完看csview上的 但是记得字节应该是得自己new样例的</p><p>八股 先小林 然后再看其他的怎么说</p><p>今天就先这样吧</p>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>15th-March</title>
    <link href="/2024/03/15/15th-March/"/>
    <url>/2024/03/15/15th-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="to-do-list"><a class="markdownIt-Anchor" href="#to-do-list"></a> To-do List</h1><ul><li><p>[x] 算法</p><ul><li>[ ]</li></ul></li><li><p>[ ] 项目</p><ul><li>[ ] cmu15445</li><li>[x] mit6.824</li><li>[ ] mit6.081</li></ul></li><li><p>[ ] 八股</p><ul><li>[ ] 操作系统</li><li>[ ] 计算机网络</li><li>[ ] 数据库</li><li>[ ] redis</li></ul></li><li><p>[x] 日常总结</p></li></ul><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><p>今天没写。。。 心态有点小崩 等会随便找个题练个手吧</p><h2 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h2><h3 id="6824"><a class="markdownIt-Anchor" href="#6824"></a> 6.824</h3><p>完成了mapreduce</p><p>主要是coordinator mapworker和reduceworker的协调，感觉还是表达能力差了点</p><p>放点主要代码吧</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoMap</span><span class="hljs-params">(mapf <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, <span class="hljs-type">string</span>)</span></span> []KeyValue, task *Task) &#123;<br><span class="hljs-comment">//读入每个输入文件，将其传给map，累积中间Map输出。</span><br>fmt.Println(<span class="hljs-string">&quot;Begin map function,task information(TaskType Filename NReduce TaskId Finished Start):&quot;</span>, task)<br>intermediate := []KeyValue&#123;&#125;<br>filename := task.Filename<br>file, err := os.Open(filename)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot open %v&quot;</span>, filename)<br>&#125;<br>content, err := ioutil.ReadAll(file)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>log.Fatalf(<span class="hljs-string">&quot;cannot read %v&quot;</span>, filename)<br>&#125;<br>file.Close()<br>kva := mapf(filename, <span class="hljs-type">string</span>(content))<br><span class="hljs-comment">//中间key</span><br>intermediate = <span class="hljs-built_in">append</span>(intermediate, kva...)<br>fmt.Println(<span class="hljs-string">&quot;map生成的中间key:&quot;</span>, intermediate)<br>intermediateMap := <span class="hljs-built_in">make</span>([][]KeyValue, task.NReduce)<br><span class="hljs-keyword">for</span> _, tmp := <span class="hljs-keyword">range</span> intermediate &#123;<br>intermediateMap[ihash(tmp.Key)%task.NReduce] = <span class="hljs-built_in">append</span>(intermediateMap[ihash(tmp.Key)%task.NReduce], tmp)<br>&#125;<br>sort.Sort(ByKey(intermediate))<br>i := <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i &lt; task.NReduce &#123;<br>oname := <span class="hljs-string">&quot;mr-&quot;</span> + strconv.Itoa(task.TaskId) + <span class="hljs-string">&quot;-&quot;</span> + strconv.Itoa(i)<br>ofile, _ := os.Create(oname)<br>enc := json.NewEncoder(ofile)<br><span class="hljs-keyword">for</span> _, kv := <span class="hljs-keyword">range</span> intermediateMap[i] &#123;<br>enc.Encode(&amp;kv)<br>&#125;<br>i++<br>ofile.Close()<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoReduce</span><span class="hljs-params">(reducef <span class="hljs-keyword">func</span>(<span class="hljs-type">string</span>, []<span class="hljs-type">string</span>)</span></span> <span class="hljs-type">string</span>, task *Task) &#123;<br>i := <span class="hljs-number">0</span><br>intermediate := []KeyValue&#123;&#125;<br><span class="hljs-keyword">for</span> i &lt; task.NReduce &#123;<br>filepath := task.Filename + strconv.Itoa(i) + <span class="hljs-string">&quot;-&quot;</span> + strconv.Itoa(task.TaskId)<br>fmt.Println(<span class="hljs-string">&quot;Begin map function,task information(TaskType Filename NReduce TaskId Finished Start):&quot;</span>, task, <span class="hljs-string">&quot;\nfilepath:&quot;</span>, filepath)<br>file, _ := os.Open(filepath)<br>dec := json.NewDecoder(file)<br><span class="hljs-comment">//解码</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">var</span> kv KeyValue<br><span class="hljs-keyword">if</span> err := dec.Decode(&amp;kv); err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>intermediate = <span class="hljs-built_in">append</span>(intermediate, kv)<br>&#125;<br>file.Close()<br>i++<br>&#125;<br>sort.Sort(ByKey(intermediate))<br>i = <span class="hljs-number">0</span><br>oname := <span class="hljs-string">&quot;mr-out-&quot;</span> + strconv.Itoa(task.TaskId)<br>ofile, _ := os.Create(oname)<br><br><span class="hljs-keyword">for</span> i &lt; <span class="hljs-built_in">len</span>(intermediate) &#123;<br>j := i + <span class="hljs-number">1</span><br><span class="hljs-keyword">for</span> j &lt; <span class="hljs-built_in">len</span>(intermediate) &amp;&amp; intermediate[j].Key == intermediate[i].Key &#123;<br>j++<br>&#125;<br>values := []<span class="hljs-type">string</span>&#123;&#125;<br><span class="hljs-comment">//将相同的Key收集到一起</span><br><span class="hljs-keyword">for</span> k := i; k &lt; j; k++ &#123;<br>values = <span class="hljs-built_in">append</span>(values, intermediate[k].Value)<br>&#125;<br>output := reducef(intermediate[i].Key, values)<br>fmt.Fprintf(ofile, <span class="hljs-string">&quot;%v %v\n&quot;</span>, intermediate[i].Key, output)<br>i = j<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="八股"><a class="markdownIt-Anchor" href="#八股"></a> 八股</h2><h3 id="golang-切片的容量是怎样增长的"><a class="markdownIt-Anchor" href="#golang-切片的容量是怎样增长的"></a> Golang-切片的容量是怎样增长的</h3><p>一般都是在向slice追加了元素之后，才会引起扩容，追加元素调用的是append函数</p><p>先来看看append函数的原型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">append</span><span class="hljs-params">(slice []Type, elems ...Type)</span></span> []Type<br></code></pre></td></tr></table></figure><p>append函数的参数长度可变，因此可以追加多个值到slice中，还可以用…传入slice，直接追加一个切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs go">slice = <span class="hljs-built_in">append</span>(slice, elem1, elem2)<br>slice = <span class="hljs-built_in">append</span>(slice, anotherSlice...)<br></code></pre></td></tr></table></figure><p>append函数返回值是一个新的slice，Go编译器不允许调用了append函数后不使用返回值。</p><p>使用 append 可以向 slice 追加元素，实际上是往底层数组添加元素。但是底层数组的长度是固定的，如果索引 <code>len-1</code> 所指向的元素已经是底层数组的最后一个元素，就没法再添加了。</p><p>这时，slice 会迁移到新的内存位置，新底层数组的长度也会增加，这样就可以放置新增的元素。同时，为了应对未来可能再次发生的 append 操作，新的底层数组的长度，也就是新 <code>slice</code> 的容量是留了一定的 <code>buffer</code> 的。否则，每次添加元素的时候，都会发生迁移，成本太高。</p><p>新 slice 预留的 <code>buffer</code> 大小是有一定规律的。在golang1.18版本更新之前网上大多数的文章都是这样描述slice的扩容策略的：</p><blockquote><p>当原 slice 容量小于 <code>1024</code> 的时候，新 slice 容量变成原来的 <code>2</code> 倍；原 slice 容量超过 <code>1024</code>，新 slice 容量变成原来的<code>1.25</code>倍。</p></blockquote><p>在1.18版本更新之后，slice的扩容策略变为了：</p><blockquote><p>当原slice容量(oldcap)小于256的时候，新slice(newcap)容量为原来的2倍；原slice容量超过256，新slice容量newcap = oldcap+(oldcap+3*256)/4</p></blockquote><p>举例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s := <span class="hljs-built_in">make</span>([]<span class="hljs-type">int</span>, <span class="hljs-number">0</span>)<br><br>oldCap := <span class="hljs-built_in">cap</span>(s)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2048</span>; i++ &#123;<br>s = <span class="hljs-built_in">append</span>(s, i)<br><br>newCap := <span class="hljs-built_in">cap</span>(s)<br><br><span class="hljs-keyword">if</span> newCap != oldCap &#123;<br>fmt.Printf(<span class="hljs-string">&quot;[%d -&gt; %4d] cap = %-4d  |  after append %-4d  cap = %-4d\n&quot;</span>, <span class="hljs-number">0</span>, i<span class="hljs-number">-1</span>, oldCap, i, newCap)<br>oldCap = newCap<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我先创建了一个空的 <code>slice</code>，然后，在一个循环里不断往里面 <code>append</code> 新的元素。然后记录容量的变化，并且每当容量发生变化的时候，记录下老的容量，以及添加完元素之后的容量，同时记下此时 <code>slice</code> 里的元素。这样，我就可以观察，新老 <code>slice</code> 的容量变化情况，从而找出规律。</p><p>运行结果(1.18版本之前)：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[0 -&gt;   -1]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">0</span>     |  after append <span class="hljs-number">0</span>     cap = <span class="hljs-number">1</span>   <br><span class="hljs-section">[0 -&gt;    0]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">1</span>     |  after append <span class="hljs-number">1</span>     cap = <span class="hljs-number">2</span>   <br><span class="hljs-section">[0 -&gt;    1]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">2</span>     |  after append <span class="hljs-number">2</span>     cap = <span class="hljs-number">4</span>   <br><span class="hljs-section">[0 -&gt;    3]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">4</span>     |  after append <span class="hljs-number">4</span>     cap = <span class="hljs-number">8</span>   <br><span class="hljs-section">[0 -&gt;    7]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">8</span>     |  after append <span class="hljs-number">8</span>     cap = <span class="hljs-number">16</span>  <br><span class="hljs-section">[0 -&gt;   15]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">16</span>    |  after append <span class="hljs-number">16</span>    cap = <span class="hljs-number">32</span>  <br><span class="hljs-section">[0 -&gt;   31]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">32</span>    |  after append <span class="hljs-number">32</span>    cap = <span class="hljs-number">64</span>  <br><span class="hljs-section">[0 -&gt;   63]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">64</span>    |  after append <span class="hljs-number">64</span>    cap = <span class="hljs-number">128</span> <br><span class="hljs-section">[0 -&gt;  127]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">128</span>   |  after append <span class="hljs-number">128</span>   cap = <span class="hljs-number">256</span> <br><span class="hljs-section">[0 -&gt;  255]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">256</span>   |  after append <span class="hljs-number">256</span>   cap = <span class="hljs-number">512</span> <br><span class="hljs-section">[0 -&gt;  511]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">512</span>   |  after append <span class="hljs-number">512</span>   cap = <span class="hljs-number">1024</span><br><span class="hljs-section">[0 -&gt; 1023]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">1024</span>  |  after append <span class="hljs-number">1024</span>  cap = <span class="hljs-number">1280</span><br><span class="hljs-section">[0 -&gt; 1279]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">1280</span>  |  after append <span class="hljs-number">1280</span>  cap = <span class="hljs-number">1696</span><br><span class="hljs-section">[0 -&gt; 1695]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">1696</span>  |  after append <span class="hljs-number">1696</span>  cap = <span class="hljs-number">2304</span><br></code></pre></td></tr></table></figure><p>运行结果(1.18版本)：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[0 -&gt;   -1]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">0</span>     |  after append <span class="hljs-number">0</span>     cap = <span class="hljs-number">1</span><br><span class="hljs-section">[0 -&gt;    0]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">1</span>     |  after append <span class="hljs-number">1</span>     cap = <span class="hljs-number">2</span>   <br><span class="hljs-section">[0 -&gt;    1]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">2</span>     |  after append <span class="hljs-number">2</span>     cap = <span class="hljs-number">4</span>   <br><span class="hljs-section">[0 -&gt;    3]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">4</span>     |  after append <span class="hljs-number">4</span>     cap = <span class="hljs-number">8</span>   <br><span class="hljs-section">[0 -&gt;    7]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">8</span>     |  after append <span class="hljs-number">8</span>     cap = <span class="hljs-number">16</span>  <br><span class="hljs-section">[0 -&gt;   15]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">16</span>    |  after append <span class="hljs-number">16</span>    cap = <span class="hljs-number">32</span>  <br><span class="hljs-section">[0 -&gt;   31]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">32</span>    |  after append <span class="hljs-number">32</span>    cap = <span class="hljs-number">64</span>  <br><span class="hljs-section">[0 -&gt;   63]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">64</span>    |  after append <span class="hljs-number">64</span>    cap = <span class="hljs-number">128</span> <br><span class="hljs-section">[0 -&gt;  127]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">128</span>   |  after append <span class="hljs-number">128</span>   cap = <span class="hljs-number">256</span> <br><span class="hljs-section">[0 -&gt;  255]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">256</span>   |  after append <span class="hljs-number">256</span>   cap = <span class="hljs-number">512</span> <br><span class="hljs-section">[0 -&gt;  511]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">512</span>   |  after append <span class="hljs-number">512</span>   cap = <span class="hljs-number">848</span> <br><span class="hljs-section">[0 -&gt;  847]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">848</span>   |  after append <span class="hljs-number">848</span>   cap = <span class="hljs-number">1280</span><br><span class="hljs-section">[0 -&gt; 1279]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">1280</span>  |  after append <span class="hljs-number">1280</span>  cap = <span class="hljs-number">1792</span><br><span class="hljs-section">[0 -&gt; 1791]</span> <span class="hljs-attr">cap</span> = <span class="hljs-number">1792</span>  |  after append <span class="hljs-number">1792</span>  cap = <span class="hljs-number">2560</span><br></code></pre></td></tr></table></figure><p>根据上面的结果我们可以看出在<code>1.18</code>版本之前：</p><p>在原来的slice容量<code>oldcap</code>小于1024的时候，新 slice 的容量<code>newcap</code>的确是<code>oldcap</code>的2倍。</p><p>但是，当<code>oldcap</code>大于等于 <code>1024</code> 的时候，情况就有变化了。当向 slice 中添加元素 <code>1280</code> 的时候，原来的slice 的容量为 <code>1280</code>，之后<code>newcap</code>变成了 <code>1696</code>，两者并不是 <code>1.25</code> 倍的关系（1696/1280=1.325）。添加完 <code>1696</code> 后，新的容量 <code>2304</code> 当然也不是 <code>1696</code> 的 <code>1.25</code> 倍。</p><p>在<code>1.18</code>版本之后：</p><p>在原来的slice 容量<code>oldcap</code>小于256的时候，新 slice 的容量<code>newcap</code>的确是<code>oldcap</code> 的2倍。</p><p>但是，当<code>oldcap</code>容量大于等于 <code>256</code> 的时候，情况就有变化了。当向 slice 中添加元素 <code>512</code> 的时候，老 slice 的容量为 <code>512</code>，之后变成了 <code>8</code>48，两者并没有符合<code>newcap = oldcap+(oldcap+3*256)/4</code> 的策略（512+（512+3*256）/4）=832。添加完 <code>848</code> 后，新的容量 <code>1280</code> 当然也不是 按照之前策略所计算出的的1252。</p><p>难道现在网上各种文章中的扩容策略并不是正确的吗。我们直接搬出源码：源码面前，了无秘密。</p><p>从前面汇编代码我们也看到了，向 slice 追加元素的时候，若容量不够，会调用 <code>growslice</code> 函数，所以我们直接看它的代码。</p><p><strong>golang版本1.9.5</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// go 1.9.5 src/runtime/slice.go:82</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> slice &#123;<br>    <span class="hljs-comment">// ……</span><br>    newcap := old.<span class="hljs-built_in">cap</span><br>doublecap := newcap + newcap<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> old.<span class="hljs-built_in">len</span> &lt; <span class="hljs-number">1024</span> &#123;<br>newcap = doublecap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>newcap += newcap / <span class="hljs-number">4</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// ……</span><br><br>capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap) * ptrSize)<br>newcap = <span class="hljs-type">int</span>(capmem / ptrSize)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>golang版本1.18</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// go 1.18 src/runtime/slice.go:178</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">growslice</span><span class="hljs-params">(et *_type, old slice, <span class="hljs-built_in">cap</span> <span class="hljs-type">int</span>)</span></span> slice &#123;<br>    <span class="hljs-comment">// ……</span><br>    newcap := old.<span class="hljs-built_in">cap</span><br>doublecap := newcap + newcap<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">cap</span> &gt; doublecap &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">const</span> threshold = <span class="hljs-number">256</span><br><span class="hljs-keyword">if</span> old.<span class="hljs-built_in">cap</span> &lt; threshold &#123;<br>newcap = doublecap<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">for</span> <span class="hljs-number">0</span> &lt; newcap &amp;&amp; newcap &lt; <span class="hljs-built_in">cap</span> &#123;<br>                <span class="hljs-comment">// Transition from growing 2x for small slices</span><br><span class="hljs-comment">// to growing 1.25x for large slices. This formula</span><br><span class="hljs-comment">// gives a smooth-ish transition between the two.</span><br>newcap += (newcap + <span class="hljs-number">3</span>*threshold) / <span class="hljs-number">4</span><br>&#125;<br><span class="hljs-keyword">if</span> newcap &lt;= <span class="hljs-number">0</span> &#123;<br>newcap = <span class="hljs-built_in">cap</span><br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-comment">// ……</span><br>    <br>capmem = roundupsize(<span class="hljs-type">uintptr</span>(newcap) * ptrSize)<br>newcap = <span class="hljs-type">int</span>(capmem / ptrSize)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果只看前半部分，现在网上各种文章里说的 <code>newcap</code> 的规律是对的。现实是，后半部分还对 <code>newcap</code> 作了一个<code>内存对齐</code>，这个和内存分配策略相关。进行内存对齐之后，新 slice 的容量是要 <code>大于等于</code> 按照前半部分生成的<code>newcap</code>。</p><p>之后，向 Go 内存管理器申请内存，将老 slice 中的数据复制过去，并且将 append 的元素添加到新的底层数组中。</p><p>最后，向 <code>growslice</code> 函数调用者返回一个新的 slice，这个 slice 的长度并没有变化，而容量却增大了。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>。。。失败 但是差不多能知道哪里不足了 可以尝试一下 明天笔试加油</p>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>raft</title>
    <link href="/2024/03/15/raft-1/"/>
    <url>/2024/03/15/raft-1/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="一种可理解的共识算法的寻找扩展版"><a class="markdownIt-Anchor" href="#一种可理解的共识算法的寻找扩展版"></a> 一种可理解的共识算法的寻找(扩展版)</h1><h2 id="概要"><a class="markdownIt-Anchor" href="#概要"></a> 概要</h2><p>​<strong>Raft</strong>是用于管理复制日志的共识算法。它产生的结果相当于(多)Paxos，效率和Paxos一样，但结构与Paxos不同;这使得Raft比Paxos更容易理解，也为构建实用系统提供了更好的基础。为了增强可理解性，Raft分离了共识的关键元素，如leader选举、日志复制和安全性，并且它强制执行更强的一致性，以减少必须考虑的状态的数量。用户研究的结果表明，对于学生来说，Raft比Paxos更容易学习。Raft还包含了一个改变集群成员的新机制，它使用重叠大多数来保证安全。</p><h2 id="i介绍"><a class="markdownIt-Anchor" href="#i介绍"></a> I.介绍</h2><p>​共识算法允许一组机器作为一个连贯的群体工作，可以在其中一些成员出现故障时幸存下来。正因为如此，它们在构建可靠的大型软件系统中起着关键作用。Paxos[15,16]在过去十年中主导了共识算法的讨论:大多数共识的实现都基于Paxos或受其影响，Paxos已成为教授学生共识的主要工具。</p><p>​不幸的是，Paxos很难理解，尽管有许多尝试使它更容易理解。此外，它的体系结构需要进行复杂的更改以支持实际系统。因此，系统构建者和学生使用Paxos都很困难。</p><p>​在与Paxos斗争之后，我们开始寻找一种新的共识算法，可以为系统构建和教育提供更好的基础。我们的方法是不同寻常的，因为我们的主要目标是可理解性:我们能否为实际系统定义一个共识算法，并以一种比Paxos更容易学习的方式来描述它?此外，我们希望算法能够促进对系统构建者至关重要的直觉的发展。重要的不仅是算法能起作用，还在于它为什么能起作用。</p><p>​这项工作的结果是一个被称为Raft的共识算法。在设计Raft时，我们应用了特定的技术来提高可理解性，包括分解(Raft将领导者选举、日志复制和安全性分开)和状态空间缩减(相对于Paxos, Raft降低了不确定性的程度和服务器之间可能不一致的方式)。一项针对两所大学43名学生的用户研究表明，Raft比Paxos更容易理解:在学习了这两种算法后，其中33名学生能够更好地回答关于Raft的问题，而不是关于Paxos的问题。</p><p>​Raft在许多方面与现有的共识算法相似(最值得注意的是Oki和Liskov的Viewstamped Replication)，但它有几个新特性:</p><ul><li><strong>强大的leader</strong>:Raft使用比其他共识算法更强大的领导形式。例如，日志条目只从leader流向其他服务器。这简化了复制日志的管理，使Raft更容易理解。</li><li><strong>leader选举</strong>:Raft使用随机计时器来选举首领。这只给任何共识算法已经需要的心跳增加了少量的机制，同时简单快速地解决冲突。</li><li><strong>成员变更</strong>:Raft用于更改集群中服务器集的机制使用了一种新的联合共识方法，在这种方法中，两种不同配置的大多数在转换期间重叠。这允许集群在配置更改期间继续正常运行。</li></ul><p>​我们相信Raft优于Paxos和其他共识算法，无论是出于教育目的还是作为实现的基础。它比其他算法更简单，更容易理解;它的描述足够完整，足以满足实际系统的需要;它有几个开源实现，并被几家公司使用;其安全性能已经过正式规定和证明;其效率与其他算法相当。</p><p>​本文的其余部分介绍了复制状态机问题(第2节)，讨论了Paxos的优缺点(第3节)，描述了我们实现可理解性的一般方法(第4节)，介绍了Raft共识算法(第5-8节)，评估了Raft(第9节)，并讨论了相关工作(第10节)。</p><h2 id="ii复制状态机"><a class="markdownIt-Anchor" href="#ii复制状态机"></a> II.复制状态机</h2><p><img src="../imgs/raft-1/image-20240315211045665.png" alt="图1:复制状态机架构。一致性算法管理包含来自客户机的状态机命令的复制日志。状态机处理来自日志的相同命令序列，因此它们产生相同的输出。" /></p><p>​共识算法通常出现在复制状态机的环境中。在这种方法中，一组服务器上的状态机计算相同状态的相同副本，并且即使某些服务器关闭也可以继续运行。复制状态机用于解决分布式系统中的各种容错问题。例如，具有单个集群领导者的大型系统，如GFS， HDFS和RAMCloud，通常使用单独的复制状态机来管理领导者选举和存储必须在领导者崩溃时存活的配置信息。复制状态机的例子包括Chubby和ZooKeeper。</p><p>​复制状态机通常使用复制日志来实现，如图1所示。每个服务器存储包含一系列命令的日志，其状态机按顺序执行这些命令。每个日志以相同的顺序包含相同的命令，因此每个状态机处理相同的命令序列。由于状态机是确定性的，因此每个状态机都计算相同的状态和相同的输出序列。</p><p>​保持复制日志的一致性是一致性算法的工作。服务器上的consensus模块接收来自客户端的命令并将其添加到日志中。它与其他服务器上的共识模块通信，以确保每个日志最终以相同的顺序包含相同的请求，即使某些服务器失败。一旦正确地复制了命令，每个服务器的状态机将按日志顺序处理它们，并将输出返回给客户机。因此，这些服务器似乎形成了一个单一的、高度可靠的状态机。</p><p>​实际系统的共识算法通常具有以下性质:</p><ul><li>它们确保在所有非拜占庭条件下的安全性(永远不会返回错误的结果)，包括网络延迟、分区、数据包丢失、重复和重新排序。</li><li>只要任何大多数服务器都是可操作的，并且可以相互通信并与客户端通信，它们就具有完整的功能(可用)。因此，典型的五台服务器集群可以容忍任意两台服务器的故障。通过停止假定服务器失败;它们可能稍后从稳定存储上的状态恢复并重新加入集群。</li><li>它们不依赖于定时来确保日志的一致性:错误的时钟和极端的消息延迟在最坏的情况下会导致可用性问题。</li><li>在通常情况下，只要集群的大多数响应了一轮远程过程调用，命令就可以完成;少数慢速服务器不需要影响整体系统性能。</li></ul><h2 id="iiiwhats-wrong-with-paxos"><a class="markdownIt-Anchor" href="#iiiwhats-wrong-with-paxos"></a> III.What’s wrong with Paxos???</h2><p>​在过去的十年里，Leslie Lamport的Paxos协议几乎已经成为共识的代名词:它是课程中最常教授的协议，大多数共识的实现都将其作为起点。Paxos首先定义了一个能够就单个决策达成一致的协议，比如单个复制的日志条目。我们将这个子集称为单命令Paxos。然后，Paxos结合该协议的多个实例来促进一系列决策，例如日志(多Paxos)。Paxos确保了安全性和活动性，并且支持更改集群成员。该方法的正确性得到了验证，在一般情况下是有效的。</p><p>​不幸的是，Paxos有两个明显的缺点。第一个缺点是Paxos非常难以理解。完整的解释[15]是出了名的不透明;只有付出巨大努力的人才能理解它。因此，已经有人尝试用更简单的术语来解释Paxos。这些解释集中于单一法令子集，但它们仍然具有挑战性。在对2012年NSDI与会者的非正式调查中，我们发现很少有人对Paxos感到满意，即使是经验丰富的研究人员。我们自己也在努力开发Paxos;直到阅读了几个简化的解释并设计了我们自己的替代协议之后，我们才能够理解完整的协议，这个过程花了将近一年的时间。</p><p>​我们假设Paxos的不透明性源于它选择单一法令子集作为其基础。单一法令的Paxos是密集而微妙的:它分为两个阶段，没有简单的直观解释，无法独立理解。正因为如此，很难对单一法令协议的工作原理做出直观的解释。多paxos的组合规则增加了额外的复杂性和微妙性。我们相信，在多个决策上达成共识的整体问题(即，一个日志而不是单个条目)可以用其他更直接和明显的方式分解。</p><p>​Paxos的第二个问题是，它没有为构建实际实现提供良好的基础。其中一个原因是，对于多paxos，还没有得到广泛认可的算法。兰波特的描述主要是关于单一法令的Paxos;他概述了实现多paxos的可能方法，但缺少许多细节。已经有几次尝试充实和优化Paxos，但这些彼此不同，也不同于Lamport的草图。像Chubby这样的系统已经实现了类似paxos的算法，但在大多数情况下，它们的细节还没有公布。</p><p>​此外，Paxos架构对于构建实际系统来说是一个糟糕的架构;这是单一法令分解的另一个后果。例如，独立地选择一组日志条目，然后将它们合并到一个顺序日志中，这几乎没有什么好处;这只会增加复杂性。围绕日志设计系统更简单、更有效，在日志中，新条目以受限的顺序依次挂起。另一个问题是Paxos在其核心使用了对称的点对点方法(尽管它最终提出了一种弱形式的领导作为性能优化)。这在只需要做出一个决策的简化世界中是有意义的，但是很少有实际的系统使用这种方法。如果必须做出一系列决策，那么首先选举一个领导者，然后让领导者协调决策是更简单和更快的方法。</p><p>​因此，实际系统与Paxos几乎没有相似之处。每个实现都从Paxos开始，发现实现它的困难，然后开发一个截然不同的体系结构。这既耗时又容易出错，而且理解Paxos的困难加剧了这个问题。Paxos的公式对于证明其正确性的定理可能是一个很好的公式，但是实际实现与Paxos如此不同，以至于证明几乎没有价值。以下是Chubby实现者的典型评论:</p><p>​<font color = 'red'><strong>在Paxos算法的描述和真实系统的需求之间有很大的差距…最终的系统将基于一个未经验证的协议</strong></font></p><p>​由于这些问题，我们得出结论，Paxos不能为系统构建或教育提供良好的基础。考虑到共识在大型软件系统中的重要性，我们决定看看是否可以设计一个具有比Paxos更好属性的替代共识算法。Raft就是那次实验的结果。</p><h2 id="iv为可理解性而设计"><a class="markdownIt-Anchor" href="#iv为可理解性而设计"></a> IV.为可理解性而设计</h2><p>​我们在设计Raft时有几个目标:它必须为系统构建提供一个完整和实用的基础，这样它就可以显著减少开发人员所需的设计工作量;它必须在所有条件下都是安全的，并在典型的操作条件下可用;对于一般的操作，它必须是有效的。但我们最重要的目标——也是最困难的挑战——是可理解性。它必须能够让大量的观众轻松地理解算法。此外，必须能够开发关于算法的直觉，以便系统构建者可以进行在实际实现中不可避免的扩展。</p><p>​在Raft的设计过程中，我们需要在不同的方法中做出选择。在这些情况下，我们根据可理解性来评估备选方案:解释每个备选方案有多难(例如，其状态空间有多复杂，它是否有微妙的含义?)，读者完全理解该方法及其含义有多容易?</p><p>​我们认识到，在这种分析中有高度的主观性;尽管如此，我们还是使用了两种普遍适用的技术。第一种技术是众所周知的问题分解方法:只要有可能，我们就把问题分成可以相对独立地解决、解释和理解的独立部分。例如，在Raft中，我们分离了leader选举、日志复制、安全性和成员变更。</p><p>​我们的第二种方法是通过减少要考虑的状态数量来简化状态空间，使系统更加连贯，并在可能的情况下消除不确定性。具体来说，原木不允许有孔，Raft限制了原木相互不一致的方式。尽管在大多数情况下我们试图消除非确定性，但在某些情况下，非确定性实际上提高了可理解性。特别是，随机方法引入了不确定性，但它们倾向于通过以类似的方式处理所有可能的选择(“随便选没关系”)。我们使用随机化来简化Raft leader的选举算法。</p><h2 id="vraft共识算法"><a class="markdownIt-Anchor" href="#vraft共识算法"></a> V.Raft共识算法</h2><p><img src="../imgs/raft-1/image-20240315213252013.png" alt="图2:Raft共识算法的简明摘要(不包括成员变更和日志压缩)。左上角框中的服务器行为被描述为一组独立且重复触发的规则。章节编号，如§5.2表示讨论特定特征的地方。正式规范更精确地描述了该算法。" /></p><p>​Raft是一种算法，用于管理第2节中描述的形式的复制日志。图2对算法进行了简明总结，以供参考，图3列出了算法的关键属性;这些数字的元素将在本节的其余部分逐条讨论。</p><p>​Raft通过首先选举一个杰出的领导者来实现共识，然后让领导者完全负责管理复制的日志。leader接受来自客户机的日志条目，在其他服务器上复制它们，并告诉服务器何时可以安全地将日志条目应用到它们的状态机。拥有一个leader可以简化对复制日志的管理。例如，leader可以在不咨询其他服务器的情况下决定在日志中放置新条目的位置，并且数据以一种简单的方式从leader流向其他服务器。leader可能会失败或与其他服务器断开连接，在这种情况下，会选举一个新的leader。</p><p>​在leader方法下，Raft将共识问题分解为三个相对独立的子问题，并在以下小节中进行讨论:</p><ul><li>领导人选举:当现有领导人失败时，必须选择新的领导人(第5.2节)。</li><li>日志复制:leader必须接受来自客户端的日志条目，并在整个集群中复制它们，迫使其他日志与自己的日志一致(第5.3节)。</li><li>安全性:Raft的关键安全属性是图3中的状态机安全属性:如果任何服务器将特定的日志条目应用到其状态机，那么其他服务器就不能对相同的日志索引应用不同的命令。第5.4节描述了Raft如何确保此属性;该解决方案涉及对第5.2节中描述的选举机制的额外限制。</li></ul><p><img src="../imgs/raft-1/image-20240315213333387.png" alt="图3:Raft保证这些属性在任何时候都是正确的。节号表示讨论每个属性的位置。" /></p><p>​在介绍了共识算法之后，本节将讨论可用性问题和定时在系统中的作用。</p><h3 id="v1-raft基础"><a class="markdownIt-Anchor" href="#v1-raft基础"></a> V.1 Raft基础</h3><p>​Raft集群包含多个服务器;5是一个典型的数字，它允许系统容忍两次故障。在任何给定时间，每个服务器都处于以下三种状态之一:领导者、追随者或候选人。在正常操作中，只有一个领导者，所有其他服务器都是追随者。追随者是被动的:他们自己不发出任何要求，只是对领导和候选人的要求做出回应。leader处理所有客户端请求(如果客户端联系了follower, follower会将其重定向到leader)。第三个状态，candidate，用于选举新的领导人，如第5.2节所述。图4显示了状态及其转换;下面将讨论这些转换。</p><p><img src="../imgs/raft-1/image-20240315213542054.png" alt="图4:服务器状态。追随者只响应来自其他服务器的请求。如果追随者没有收到任何通信，它就成为候选人并发起选举。获得整个集群大多数选票的候选人成为新的领导者。领导者通常会一直工作到失败。" /></p><p><img src="../imgs/raft-1/image-20240315213607650.png" alt="图5:时间分为任期，每任期以选举开始。在一次成功的选举之后，一个单一的领导者管理集群直到任期结束。有些选举失败，在这种情况下，任期结束时没有选出领导人。在不同的服务器上，可以在不同的时间观察到术语之间的转换。" /></p><p>​Raft将时间划分为任意长度，如图5所示。任期用连续整数编号。每个任期以选举开始，其中一个或多个候选人试图成为第5.2节所述的领导人。如果一位候选人赢得选举，那么他将在剩下的任期内担任领导人。在某些情况下，选举会导致票数不一致。在这种情况下，任期结束时将没有领导人;新任期(有新的选举)即将开始。Raft保证在给定的任期内最多有一个leader。</p><p>​不同的服务器可能会在不同的时间观察任期之间的过渡，在某些情况下，服务器可能不会观察选举甚至整个任期。术语在Raft中充当逻辑时钟，它们允许服务器检测过时的信息，如过时的leader。每个服务器存储一个当前术语号，该术语号随时间单调增加。每当服务器通信时，都会交换当前条款;如果一台服务器的当前项小于另一台服务器的，则将其当前项更新为较大的值。如果候选人或领导人发现自己的任期已经过期，</p><p>​Raft服务器使用远程过程调用(rpc)进行通信，基本的一致性算法只需要两种类型的rpc。RequestVote rpc是由候选人在选举期间发起的(第5.2节)，而追加条目rpc是由领导者发起的，用于复制日志条目并提供心跳形式(第5.3节)。第7节添加了第三个RPC，用于在服务器之间传输快照。如果服务器没有及时收到响应，它们会重试rpc，并并行地发出rpc以获得最佳性能。</p><h3 id="v2-领导选举"><a class="markdownIt-Anchor" href="#v2-领导选举"></a> V.2 领导选举</h3><p>​Raft使用心跳机制来触发领导人选举。当服务器启动时，它们从追随者开始。只要从leader或candidate接收到有效的rpc，服务器就保持follower状态。领导者定期向所有追随者发送心跳(AppendEntries rpc，不携带日志条目)，以维护他们的权威。如果一个follower在一段称为选举超时的时间内没有收到任何通信，那么它假设没有可见的leader，并开始选举以选择一个新的leader。</p><p>​要开始选举，追随者增加其当前任期并过渡到候选人状态。然后，它为自己投票，并并行地向集群中的每个其他服务器发出RequestVote rpc。候选人一直处于这种状态，直到发生以下三种情况之一:(A)它赢得了选举，(b)另一个服务器确立了自己的领导地位，或者©一段时间过去了，没有赢家。这些结果将在下文各段分别讨论。</p><p>​如果候选人在同一任期内获得整个集群中大多数服务器的投票，则该候选人赢得选举。在给定的任期内，每个服务器将以先到先得的方式投票给最多一个候选人(注意:第5.4节增加了对投票的额外限制)。多数决定原则确保最多有一名候选人能够赢得特定任期的选举(图3中的选举安全属性)。一旦候选人赢得选举，它就成为领导者。然后，它向所有其他服务器发送心跳消息，以建立其权威并防止新的选举。</p><p>​在等待投票期间，候选人可能会从另一个声称是领导者的服务器接收AppendEntries RPC。如果领导者的任期(包含在其RPC中)至少与候选人的当前任期一样长，则候选人将承认领导者是合法的，并返回到追随者状态。如果RPC中的术语小于候选者的当前术语，则候选者拒绝RPC并继续处于候选者状态。</p><p>​第三种可能的结果是候选人既不赢也不输:如果许多追随者同时成为候选人，选票可能会被分割，因此没有候选人获得多数。当这种情况发生时，每个候选人将超时并通过增加其任期并启动另一轮请求-投票rpc来开始新的选举。然而，如果不采取额外措施，分裂投票可能会无限期地重复。</p><p>​Raft使用随机选举超时来确保分裂投票很少，并且可以快速解决。为了首先防止分裂投票，选举超时从固定间隔(例如150-300ms)中随机选择。这将分散服务器，因此在大多数情况下，只有一个服务器会超时;它赢得了选举，并在任何其他服务器超时之前发送心跳。同样的机制也用于处理分裂投票。每个候选人在选举开始时重新启动其随机选举超时，并等待该超时结束后再开始下一次选举;这降低了在新选举中再次出现分裂投票的可能性。9.3节表明，这种方法可以快速地选出领导者。</p><p><img src="../imgs/raft-1/image-20240315214258232.png" alt="图6:日志由条目组成，条目按顺序编号。每个条目包含创建它时使用的术语(每个框中的数字)和用于状态机的命令。如果将一个条目应用于状态机是安全的，则认为该条目已提交。" /></p><p>​选举是一个例子，说明可理解性如何指导我们在设计方案之间做出选择。最初我们计划使用一个排名系统:每个候选人被分配一个唯一的排名，用于在竞争候选人之间进行选择。如果一个候选人发现了另一个排名更高的候选人，它就会回到追随者状态，这样排名更高的候选人就更容易赢得下一次选举。我们发现这种方法在可用性方面产生了微妙的问题(如果排名较高的服务器失败，排名较低的服务器可能需要超时并再次成为候选服务器，但如果它这样做得太快，它可能会重置选举领导者的进度)。我们对算法进行了几次调整，但每次调整后都会出现新的拐角案例。最终我们得出结论，随机重试方法更明显，更容易理解。</p><h3 id="v3-日志复制"><a class="markdownIt-Anchor" href="#v3-日志复制"></a> V.3 日志复制</h3><p>​一旦选出领导者，它就开始服务客户端请求。每个客户端请求都包含一个要由复制状态机执行的命令。leader将该命令作为一个新条目追加到它的日志中，然后将AppendEntries rpc与其他每个服务器并行，以复制该条目。当条目被安全复制后(如下所述)，leader将该条目应用于其状态机，并将执行的结果返回给客户机。如果follower崩溃或运行缓慢，或者如果网络数据包丢失，leader会无限期地重试追加条目rpc(即使在它已经响应客户端之后)，直到所有follower最终存储所有日志条目。</p><p>​日志组织如图6所示。每个日志记录存储一个状态机命令以及leader接收到该条目时的术语号。日志条目中的术语编号用于检测日志之间的不一致性，并确保图3中的一些属性。每个日志条目还有一个整数索引，用于标识其在日志中的位置。</p><p>​领导者决定何时对状态机应用日志记录是安全的;这样的条目称为committed。Raft保证提交的条目是持久的，并且最终将由所有可用的状态机执行。一旦创建条目的leader在大多数服务器上复制了该条目(例如，图6中的条目7)，日志条目就会被提交。这也会提交leader日志中所有之前的条目，包括之前的leader创建的条目。第5.4节讨论了在领导者更换后应用此规则时的一些微妙之处，并表明此承诺定义是安全的。leader跟踪它知道要提交的最高索引，并将该索引包含在未来的AppendEntries rpc中(包括心跳)，以便其他服务器最终发现。一旦追随者了解到日志条目已提交，它将该条目应用于其本地状态机(按日志顺序)。</p><p>​我们设计Raft日志机制是为了在不同服务器上的日志之间保持高度的一致性。这不仅简化了系统的行为，使其更可预测，而且是确保安全的重要组成部分。Raft维护以下属性，它们共同构成了图3中的日志匹配属性:</p><ul><li>如果不同日志中的两个条目具有相同的索引和期限，则它们存储相同的命令。</li><li>如果不同日志中的两个条目具有相同的索引和期限，则前面所有条目的日志都相同。</li></ul><p>​第一个属性源于这样一个事实，即leader在给定的期限内最多创建一个具有给定日志索引的条目，并且日志条目永远不会改变其在日志中的位置。第二个属性由AppendEntries执行的简单一致性检查保证。当发送AppendEntries RPC时，leader在其日志中包含条目的索引和期限，该条目立即位于新条目之前。如果跟随者在其日志中没有找到具有相同索引和期限的条目，则拒绝新条目。一致性检查作为一个归纳步骤:日志的初始空状态满足日志匹配属性，无论何时扩展日志，一致性检查都保持日志匹配属性。因此，每当AppendEntries成功返回时，leader就知道follower的日志与它自己的日志通过新条目相同。</p><p>​正常运行时，leader和follower的日志是一致的，所以AppendEntries一致性检查不会失败。但是，leader崩溃可能导致日志不一致(旧leader可能没有完全复制其日志中的所有条目)。这些不一致可能会在一系列领导者和追随者的崩溃中加剧。图7说明了追随者的日志可能与新领导者的不同之处。follower可能缺少leader上存在的条目，也可能有leader上没有的额外条目，或者两者兼而有之。日志中缺少的和无关的条目可能跨越多个术语。</p><p>​在Raft中，领导者通过强迫追随者的日志复制自己的日志来处理不一致。这意味着跟随者日志中的冲突条目将被来自领导者日志的条目覆盖。第5.4节将说明，如果加上另外一个限制，这样做是安全的。</p><p>​为了使追随者的日志与自己的日志保持一致，领导者必须找到两个日志一致的最新日志条目，删除追随者日志中在该点之后的任何条目，并将领导者在该点之后的所有条目发送给追随者。所有这些操作都是对AppendEntries rpc执行的一致性检查的响应。leader为每个follower维护一个nextindex，这是leader将发送给该follower的下一个日志条目的索引。当leader首次掌权时，它将所有nextIndex值初始化为日志中最后一个值之后的索引(图7中的11)。如果follower的日志与leader的日志不一致，AppendEntries一致性检查将在下一个AppendEntries RPC中失败。拒绝后，leader减少nextIndex并重试AppendEntries RPC。最终nextIndex将达到领导者和追随者日志匹配的点。当这种情况发生时，AppendEntries将成功，它将删除follower日志中的任何冲突条目，并从leader日志中添加条目(如果有的话)。一旦AppendEntries成功，跟随者的日志与领导者的日志一致，并且在任期的剩余时间内保持这种状态。</p><p>​如果需要，可以优化协议以减少被拒绝的AppendEntries rpc的数量。例如，在拒绝AppendEntries请求时，follower可以包含冲突条目的项和它为该项存储的第一个索引。有了这些信息，leader就可以对nextIndex进行减量以绕过该项中所有冲突的表项;每个有冲突条目的术语需要一个AppendEntries RPC，而不是每个条目一个RPC。在实践中，我们怀疑这种优化是否必要，因为故障很少发生，而且不太可能有许多不一致的条目。</p><p>​有了这种机制，当涉及到权力时，领导者不需要采取任何特殊操作来恢复日志一致性。它只是开始正常操作，并且日志会自动收敛，以响应追加条目一致性检查失败。leader永远不会覆盖或删除自己日志中的条目(图3中的leader追加属性)。</p><p>​这种日志复制机制展示了第2节中描述的理想的共识属性:只要大多数服务器正常运行，Raft就可以接受、复制和应用新的日志条目;在正常情况下，一个新条目可以通过一轮rpc复制到集群的大多数;一个缓慢的追随者不会影响你的表现。</p><h3 id="v4-安全"><a class="markdownIt-Anchor" href="#v4-安全"></a> V.4 安全</h3><p>​前面的小节描述了Raft如何选择leader和复制日志条目。然而，到目前为止所描述的机制还不足以确保每个状态机以相同的顺序执行完全相同的命令。例如，当leader提交多个日志条目时，follower可能不可用，那么它可以被选为leader并用新的条目覆盖这些条目;因此，不同的状态机可能执行不同的命令序列。</p><p>​本节通过添加服务器可以被选为领导者的限制来完成Raft算法。该限制确保任何给定任期的leader包含在前一任期中提交的所有条目(图3中的leader完整性属性)。考虑到选举限制，我们将使提交规则更加精确。最后，我们给出了Leader完备性的证明草图，并展示了它如何导致复制状态机的正确行为。</p><h4 id="v41-选举限制"><a class="markdownIt-Anchor" href="#v41-选举限制"></a> V.4.1 选举限制</h4><p>​在任何基于领导者的共识算法中，领导者最终必须存储所有已提交的日志条目。在一些共识算法中，如Viewstamped replication，即使leader最初没有包含所有提交的条目，也可以被选举出来。这些算法包含额外的机制来识别缺失的条目，并在选举过程中或之后不久将它们传输给新的领导者。不幸的是，这会导致相当多的附加机制和复杂性。Raft使用了一种更简单的方法，它保证从每一个新的leader被选举的那一刻起，所有以前的承诺条目都存在于leader上，而不需要将这些条目转移到leader上。这意味着日志条目只在一个方向上流动，从领导者到追随者，并且领导者永远不会覆盖其日志中的现有条目。</p><p>​Raft使用投票过程来阻止候选人赢得选举，除非其日志包含所有已提交的条目。候选人必须与集群的大多数成员联系才能当选，这意味着每个提交的条目必须至少出现在其中一台服务器中。如果候选日志至少与大多数日志中的任何其他日志一样最新(“最新”的定义在下面)，那么它将保存所有已提交的条目。RequestVote RPC实现了这个限制:RPC包含关于候选人日志的信息，如果投票人自己的日志比候选人的日志更新，投票人就拒绝投票。</p><p>​Raft通过比较日志中最后条目的索引和期限来确定两个日志中哪一个是最新的。如果日志的最后条目具有不同的术语，那么具有后一个术语的日志是最新的。如果日志以相同的期限结束，那么哪个日志越长，哪个日志就越最新。</p><h4 id="v42-提交以前的条目"><a class="markdownIt-Anchor" href="#v42-提交以前的条目"></a> V.4.2 提交以前的条目</h4><p><img src="../imgs/raft-1/image-20240315215118470.png" alt="图8" /></p><p>​如5.3节所述，leader知道，一旦条目被存储在大多数服务器上，它当前期限的条目就被提交。如果leader在提交条目之前崩溃，未来的leader将尝试完成对条目的复制。然而，一个leader不能立即得出结论，一个前一个term的条目一旦存储在大多数服务器上就被提交了。图8说明了一种情况，其中旧日志条目存储在大多数服务器上，但仍然可以被未来的领导者覆盖。</p><p>​为了消除图8所示的问题，Raft不会通过计算副本来提交以前条目中的日志条目。通过计算副本，只提交leader当前任期内的日志条目;一旦以这种方式提交了当前项中的一个条目，那么由于日志匹配属性，所有先前的条目都将间接提交。在某些情况下，leader可以安全地得出一个较旧的日志条目已提交的结论(例如，如果该条目存储在每个服务器上)，但是Raft为了简单起见采用了更保守的方法。</p><p>​Raft在承诺规则中引入了这种额外的复杂性，因为当leader复制前一项的条目时，日志条目保留其原始的条目编号。在其他共识算法中，如果一个新的leader从先前的“term”中重复复制条目，它必须使用新的“term number”。Raft的方法可以更容易地推断日志条目，因为它们在不同的时间和日志中保持相同的项数。此外，Raft中的新leader发送的以前条目的日志条目比其他算法少(其他算法必须发送冗余的日志条目来重新编号，然后才能提交)。</p><h4 id="v43-安全论证"><a class="markdownIt-Anchor" href="#v43-安全论证"></a> V.4.3 安全论证</h4><p><img src="../imgs/raft-1/image-20240315215633177.png" alt="图9:如果S1(任期T的领导者)从其任期提交了一个新的日志条目，并且S5被选为下一个任期U的领导者，那么必须至少有一个服务器(S3)接受该日志条目并投票给S5。" /></p><p>​给定完整的Raft算法，我们现在可以更精确地论证Leader完备性成立(这个论证是基于安全证明;参见9.2节)。我们假设领先者完备性不成立，然后我们证明了一个矛盾。假设任期T的leader (leaderT)提交了一个来自其术语的日志条目，但是该日志条目没有被某个未来术语的leader存储。考虑最小的任期 U &gt; T，其leader (leaderU)不存储条目。</p><ol><li>承诺的条目必须在其选举时从领导u的日志中消失(领导永远不会删除或覆盖条目)。</li><li>leaderT在大多数集群上复制条目，而leaderU收到大多数集群的投票。因此，至少有一个服务器(“投票人”)接受了来自leaderT的条目并投票给了leadu，如图9所示。选民是达成矛盾的关键。</li><li>投票人必须在投票给leadt之前接受leadt的承诺条目;否则，它将拒绝来自leaderT的AppendEntries请求(其当前项将高于T)。</li><li>投票人在投票给领导u时仍然存储该条目，因为每个介入的领导都包含该条目(假设)，领导永远不会删除条目，而追随者只有在与领导冲突时才删除条目。</li><li>投票人将其选票授予了leaderU，因此leaderU的日志必须与投票人的日志一样是最新的。这导致了两个矛盾之一。</li><li>首先，如果投票者和leaderU共享相同的最后一个日志项，那么leaderU的日志必须至少和投票者的日志一样长，所以它的日志包含投票者日志中的每一个条目。这是一个矛盾，因为选民包含承诺的条目，而领导人被认为没有。</li><li>否则，领导人u的上一个对数项一定大于选民的对数项。而且，它比T大，因为投票人的最后一个日志项至少是T(它包含来自项T的承诺条目)。创建leadu的最后一个日志项的较早的领导者必须在其日志中包含承诺条目(通过假设)。那么，根据日志匹配属性，leaderU的日志必须也包含提交的条目，这是一个矛盾。</li><li>这就解决了矛盾。因此，所有大于T的项的前导必须包含所有在T项中提交的来自T项的项。</li><li>Log Matching Property保证未来的leader也将包含间接提交的条目，如图8(d)中的索引2。</li></ol><p>​间接地，如图8(d)中的索引2。给定Leader完整性属性，我们可以证明图3中的状态机安全属性，该属性表明，如果服务器在给定索引上应用了一个日志条目到其状态机，那么其他服务器将不会为相同的索引应用不同的日志条目。当服务器将一个日志条目应用到它的状态机时，它的日志必须与该条目之前的领导日志相同，并且该条目必须提交。现在考虑任何服务器应用给定日志索引的最低期限;日志完整性属性保证所有较高项的leader将存储相同的日志条目，因此在较低项中应用索引的服务器将应用相同的值。因此，状态机安全属性保持不变。</p><p>​最后，Raft要求服务器按照日志索引顺序应用条目。结合状态机安全属性，这意味着所有服务器将以相同的顺序向其状态机应用完全相同的日志条目集。</p><h3 id="v5-追随者和候选人崩溃"><a class="markdownIt-Anchor" href="#v5-追随者和候选人崩溃"></a> V.5 追随者和候选人崩溃</h3><p>​到目前为止，我们关注的是领导者的失败。跟随者和候选者崩溃比领导者崩溃更容易处理，它们的处理方式是一样的。如果一个follower或candidate崩溃，那么以后发送给它的RequestVote和AppendEntries rpc将失败。Raft通过无限重试来处理这些失败;如果崩溃的服务器重新启动，那么RPC将成功完成。如果服务器在完成RPC之后但在响应之前崩溃，那么它将在重新启动后再次接收相同的RPC。Raft rpc是幂等的，所以这不会造成伤害。例如，如果追随者接收到一个AppendEntries请求，该请求包含其日志中已经存在的日志条目，那么它将忽略新请求中的这些条目。</p><h3 id="v6-时间和可用性"><a class="markdownIt-Anchor" href="#v6-时间和可用性"></a> V.6 时间和可用性</h3><p>​我们对Raft的要求之一是安全性不能依赖于时间:系统不能仅仅因为某些事件发生得比预期的快或慢而产生不正确的结果。然而，可用性(系统及时响应客户机的能力)必须不可避免地依赖于时间。例如，如果消息交换的时间比服务器崩溃之间的典型时间长，候选人就不会坚持足够长的时间来赢得选举;没有稳定的领导，Raft就无法前进。</p><p>​领袖选举是Raft中最关键的环节。只要系统满足以下时间要求，Raft就能够选出并维持一个稳定的leader:</p><p>​<font color='red'>broadcastTime≪ electionTimeout ≪ MTBF</font></p><p>​在这个不等式中，broadcastTime是服务器向集群中的每个服务器并行发送rpc并接收它们的响应所需的平均时间;electionTime-out是5.2节中描述的选举超时;MTBF是单个服务器的平均故障间隔时间。广播时间应该比选举超时时间少一个数量级，这样领导者才能可靠地发送心跳消息，以防止追随者开始选举;考虑到用于选举暂停的随机方法，这种不平等也使得分裂投票不太可能。选举超时应该比MTBF小几个数量级，这样系统才能稳步前进。当leader崩溃时，系统将在选举超时期间不可用;我们希望这只代表总时间的一小部分。</p><p>​广播时间和MTBF是底层系统的属性，而选举超时是我们必须选择的。Raft的rpc通常要求接收方将信息持久化到稳定的存储中，因此广播时间可能在0.5ms到20ms之间，具体取决于存储技术。因此，选举超时可能在10ms到500ms之间。典型的服务器mtbf是几个月或更长时间，这很容易满足时间需求。</p><h2 id="vi-集群成员变更"><a class="markdownIt-Anchor" href="#vi-集群成员变更"></a> VI 集群成员变更</h2><p><img src="../imgs/raft-1/image-20240315220334863.png" alt="图10" /></p><p>​到目前为止，我们已经假设集群配置(参与共识算法的服务器集)是固定的。在实践中，有时需要更改配置，例如在服务器发生故障时更换服务器或更改复制的程度。虽然这可以通过使整个集群脱机、更新配置文件、然后重新启动集群来实现，但这会使集群在转换期间不可用。此外，如果有任何手动步骤，则有操作员出错的风险。为了避免这些问题，我们决定将配置更改自动化，并将其合并到Raft共识算法中。</p><p>​为了保证配置变更机制的安全性，在过渡期间不可能出现两名领导人在同一任期内当选的情况。不幸的是，服务器直接从旧配置切换到新配置的任何方法都是不安全的。一次自动切换所有服务器是不可能的，因此集群可能在转换期间分裂成两个独立的多数(参见图10)。</p><p>​为了确保安全，配置更改必须使用两阶段方法。有多种方法可以实现这两个阶段。例如，一些系统(例如，[22])使用第一阶段禁用旧配置，因此它不能处理客户端请求;然后，第二阶段启用新配置。在Raft中，集群首先切换到我们称之为联合共识的过渡配置;一旦联合共识被提交，系统就会转换到新的配置。联合共识结合了新旧两种配置:</p><ul><li>日志条目被复制到两种配置中的所有服务器。</li><li>任一配置中的任何服务器都可以作为leader。</li><li>协议(对于选举和进入承诺)需要从旧的和新的配置中分离多数。</li></ul><p>​联合共识允许单个服务器在不同的时间在配置之间转换，而不会出现安全问题。此外，联合共识允许集群在整个配置更改期间继续为客户机请求提供服务。</p><p>​集群配置使用复制日志中的特殊条目进行存储和通信;图11说明了配置更改过程。当leader接收到将配置从Cold更改为C（new）的请求时，它将联合共识(图中为C（old,new）)的配置存储为日志条目，并使用前面描述的机制复制该条目。一旦给定的服务器将新的配置条目添加到其日志中，它就会在以后的所有决策中使用该配置(服务器总是在其日志中使用最新的配置，而不管该条目是否已提交)。这意味着领导者将使用C（old,new）的规则来确定何时提交C（old,new）的日志条目。如果leader崩溃，根据获胜的候选人是否收到了Cold,new，来选择一个新的leader。无论如何，在此期间，中国不能做出单方面的决定。</p><p><img src="../imgs/raft-1/image-20240315225354334.png" alt="图11" /></p><p>​一旦提交了Cold,new，两个服务器都不能在未经对方批准的情况下做出决定，并且Leader完整性属性确保只有具有C（old,new）日志条目的服务器才能被选为Leader。现在，leader可以安全地创建描述C（new）的日志条目并将其复制到集群中。同样，一旦看到此配置，该配置将在每个服务器上生效。当在C（new）规则下提交新配置时，旧配置是不相关的，不在新配置中的服务器可以关闭。如图11所示，不存在C（old）和C（new）同时做出单边决策的情况;这保证了安全。</p><p>​对于重新配置，还有三个问题需要解决。第一个问题是，新服务器最初可能不存储任何日志条目。如果以这种状态将它们添加到集群中，它们可能需要一段时间才能赶上进度，在此期间可能无法提交新的日志条目。为了避免可用性差距，Raft在配置更改之前引入了一个额外的阶段，在这个阶段中，新服务器作为无投票成员加入集群(leader向它们复制日志条目，但它们不被认为是majority)。一旦新服务器赶上了集群的其余部分，就可以按照上面的描述进行重新配置。</p><p>​第二个问题是集群领导者可能不是新配置的一部分。在这种情况下，leader一旦提交了C（new）日志条目，就会退出(返回到follower状态)。这意味着会有一段时间(当它正在提交C(new)时)，当leader管理一个不包括它自己的集群时;它复制日志条目，但不认为自己占多数。leader转换发生在C（new）提交时，因为这是新配置可以独立操作的第一个点(总是可以从C(new)中选择leader)。在此之前，可能只有来自C(old)的服务器可以被选为leader。</p><p>​第三个问题是被移除的服务器(不在C(new)中的服务器)可能会破坏集群。这些服务器将不会接收到心跳，因此它们将超时并开始新的选举。然后，它们将发送带有新术语号的RequestVote rpc，这将导致当前的领导者恢复到追随者状态。新的领导人最终会被选举出来，但是被移除的服务器会再次超时，这个过程会重复，导致可用性差。</p><p>​为了防止这个问题，当服务器认为当前的leader存在时，它们会忽略RequestVote rpc。具体地说，如果服务器在听取当前领导者的最小选举超时时间内收到RequestVote RPC，则它不会更新其任期或授予其投票。这不会影响正常的选举，其中每个服务器在开始选举之前至少等待最小的选举超时。然而，它有助于避免被移除的服务器造成的中断:如果一个leader能够将心跳传送到它的集群，那么它就不会被更大的term number所取代。</p><h2 id="vii-日志压缩"><a class="markdownIt-Anchor" href="#vii-日志压缩"></a> VII 日志压缩</h2><p>​Raft的日志在正常运行期间会增长，以包含更多的客户端请求，但在实际系统中，它不能无限制地增长。随着日志变长，它会占用更多的空间，并且需要更多的时间来重放。如果没有某种机制来丢弃日志中积累的过时信息，这将最终导致可用性问题。</p><p>​快照是最简单的压缩方法。在快照中，整个当前系统状态被写入稳定存储上的快照，然后直到该点的整个日志被丢弃。快照在Chubby和ZooKeeper中使用，本节的其余部分描述了Raft中的快照。</p><p>​增量压缩方法，如日志清理和日志结构合并树，也是可能的。它们一次对一小部分数据进行操作，因此它们随着时间的推移更均匀地分散了压缩的负载。它们首先选择一个数据区域，该区域累积了许多已删除和覆盖的对象，然后更紧凑地重写该区域的活动对象，并释放该区域。与快照相比，这需要大量额外的机制和复杂性，快照通过始终对整个数据集进行操作来简化问题。虽然日志清理需要修改Raft，但状态机可以使用与快照相同的接口实现LSM树。</p><p><img src="../imgs/raft-1/image-20240315225801111.png" alt="图12" /></p><p>​图12显示了Raft中快照的基本思想。每个服务器独立地获取快照，只覆盖其日志中提交的条目。大部分工作包括状态机将其当前状态写入快照。Raft还在快照中包含少量元数据:最后包含的索引是快照替换的日志中最后一个条目的索引(状态机应用的最后一个条目)，最后包含的术语是该条目的术语。保留这些内容是为了支持对快照之后的第一个日志条目进行AppendEntries一致性检查，因为该条目需要之前的日志索引和期限。为了启用集群成员变更(第6节)，快照还包括日志中上次包含索引时的最新配置。一旦服务器完成对快照的写入，它可能会删除直到最后包含的索引的所有日志条目，以及任何先前的快照。</p><p>​虽然服务器通常会独立地拍摄快照，但领导者偶尔必须向落后的追随者发送快照。当领导者已经丢弃了它需要发送给追随者的下一个日志条目时，就会发生这种情况。幸运的是，在正常操作中不太可能出现这种情况:跟随领导者的追随者已经有了这个条目。但是，异常缓慢的追随者或加入集群的新服务器(第6节)不会这样做。让这样的追随者与时俱进的方法是，领导者通过网络向其发送快照。</p><p><img src="../imgs/raft-1/image-20240315225927519.png" alt="图13:InstallSnapshot RPC的摘要。快照被分成块进行传输;这为follower提供了每个块的生命迹象，因此它可以重置其选举计时器。" /></p><p>​leader使用一个名为InstallSnapshot的新RPC向远远落后的follower发送快照;参见图13。当跟踪者接收到带有此RPC的快照时，它必须决定如何处理其现有的日志条目。通常，快照将包含收件人日志中尚未包含的新信息。在这种情况下，追随者丢弃其整个日志;它全部被快照取代，并且可能有与快照冲突的未提交条目。如果跟随者接收到描述其日志前缀的快照(由于重传或错误)，则快照所涵盖的日志条目将被删除，但快照后面的条目仍然有效，必须保留。</p><p>​这种快照方法违背了Raft的强领导原则，因为追随者可以在领导者不知情的情况下拍摄快照。然而，我们认为这种离开是合理的。虽然有一个领导者有助于在达成共识时避免冲突的决策，但在快照时已经达成了共识，因此没有决策冲突。数据仍然只能从领导者流向追随者，现在只有追随者可以重组他们的数据。</p><p>​我们考虑了另一种基于领导者的方法，其中只有领导者创建快照，然后将此快照发送给其每个追随者。然而，这有两个缺点。首先，将快照发送给每个关注者会浪费网络带宽并减慢快照进程。每个follower都已经拥有了生成自己的快照所需的信息，对于服务器来说，从其本地状态生成快照通常比通过网络发送和接收快照要便宜得多。其次，领导人的执行将更加复杂。例如，领导者需要向追随者发送快照，同时向他们复制新的日志条目，以便不阻止新的客户机请求。</p><p>​还有两个问题会影响快照性能。首先，服务器必须决定何时快照。如果服务器快照太频繁，会浪费磁盘带宽和能量;如果它的快照频率太低，就有耗尽存储容量的风险，并且会增加重新启动期间重播日志所需的时间。一个简单的策略是在日志达到固定大小(以字节为单位)时拍摄快照。如果将此大小设置为明显大于快照的预期大小，则用于快照的磁盘带宽开销将很小。</p><p>​第二个性能问题是，编写快照可能会花费大量时间，我们不希望这会延迟正常操作。解决方案是使用写时复制(copy-on-write)技术，这样就可以接受新的更新，而不会影响正在写入的快照。例如，用函数数据结构构建的状态机自然支持这一点。或者，可以使用操作系统的写时复制支持(例如Linux上的fork)来创建整个状态机的内存快照(我们的实现使用这种方法)。</p><h2 id="iix-客户端交互"><a class="markdownIt-Anchor" href="#iix-客户端交互"></a> IIX 客户端交互</h2><p>​本节描述客户端如何与Raft交互，包括客户端如何找到集群领导者以及Raft如何支持线性化语义。这些问题适用于所有基于共识的系统，Raft的解决方案与其他系统类似。</p><p>​Raft的客户将他们所有的请求发送给leader。当客户机第一次启动时，它连接到一个随机选择的服务器。如果客户端的第一选择不是leader，服务器将拒绝客户端的请求，并提供最近收到的leader的信息(AppendEntries请求包括leader的网络地址)。如果leader崩溃，客户端请求将超时;然后客户端使用随机选择的服务器再次尝试。</p><p>​Raft的目标是实现可线性化的语义(每个操作在调用和响应之间的某个点上似乎是瞬间执行的，只执行一次)。然而，正如目前所描述的，Raft可以多次执行命令:例如，如果leader在提交日志条目之后崩溃，但在响应客户端之前，客户端将使用新的leader重试命令，导致它被执行第二次。解决方案是让客户端为每个命令分配唯一的序列号。然后，状态机跟踪为每个客户机处理的最新序列号，以及相关的响应。如果它接收到一个序列号已经被执行的命令，它会立即响应而不重新执行请求。</p><p>​可以在不向日志中写入任何内容的情况下处理只读操作。然而，如果没有额外的措施，这将有返回陈旧数据的风险，因为响应请求的leader可能已经被它不知道的新leader所取代。可linearizable读一定不能返回陈旧的数据，Raft需要两个额外的预防措施来保证这一点，而不使用日志。首先，leader必须拥有提交条目的最新信息。Leader完整性属性保证Leader拥有所有已提交的条目，但在其任期开始时，Leader可能不知道哪些是已提交的条目。为了找出答案，它需要提交其任期中的一个条目。Raft通过让每个leader在其任期开始时提交一个空白的无操作条目到日志中来处理这个问题。其次，leader必须在处理一个只读请求之前检查它是否已经被废弃(如果一个最近的leader被选举出来，它的信息可能是陈旧的)。Raft通过让leader在响应只读请求之前与大多数集群交换心跳消息来处理这个问题。或者，leader可以依赖心跳机制来提供一种形式的租约[9]，但这将依赖于安全的定时(它假设有界时钟倾斜)。</p><h2 id="ix-执行与评估"><a class="markdownIt-Anchor" href="#ix-执行与评估"></a> IX 执行与评估</h2><p>​我们已经将Raft作为复制状态机的一部分实现，该状态机存储RAMCloud的配置信息，并协助RAMCloud协调器的故障转移。Raft实现包含大约2000行c++代码，不包括测试、注释或空白行。源代码是免费提供的。根据本文的草稿，目前大约有25个独立的第三方开源的Raft实现[34]处于不同的开发阶段。此外，许多公司正在部署基于raft的系统。</p><p>​本节的其余部分使用三个标准来评估Raft:可理解性、正确性和性能。</p><h3 id="ix1-可理解性"><a class="markdownIt-Anchor" href="#ix1-可理解性"></a> IX.1 可理解性</h3><p><img src="../imgs/raft-1/image-20240315230558611.png" alt="图15" /></p><p>​为了衡量Raft相对于Paxos的可理解性，我们对斯坦福大学高级操作系统课程和加州大学伯克利分校分布式计算课程的高年级本科生和研究生进行了一项实验研究。我们录制了Raft和Paxos的视频讲座，并制作了相应的小测验。Raft讲座涵盖了这篇论文的内容，除了原木的压缩;Paxos讲座涵盖了足够的材料来创建一个等效的复制状态机，包括单命令Paxos、多命令Paxos、重新配置和实践中需要的一些优化(例如领导者选举)。这些测试测试了学生对算法的基本理解，也要求他们对极端情况进行推理。每个学生看了一个视频，做了相应的测试，看了第二个视频，做了第二个测试。大约一半的参与者先做了Paxos部分，另一半先做了Raft部分，以解释个人在表现和从第一部分研究中获得的经验上的差异。我们比较了参与者在每个测验中的得分，以确定参与者是否对Raft有更好的理解。</p><p>​我们试图在Paxos和Raft之间进行尽可能公平的比较。实验在两个方面对Paxos有利:43名参与者中有15人报告说他们之前有过Paxos的一些经验，Paxos的视频比Raft的视频长14%。如表1所示，我们已采取措施减轻潜在的偏倚来源。我们所有的资料都可以查阅。</p><p>​平均而言，参与者在Raft测试中的得分比Paxos测试高4.9分(在可能的60分中，Raft的平均得分为25.7分，Paxos的平均得分为20.8分);图14显示了他们的个人分数。配对t检验表明，在95%的置信度下，Raft分数的真实分布均值至少比Paxos分数的真实分布均值大2.5分。</p><p>​我们还创建了一个线性回归模型，可以根据三个因素预测新学生的测验分数:他们参加的测验，他们之前Paxos的经验程度，以及他们学习算法的顺序。该模型预测，测验的选择会产生12.5分的差异，从而有利于Raft。这明显高于观察到的4.9分的差异，因为许多实际学生之前都有Paxos的经验，这对Paxos有很大帮助，而对Raft的帮助略小。奇怪的是，该模型还预测，已经参加过Paxos测试的人在Raft上的得分要低6.3分;虽然我们不知道为什么，但这在统计上确实很重要。</p><p>​我们还在测试结束后对参与者进行了调查，看看他们觉得哪种算法更容易实现或解释;这些结果如图15所示。绝大多数参与者表示Raft更容易实现和解释(每个问题41个中有33个)。然而，这些自我报告的感觉可能不如参与者的测验分数可靠，参与者可能因为我们的假设(Raft更容易理解)而有偏见。</p><h3 id="ix2-正确性"><a class="markdownIt-Anchor" href="#ix2-正确性"></a> IX.2 正确性</h3><p>​我们已经开发了第5节中描述的共识机制的正式规范和安全性证明。正式规范[31]使用TLA+规范语言[17]使得图2中总结的信息完全精确。它大约有400行，是证明的主体。对于任何实现Raft的人来说，它本身也很有用。我们已经用TLA证明系统[7]机械地证明了对数完备性。然而，这种证明依赖于没有经过机械检查的不变量(例如，我们还没有证明规范的类型安全性)。此外，我们已经写了一个状态机安全属性的非正式证明[31]，它是完整的(它只依赖于规范)和相对精确的(大约3500字长)。</p><h3 id="ix3-性能"><a class="markdownIt-Anchor" href="#ix3-性能"></a> IX.3 性能</h3><p><img src="../imgs/raft-1/image-20240315230821442.png" alt="图16:检测和替换崩溃的leader的时间。顶部的图改变了选举超时的随机性，底部的图缩放了最小的选举超时。每条线代表1000次试验(“150-150ms”的100次试验除外)，对应于一个特定的选举超时选择;例如，“150-155ms”表示在150ms到155ms之间随机且均匀地选择选举超时。这些测量是在一个由5个服务器组成的集群上进行的，广播时间大约为15毫秒。对于包含9台服务器的集群，结果类似。" /></p><p>​Raft的性能与Paxos等其他共识算法类似。对于性能来说，最重要的情况是当一个已建立的leader复制新的日志条目时。Raft使用最少数量的消息(从leader到一半集群的单次往返)实现了这一点。也有可能进一步提高Raft的性能。例如，它很容易支持批处理和流水线请求，以获得更高的吞吐量和更低的延迟。文献中对其他算法提出了各种优化;其中许多可以应用到Raft中，但我们将其留给未来的工作。</p><p>​我们使用Raft实现来衡量Raft领导者选举算法的性能，并回答了两个问题。首先，选举过程会很快趋同吗?其次，在leader崩溃后可以实现的最小停机时间是多少?</p><p>​为了测量leader的选举，我们反复地使一个由5个服务器组成的集群的leader崩溃，并计算检测到崩溃和选举新leader所花费的时间(参见图16)。为了产生最坏的情况，每个试验中的服务器具有不同的日志长度，因此一些候选人没有资格成为领导者。此外，为了鼓励分裂投票，我们的测试脚本在终止其进程之前触发了来自leader的心跳rpc的同步广播(这近似于leader在崩溃之前复制新日志条目的行为)。leader在心跳间隔内均匀随机崩溃，心跳间隔为所有测试的最小选举超时的一半。因此，最小的可能停机时间大约是最小选举超时的一半。</p><p>​图16中最上面的图表显示，选举超时中的少量随机化足以避免选举中的分裂投票。在没有随机性的情况下，在我们的测试中，由于许多选票分裂，领导人选举持续花费超过10秒的时间。仅仅增加5ms的随机性就有很大帮助，导致停机时间中值为287ms。使用更多的随机性可以改善最坏情况下的行为:当随机性为50ms时，最坏情况下的完成时间(超过1000次试验)为513ms。</p><p>​图16底部的图表显示，可以通过减少选举超时来减少停机时间。在选举超时为12-24ms的情况下，平均只需35ms就能选出一个leader(最长的一次试验花费了152ms)。然而，将超时时间降低到超过这个点违反了Raft的时间要求:在其他服务器开始新的选举之前，领导者很难广播心跳。这可能导致不必要的领导更改，并降低整个系统的可用性。我们建议使用保守的选举超时，例如150-300ms;这样的暂停不太可能导致不必要的领导人变动，而且仍然会提供良好的可用性。</p><h2 id="x-总结"><a class="markdownIt-Anchor" href="#x-总结"></a> X 总结</h2><p>​算法的设计通常以正确性、效率和/或简洁性为主要目标。虽然这些都是有价值的目标，但我们相信可理解性同样重要。在开发人员将算法转化为实际实现之前，其他目标都无法实现，而实际实现将不可避免地偏离并扩展已发布的形式。除非开发人员对算法有深刻的理解，并且能够创建关于它的直觉，否则他们很难在实现中保留其理想的属性。</p><p>​在本文中，我们讨论了分布式共识的问题，其中一个被广泛接受但难以理解的算法Paxos多年来一直挑战着学生和开发人员。我们开发了一种新的算法Raft，我们已经证明它比Paxos更容易理解。我们也相信Raft为系统构建提供了更好的基础。将可理解性作为主要设计目标改变了我们设计《Raft》的方式;随着设计的进展，我们发现自己重复使用了一些技术，比如分解问题和简化状态空间。这些技术不仅提高了Raft的可理解性，而且使我们更容易相信它的正确性。</p>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>mit6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mapreduce</title>
    <link href="/2024/03/14/mapreduce/"/>
    <url>/2024/03/14/mapreduce/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="mapreduce在大型集群上的简易数据处理"><a class="markdownIt-Anchor" href="#mapreduce在大型集群上的简易数据处理"></a> MapReduce:在大型集群上的简易数据处理</h1><h2 id="摘要"><a class="markdownIt-Anchor" href="#摘要"></a> 摘要</h2><p>​MapReduce是一种用于处理和生成大型数据集的编程模型和相关实现。用户使用map函数处理kv对，生成一个中间value和中间key，使用reduce函数merge所有的中间kv键。很多现实世界任务都可以用这个模型来表示。</p><p>​用这种函数式风格编写的程序被自动并行化，并在大量的商用机器上执行。运行时系统负责对输入数据进行分区、在一组机器上调度程序的执行、处理机器故障以及管理所需的机器间通信等细节。这让程序员不需要理解并行和分布式系统就能很轻易地使用大型分布式系统的资源。</p><h2 id="1-介绍"><a class="markdownIt-Anchor" href="#1-介绍"></a> 1 介绍💦</h2><p>​在过去的五年中，作者和谷歌的许多其他人已经实现了数百种特殊用途的计算，这些计算处理大量的原始数据，如抓取的文档、web请求日志等，以计算各种派生数据，如倒排索引、web文档的图形结构的各种表示、每个主机抓取的页面数量的摘要、给定一天中最频繁的查询集等。大多数这样的计算在概念上是直截了当的。然而，输入数据通常很大，计算必须分布在数百或数千台机器上，以便在合理的时间内完成。如何并行化计算、分布数据和处理故障等问题，使得原始的简单计算用大量复杂的代码来处理这些问题变得模糊不清。</p><p>​作为对这种复杂性的反应，我们设计了一个新的抽象，它允许我们表达我们试图执行的简单计算，但隐藏了库中并行化、容错、数据分布和负载平衡的混乱细节。我们的抽象受到Lisp和其他函数式语言中map和reduce原语的启发。我们意识到，大多数计算涉及对输入中每个逻辑“记录”应用map操作，以计算一组中间键/值对，然后对共享同一键的所有值应用reduce操作，以便适当地组合派生数据。通过使用带有用户指定map和reduce操作的功能模型，我们能够轻松并行化大型计算，并将重新执行作为主要容错机制。</p><p>​这个工作的主要贡献是一个简单但强大的支持大规模计算的自动并行化和分布的接口。与此接口的实现相结合，在大型商用pc集群上实现高性能。第2节描述了基本的编程模型，并给出了几个示例。第3节描述了针对基于集群的计算环境量身定制的MapReduce接口的实现。第4节描述了我们认为有用的编程模型的几个改进。第5节对各种任务的实现进行了性能度量。第6节探讨了MapReduce在Google中的使用，包括我们使用它作为重写我们的生产索引系统的基础的经验。第7节讨论了相关的和未来的工作。</p><h2 id="2-编程模型"><a class="markdownIt-Anchor" href="#2-编程模型"></a> 2 编程模型💦</h2><p>​计算需要一组kv对输入，并且输出一组kv对。<strong>mapreduce</strong>主要是两个函数：<strong>Map</strong>和<strong>Reduce</strong>。</p><p>​<strong>Map</strong>接受一个输入对并且产生一个中间kv对。MapReduce库将与中间key<strong>I</strong>相同的的所有中间值分组，并且把它们传递到Reduce函数中。</p><p>​<strong>Reduce</strong>函数接受一个中间key<strong>I</strong>和一组与key相对应的value，它将这些value合并起来形成一个可能更小的值集，一般是输出一个key一个value。中间值通过迭代器提供给用户的reduce函数。这允许我们处理大到内存无法容纳的值列表。</p><h3 id="21-example"><a class="markdownIt-Anchor" href="#21-example"></a> 2.1 Example</h3><p>​单词计数器，伪代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">map</span>(String key, String value): <br>// key: document name <br>// value: document contents <br><span class="hljs-keyword">for</span> each word w <span class="hljs-keyword">in</span> value: <br>EmitIntermediate(w, <span class="hljs-string">&quot;1&quot;</span>); <br><br>reduce(String key, Iterator values): <br>// key: a word <br>// values: a <span class="hljs-built_in">list</span> of counts <span class="hljs-built_in">int</span> result = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> each v <span class="hljs-keyword">in</span> values: <br>result += ParseInt(v); <br>Emit(AsString(result));<br></code></pre></td></tr></table></figure><p>​map函数发出每个单词加上相关的出现次数计数,reduce函数将针对特定单词发出的所有计数求和。</p><p>​此外，用户编写代码，用输入和输出文件的名称以及可选的调优参数填充mapreduce规范对象。然后，用户调用MapReduce函数，将规范对象传递给它。用户的代码与MapReduce库(用c++实现)链接在一起。附录A包含这个示例的完整程序文本。</p><h3 id="22-types"><a class="markdownIt-Anchor" href="#22-types"></a> 2.2 Types</h3><p>​尽管前面的伪代码是根据字符串输入和输出编写的，但从概念上讲，用户提供的map和reduce函数具有相关的类型:</p><p><img src="../imgs/mapreduce/image-20240314162209411.png" alt="image-20240314162209411" /></p><p>​输入键和值是从与输出键和值不同的域中绘制的。此外，中间键和值与输出键和值来自相同的domain。</p><p>​我们的c++实现将字符串传递给用户定义函数，并将其留给用户代码在字符串和适当类型之间进行转换。</p><h3 id="23-more-examples"><a class="markdownIt-Anchor" href="#23-more-examples"></a> 2.3 More Examples</h3><p>​Distributed Grep: 如果map函数匹配提供的模式，则会发出一行。reduce函数是一个恒等函数，它只是将提供的中间数据复制到输出。</p><p>​Count of URL Access Frequency: map函数处理web页面请求日志，输出&lt;URL,1&gt;。reduce函数将同一URL的所有值相加，并发出一个&lt; RL,total count&gt;对。</p><p>​Reverse Web-Link Graph: map函数为在名为source的页面中找到的每个指向目标URL的链接输出&lt;target,source&gt;对。reduce函数将与给定目标URL相关联的所有源URL的列表连接起来，并发出对:&lt;target, list(source)&gt;</p><p>​Term-Vector per Host: 术语向量是将文档或一组文档中最重要的单词总结为&lt;word, frequency&gt;对的列表。map函数会针对每个输入文档生成一个&lt;hostname, term vector&gt;对（其中主机名从文档的URL中提取）。reduce函数会合并给定主机下所有文档的术语向量，将它们相加，并丢弃不常见的术语，最终输出&lt;hostname, term vector&gt;对。</p><p>​Inverted Index: map函数解析每个文档，并发出&lt;word,document ID&gt;对的序列。reduce函数接受给定单词的所有对，对相应的文档ID进行排序并发出&lt;word, list(文档ID)&gt;对。所有输出对的集合形成一个简单的倒排索引。很容易增加这个计算来跟踪单词的位置。</p><p>​Distributed Sort: map函数从每个记录中提取键，并发出一个&lt;key,record&gt;对。reduce函数不加更改地发出所有对。这种计算依赖于第4.1节中描述的分区工具和第4.2节中描述的排序属性。</p><h2 id="3-实现"><a class="markdownIt-Anchor" href="#3-实现"></a> 3 实现</h2><p><img src="../imgs/mapreduce/image-20240314163016983.png" alt="图1：执行概述" /></p><p>​MapReduce接口可能有许多不同的实现。正确的选择取决于环境。例如，一种实现可能适用于小型共享内存机器，另一种适用于大型NUMA多处理器，还有一种适用于更大的联网机器集合。</p><p>​本节描述了针对Google广泛使用的计算环境的实现:大型商用pc集群通过交换以太网连接在一起。在我们的环境中:</p><ol><li>机器通常是运行Linux的双处理器x86处理器，每台机器有2-4 GB内存。</li><li>使用的是商用网络硬件——通常在机器级别上是100兆比特/秒或1千兆比特/秒，但总体对分带宽平均要少得多。</li><li>集群由数百或数千台机器组成，因此机器故障很常见。</li><li>存储由直接连接到单个机器上的廉价IDE磁盘提供。内部开发的分布式文件系统用于管理存储在这些磁盘上的数据。文件系统使用复制在不可靠的硬件之上提供可用性和可靠性。</li><li>用户向调度系统提交作业。每个作业由一组任务组成，并由调度器映射到集群中的一组可用机器。</li></ol><h3 id="31-执行概述"><a class="markdownIt-Anchor" href="#31-执行概述"></a> 3.1 执行概述</h3><p>​通过自动将输入数据划分为M段，Map调用可以在多台机器上进行分布式处理。不同的机器可以并行处理输入分割。Reduce调用是通过使用分区函数（例如hash(key) mod R）将中间键空间划分为R块来进行分发的。用户可以指定要使用的分区数量®和分区函数。</p><p>​图1显示了我们实现中MapReduce操作的整体流程。当用户程序调用MapReduce函数时，会发生以下一系列动作(图1中的编号标签对应于下面列表中的数字):</p><ol><li>MapReduce库将输入文件从m个16-64mb的小文件，然后，它在一个机器集群上启动该程序的许多副本。</li><li>这个节目的其中一份拷贝是特别的——master。其余的是由master分配工作的worker。有M个map任务和R个reduce任务要分配。主机选择空闲的worker，并为每个worker分配一个map任务或reduce任务。</li><li>被分配映射任务的worker线程读取相应输入分割的内容。它从输入数据中解析键/值对，并将每对传递给用户定义的Map函数。Map函数产生的中间键/值对在内存中进行缓冲。</li><li>周期性地将缓冲对写入本地磁盘，并通过分区函数划分为R个区域。这些缓冲对在本地磁盘上的位置被传递回主服务器，主服务器负责将这些位置转发给reduce worker。</li><li>当主服务器通知reduce worker有关这些位置时，它使用远程过程调用从map worker的本地磁盘读取缓冲数据。当reduce工作程序读取了所有中间数据后，它按中间键对数据进行排序，以便将所有出现的相同键分组在一起。排序是必要的，因为通常有许多不同的键映射到相同的reduce任务。如果中间数据量太大，内存无法容纳，则使用外部排序。</li><li>reduce worker遍历已排序的中间数据，对于遇到的每个唯一的中间键，它将键和相应的中间值集传递给用户的reduce函数。Reduce函数的输出被附加到这个Reduce分区的最终输出文件中。</li><li>当所有map任务和reduce任务完成后，主程序唤醒用户程序。此时，用户程序中的MapReduce调用返回到用户代码。</li></ol><p>​成功完成后，maprereduce执行的输出在R输出文件中可用(每个reduce任务一个，文件名由用户指定)。通常，用户不需要将这些R输出文件合并到一个文件中——他们经常将这些文件作为输入传递给另一个MapReduce调用，或者从另一个能够处理分区为多个文件的输入的分布式应用程序中使用它们。</p><h3 id="32-master数据结构"><a class="markdownIt-Anchor" href="#32-master数据结构"></a> 3.2 master数据结构</h3><p>​master保留了几个数据结构。对于每个map任务和reduce任务，它存储状态(空闲、正在进行或已完成)以及工作机器的标识(对于非空闲任务)。</p><p>​主节点是将中间文件区域的位置从map任务传播到reduce任务的通道。因此，对于每一个完成的map任务，master存储由map任务产生的R个中间文件区域的位置和大小。当地图任务完成时，会收到对该位置和大小信息的更新。这些信息被逐步推送给正在执行减少任务的工作人员。</p><h3 id="33-容错性"><a class="markdownIt-Anchor" href="#33-容错性"></a> 3.3 容错性</h3><p>​由于MapReduce库的设计目的是帮助处理使用数百或数千台机器的大量数据，因此库必须优雅地容忍机器故障。</p><h4 id="worker"><a class="markdownIt-Anchor" href="#worker"></a> worker</h4><p>​主服务器定期ping每个worker。如果在一定时间内没有收到来自worker的响应，则主程序将该worker标记为失败。该worker完成的任何map任务都将被重置回其初始空闲状态，因此可以在其他worker上进行调度。类似地，在失败的worker上正在进行的任何map任务或reduce任务也被重置为空闲，并有资格重新调度。</p><p>​完成的映射任务在发生故障时重新执行，因为它们的输出存储在故障机器的本地磁盘上，因此无法访问。完成的reduce任务不需要重新执行，因为它们的输出存储在全局文件系统中。</p><p>​当一个映射任务首先由工人a执行，然后由工人B执行(因为a失败了)，所有的执行reduce任务的worker会收到重新执行的通知。任何尚未从worker A读取数据的reduce任务都将从worker B读取数据。</p><p>​MapReduce对大规模worker故障具有弹性。例如，在一次MapReduce操作期间，正在运行的集群上的网络维护导致80台机器组成的组在几分钟内无法访问。MapReduce主节点只是重新执行无法到达的工作机器所做的工作，并继续向前推进，最终完成MapReduce操作。</p><h4 id="master"><a class="markdownIt-Anchor" href="#master"></a> master</h4><p>​让主写入上述主数据结构的定期检查点是很容易的。如果主任务终止，则可以从最后一个检查点状态开始新的副本。然而，考虑到只有一个主人，它不太可能失败;因此，如果主节点失败，我们当前的实现会中止MapReduce的计算。客户端可以检查这种情况，如果需要的话，可以重试MapReduce操作。</p><h4 id="故障时的语义表现"><a class="markdownIt-Anchor" href="#故障时的语义表现"></a> 故障时的语义表现</h4><p>​当用户提供的map和reduce操作符是其输入值的确定性函数时，我们的分布式实现产生的输出与整个程序的非错误顺序执行所产生的输出相同。</p><p>​我们依靠map的原子提交和reduce任务输出来实现这个属性。每个正在进行的任务将其输出写入私有临时文件。一个reduce任务生成一个这样的文件，一个map任务生成R个这样的文件(每个reduce任务生成一个)。当map任务完成时，worker向master发送一条消息，并在消息中包含R临时文件的名称。如果主机接收到已经完成的映射任务的完成消息，则忽略该消息。否则，它将在主数据结构中记录R文件的名称。</p><p>​当reduce任务完成时，reduce worker自动将其临时输出文件重命名为最终输出文件。如果在多台机器上执行相同的reduce任务，则将对相同的最终输出文件执行多个重命名调用。我们依赖底层文件系统提供的原子重命名操作来保证最终文件系统状态只包含一次reduce任务执行所产生的数据。</p><p>​我们的绝大多数map和reduce操作符都是确定性的，在这种情况下，我们的语义等同于顺序执行，这使得程序员很容易推断他们的程序行为。当map和/或reduce操作符不确定时，我们提供较弱但仍然合理的语义。在存在非确定性操作符的情况下，特定reduce任务R1的输出相当于非确定性程序的顺序执行对R1产生的输出。然而，不同的reduce任务R2的输出可能对应于不确定性程序的不同顺序执行所产生的R2的输出。</p><p>​考虑map任务M和reduce任务R1和R2。设e(Ri)为所提交的Ri的执行(只有一次这样的执行)较弱的语义出现是因为e(R1)可能读取了一次M执行产生的输出，而e(R2)可能读取了另一次M执行产生的输出。</p><h3 id="34-locality"><a class="markdownIt-Anchor" href="#34-locality"></a> 3.4 Locality</h3><p>​网络带宽在我们的计算环境中是一种相对稀缺的资源。我们利用输入数据(由GFS管理)存储在组成集群的机器的本地磁盘这一事实来节省网络带宽。GFS将每个文件划分为64 MB的块，并在不同的机器上存储每个块的几个副本(通常是3个副本)。MapReduce主程序将输入文件的位置信息考虑在内，并尝试在包含相应输入数据副本的机器上调度地图任务。如果失败，它会尝试在该任务输入数据的副本附近调度一个map任务(例如，在与包含数据的机器位于同一网络交换机上的工作机器上)。当在集群中相当一部分worker上运行大型MapReduce操作时，大多数输入数据都是在本地读取的，不消耗网络带宽。</p><h3 id="35-任务粒度"><a class="markdownIt-Anchor" href="#35-任务粒度"></a> 3.5 任务粒度</h3><p>​我们将map阶段细分为M个片段，reduce阶段细分为R个片段，如上所述。理想情况下，M和R应该比工作机器的数量大得多。让每个worker执行许多不同的任务可以改善动态负载平衡，并且还可以在一个worker失败时加快恢复速度:它完成的许多map任务可以分散到所有其他worker机器上。</p><p>​在我们的实现中，M和R的大小是有实际限制的，因为主机必须做出O(M + R)个调度决策，并如上所述在内存中保持O(M * R)个状态。(然而，内存使用的恒定因素很小:状态的O(M * R)块由每个map任务/reduce任务对大约一个字节的数据组成。)</p><p>​此外，R经常受到用户的约束，因为每个reduce任务的输出最终都在一个单独的输出文件中。在实践中，我们倾向于选择M，这样每个单独的任务大约有16 MB到64 MB的输入数据(这样上面描述的局部性优化是最有效的)，我们让R是我们期望使用的工作机器数量的一个小倍数。我们经常使用2000台工作机器，在M = 200000和R = 5000的情况下执行MapReduce计算。</p><h3 id="36-备份任务"><a class="markdownIt-Anchor" href="#36-备份任务"></a> 3.6 备份任务</h3><p>​导致MapReduce操作总时间延长的常见原因之一是“掉队者”:在计算过程中，一台机器花了很长时间才完成最后几个map或reduce任务中的一个。掉队者的出现有很多原因。例如，具有坏磁盘的机器可能会遇到频繁的可纠正错误，从而使其读取性能从30 MB/s降低到1 MB/s。集群调度系统可能已经调度了机器上的其他任务，由于CPU、内存、本地磁盘或网络带宽的竞争，导致它执行MapReduce代码的速度更慢。我们最近遇到的一个问题是机器初始化代码中的一个错误，它导致处理器缓存被禁用:受影响的机器上的计算速度减慢了一百多倍。</p><p>​我们有一个通用的机制来缓解掉队者的问题。当一个MapReduce操作接近完成时，master调度剩余正在执行的任务执行备份。每当主执行或备份执行完成时，任务就被标记为已完成。我们已经对这种机制进行了调优，使它通常只增加操作所使用的计算资源几个百分点。我们发现这大大减少了完成大型MapReduce操作的时间。例如，当备份任务机制被禁用时，5.3节中描述的排序程序要多花44%的时间来完成。</p><h2 id="4-改进"><a class="markdownIt-Anchor" href="#4-改进"></a> 4 改进</h2><p>​虽然简单编写Map和Reduce函数提供的基本功能足以满足大多数需求，但我们发现一些扩展很有用。本节将介绍这些特性。</p><h3 id="41-分区函数"><a class="markdownIt-Anchor" href="#41-分区函数"></a> 4.1 分区函数</h3><p>​MapReduce的用户可以指定他们想要的reduce任务/输出文件数量®。使用中间键上的分区函数在这些任务之间对数据进行分区。提供了一个默认使用哈希函数进行分区(例如“hash(key) mod R”)，通常会产生相当均衡的分区结果。然而，在某些情况下，根据键值的其他函数对数据进行分区是有用的。例如，当输出键为url时，我们希望将同一主机上所有条目都放置在同一个输出文件中。为了支持这种情况，MapReduce库允许用户提供特殊的分区函数。例如，使用“hash(Hostname(urlkey)) mod R”作为分区函数将导致来自同一主机的所有url最终出现在相同的输出文件中。</p><h3 id="42-排序保证"><a class="markdownIt-Anchor" href="#42-排序保证"></a> 4.2 排序保证</h3><p>​保证在给定分区内，中间键/值对按键或递增顺序处理。这种排序保证可以很容易地为每个分区生成排序的输出文件，当输出文件格式需要支持有效的按键随机访问查找时，或者输出的用户发现对数据进行排序很方便时，这是很有用的。</p><h3 id="43-combiner"><a class="markdownIt-Anchor" href="#43-combiner"></a> 4.3 Combiner</h3><p>​在某些情况下，每个map任务产生的中间键存在显著的重复，并且用户指定的Reduce函数是可交换的和关联的。第2.1节中的单词计数就是一个很好的例子。由于词频倾向于遵循Zipf分布，每个地图任务将产生成百上千条形式为&lt;the, 1&gt;的记录。所有这些计数将通过网络发送到一个Reduce任务，然后由Reduce函数将它们加在一起生成一个数字。我们允许用户指定一个可选的Combiner函数，该函数在数据通过网络发送之前对其进行部分合并。</p><p>​Combiner函数在每台执行映射任务的机器上执行。通常使用相同的代码来实现combiner和reduce函数。reduce函数和组合函数之间的唯一区别是MapReduce库如何处理函数的输出。reduce函数的输出被写入最终的输出文件。组合函数的输出被写入中间文件，该中间文件将被发送给reduce任务。</p><p>​部分组合显著加快了某些类型的MapReduce操作。附录A包含一个使用组合器的示例。</p><h3 id="44-输入和输出类型"><a class="markdownIt-Anchor" href="#44-输入和输出类型"></a> 4.4 输入和输出类型</h3><p>​MapReduce库支持以几种不同的格式读取输入数据。比如，“text&quot;模式输入将每行视为一个键/值对:键是文件中的偏移量，值是该行的内容。另一种常见的支持格式存储按键排序的键/值对序列。每个输入类型实现都知道如何将自己分割成有意义的范围，以便作为单独的map任务进行处理(例如，文本模式的范围分割确保范围分割仅在行边界发生)。用户可以通过提供简单阅读器界面的实现来添加对新输入类型的支持，尽管大多数用户只使用少数预定义输入类型中的一种。</p><p>​读取器不一定需要提供从文件读取的数据。例如，很容易定义从数据库或从内存中映射的数据结构中读取记录的读取器。</p><p>​以类似的方式，我们支持一组输出类型来生成不同格式的数据，并且用户代码很容易添加对新输出类型的支持。</p><h3 id="45-副作用"><a class="markdownIt-Anchor" href="#45-副作用"></a> 4.5 副作用</h3><p>​在某些情况下，MapReduce的用户发现从他们的map和/或reduce操作符生成辅助文件作为附加输出是很方便的。我们依靠应用程序编写器使这些副作用原子化和幂等化。通常，应用程序写入临时文件，并在完全生成该文件后自动重命名该文件。</p><p>​我们不支持单个任务生成的多个输出文件的原子两阶段提交。因此，产生具有跨文件一致性要求的多个输出文件的任务应该是确定性的。这种限制在实践中从来没有成为问题。</p><h3 id="46-跳过坏记录"><a class="markdownIt-Anchor" href="#46-跳过坏记录"></a> 4.6 跳过坏记录</h3><p>​有时，用户代码中的错误会导致Map或Reduce函数在某些记录上崩溃。这样的bug会导致MapReduce操作无法完成。通常的做法是修复漏洞，但有时这是不可行的;也许这个bug是在一个第三方库中，源代码是不可用的。此外，有时忽略一些记录也是可以接受的，例如在对大型数据集进行统计分析时。我们提供了一种可选的执行模式，其中MapReduce库检测哪些记录导致确定性崩溃，并跳过这些记录，以便向前推进。</p><p>​每个工作进程安装一个信号处理程序，用于捕获分段违反和总线错误。在调用用户Map或Reduce操作之前，mapreduce库将参数的序列号存储在一个全局变量中。如果用户代码生成一个信号，信号处理程序发送一个包含序列号的“最后喘息”UDP数据包到MapReduce主服务器。当主服务器在一个特定的记录上看到多个失败时，它表明在下一次重新执行相应的Map或Reduce任务时应该跳过该记录。</p><h3 id="47-本地执行"><a class="markdownIt-Anchor" href="#47-本地执行"></a> 4.7 本地执行</h3><p>​Map或Reduce函数中的调试问题可能很棘手，因为实际的计算发生在分布式系统中，通常在数千台机器上，工作分配决策是由主机动态做出的。为了方便调试、分析和小规模测试，我们开发了MapReduce库的另一种实现，它在本地机器上顺序地执行MapReduce操作的所有工作。控件提供给用户，这样计算就可以限制在特定的地图任务上。用户用一个特殊的标志来调用他们的程序，然后可以很容易地使用他们认为有用的任何调试或测试工具(例如gdb)。</p><h3 id="48-状态信息"><a class="markdownIt-Anchor" href="#48-状态信息"></a> 4.8 状态信息</h3><p>​主服务器运行一个内部HTTP服务器，并导出一组状态页供人们使用。状态页显示计算的进度，例如已经完成了多少个任务、正在进行多少个任务、输入字节数、中间数据字节数、输出字节数、处理速率等。这些页面还包含到每个任务生成的标准错误和标准输出文件的链接。用户可以使用这些数据来预测计算需要多长时间，以及是否应该在计算中添加更多的资源。这些页面还可用于确定何时计算比预期慢得多。</p><p>​此外，顶级状态页显示哪些工人失败了，以及他们失败时正在处理哪些映射和减少任务。当试图诊断用户代码中的错误时，此信息非常有用。</p><h3 id="49-counters"><a class="markdownIt-Anchor" href="#49-counters"></a> 4.9 Counters</h3><p>​MapReduce库提供了一个计数器工具来计算各种事件的发生次数。例如，用户代码可能想要计算处理的单词总数或索引的德语文档的数量等。</p><p>​要使用此功能，用户代码创建一个命名计数器对象，然后在Map和/或Reduce函数中适当地增加计数器。例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs Python">Counter* uppercase; <br>uppercase = GetCounter(<span class="hljs-string">&quot;uppercase&quot;</span>); <br><span class="hljs-built_in">map</span>(String name, String contents): <br><span class="hljs-keyword">for</span> each word w <span class="hljs-keyword">in</span> contents: <br><span class="hljs-keyword">if</span> (IsCapitalized(w)): <br>uppercase-&gt;Increment(); <br>EmitIntermediate(w, <span class="hljs-string">&quot;1&quot;</span>);<br></code></pre></td></tr></table></figure><p>​来自各个工作机器的计数器值定期传播到主机器(在ping响应的基础上)。master从成功的map和reduce任务中聚合计数器值，并在MapReduce操作完成时返回给用户代码。当前计数器的值也显示在主状态页面上，以便人们可以观看实时计算的进度。在聚合计数器值时，主服务器消除了重复执行相同映射或reduce任务的影响，以避免重复计数。(重复执行可能来自我们使用备份任务和由于失败而重新执行任务。</p><p>)</p><p>​一些计数器值由MapReduce库自动维护，例如处理的输入键/值对的数量和产生的输出键/值对的数量。</p><p>​用户发现计数器功能对于安全检查MapReduce操作的行为很有用。例如，在一些MapReduce操作中，用户代码可能希望确保生成的输出对的数量恰好等于处理的输入对的数量，或者处理的德语文档的比例在处理的文档总数的某个可容忍的比例之内。</p><h2 id="5-performance"><a class="markdownIt-Anchor" href="#5-performance"></a> 5 Performance</h2><p>主要是一些性能的测试，就分析图片吧</p><p>集群配置：所有的程序都在一个由大约1800台机器组成的集群上执行。每台机器都有两个2GHz英特尔至强处理器，支持超线程，4GB内存，两个160GB IDE磁盘和千兆以太网链路。这些机器被安排在一个两级树状交换网络中，根节点的总带宽约为100- 200gbps。所有的机器都在同一个托管设施中，因此任何一对机器之间的往返时间都小于1毫秒。在4GB内存中，大约有1-1.5GB是由集群上运行的其他任务保留的。这些程序是在一个周末的下午执行的，当时cpu、磁盘和网络大多处于空闲状态。</p><p><img src="../imgs/mapreduce/image-20240314175218619.png" alt="图2:随时间变化的数据传输速率" /></p><p>图2显示了计算随时间的进展。y轴表示扫描输入数据的速率。当更多的机器被分配到这个MapReduce计算时，速率逐渐回升，当分配了1764个worker时，速率超过30GB/s。当地图任务完成时，速率开始下降，并在计算后80秒左右达到零。整个计算从开始到结束大约需要150秒。这包括大约一分钟的启动开销。开销是由于将程序传播到所有工作机器，以及延迟与GFS交互以打开1000个输入文件集并获得局部性优化所需的信息。</p><p><img src="../imgs/mapreduce/image-20240314175700641.png" alt="图3:排序程序的不同执行随时间变化的数据传输速率" /></p><p>图3 (a)显示了排序程序正常执行的进度。左上角的图表显示了读取输入的速率。速率峰值约为13gb /s，并且很快就会消失，因为所有的map任务在200秒内就完成了。注意，输入速率小于grep。这是因为排序映射任务花费大约一半的时间和I/O带宽将中间输出写入本地磁盘。grep对应的中间输出的大小可以忽略不计。</p><p>左中图显示了数据通过网络从map任务发送到reduce任务的速率。当第一个map任务完成时，shuffle就开始了。图中的第一个驼峰是第一批大约1700个reduce任务(整个MapReduce被分配了大约1700台机器，每台机器一次最多执行一个reduce任务)。在大约300秒的计算中，第一批reduce任务中的一些完成了，我们开始为剩余的reduce任务转移数据。所有的洗牌在计算后大约600秒完成</p><p>左下角的图表显示了reduce任务将排序后的数据写入最终输出文件的速率。在第一个洗牌周期的结束和写入周期的开始之间有一个延迟，因为机器忙于对中间数据进行排序。继续以大约2-4 GB/s的速率写一段时间。所有的写操作在计算完成后大约850秒完成。包括启动开销在内，整个计算耗时891秒。这与目前TeraSort基准测试1057秒的最佳报告结果相似。</p><p>在图3 (b)中，我们展示了禁用备份任务的排序程序的执行。执行流与图3 (a)中所示的类似，除了有一个非常长的尾，几乎没有任何写活动发生。960秒后，除5个reduce任务外，其余的reduce任务都完成了。然而，这些最后几名落伍者直到300秒后才完成比赛。整个计算耗时1283秒，运行时间增加了44%。</p><p>在图3 ©中，我们展示了排序程序的执行，在计算开始几分钟后，我们故意杀死了1746个工作进程中的200个。底层集群调度器立即重新启动这些机器上的新工作进程(因为只有进程被终止，机器仍然正常运行)。</p><h2 id="6-相关工作"><a class="markdownIt-Anchor" href="#6-相关工作"></a> 6 相关工作</h2><p>​许多系统提供了受限的编程模型，并利用这些约束自动并行化计算。例如，可以在N个处理器上使用并行前缀计算，在log N时间内对N个元素数组的所有前缀计算一个关联函数。MapReduce可以被认为是基于我们在现实世界中大量计算的经验对这些模型的简化和提炼。更重要的是，我们提供了可扩展到数千个处理器的容错实现。相比之下，大多数并行处理系统只在较小的规模上实现，并将处理机器故障的细节留给程序员。</p><p>​批量同步编程和一些MPI原语提供了更高级的抽象，使程序员更容易编写并行程序。这些系统和MapReduce之间的一个关键区别是，MapReduce利用一个受限的编程模型来自动并行化用户程序，并提供透明的容错。</p><p>​我们的局部性优化从活动磁盘等技术中获得灵感，其中计算被推进到靠近本地磁盘的处理元素中，以减少通过I/O子系统或网络发送的数据量。我们在直接连接少量磁盘的普通处理器上运行，而不是直接在磁盘控制器处理器上运行，但一般方法是相似的。</p><p>​我们的备份任务机制类似于夏洛特系统中采用的急切调度机制。简单的渴望调度的缺点之一是，如果一个给定的任务导致重复的失败，整个计算无法完成。我们用跳过坏记录的机制修复了这个问题的一些实例。</p><p>​MapReduce的实现依赖于内部集群管理系统，该系统负责在大量共享机器上分发和运行用户任务。集群管理系统虽然不是本文的重点，但在精神上与Condor等其他系统相似。</p><p>​排序工具是MapReduce库的一部分，在操作上类似于NOW-Sort。源机器(map worker)对要排序的数据进行分区，并将其发送给R个reduce worker中的一个。每个reduce worker在本地(如果可能的话，在内存中)对其数据进行排序。当然NOW-Sort没有用户自定义的Map和Reduce函数，而这些函数使我们的库具有广泛的适用性。</p><p>​River提供了一种编程模型，其中进程通过在分布式队列上发送数据来相互通信。与MapReduce一样，River系统即使在异构硬件或系统扰动引入的不均匀性存在的情况下，也试图提供良好的平均情况性能。River通过仔细地调度磁盘和网络传输来实现这一点，以实现平衡的完成时间。mapreduce采用了不同的方法。通过限制编程模型，MapReduce框架能够将问题划分为大量细粒度任务。这些任务在可用的worker上动态调度，以便更快的worker处理更多的任务。受限制的编程模型还允许我们在作业结束时安排任务的冗余执行，这大大减少了存在不一致性(例如缓慢或卡住的工人)的完成时间。</p><p>​BAD-FS有一个与MapReduce非常不同的编程模型，而且与MapReduce不同的是，它的目标是在广域网上执行工作。然而，有两个基本的相似之处。(1)两个系统都使用冗余执行来恢复故障造成的数据丢失。(2)两个系统都使用位置感知调度来减少在拥挤的网络链路上发送的数据量。</p><p>​TACC是一种简化高可用性网络业务构建的系统。与MapReduce一样，它依赖于重新执行作为实现容错的机制。</p><h2 id="7-总结"><a class="markdownIt-Anchor" href="#7-总结"></a> 7 总结</h2><p>​MapReduce编程模型已经在Google成功地用于许多不同的目的。我们把这一成功归因于几个原因。首先，该模型易于使用，即使对于没有并行和分布式系统经验的程序员也是如此，因为它隐藏了并行化、容错、局部优化和负载平衡的细节。其次，大量的问题很容易表达为MapReduce计算。例如，MapReduce用于为Google的生产网络搜索服务生成数据，用于排序、数据挖掘、机器学习和许多其他系统。第三，我们已经开发了一个MapReduce的实现，它可以扩展到由数千台机器组成的大型机器集群。该实现有效地利用了这些机器资源，因此适合用于Google遇到的许多大型计算问题。</p><p>​我们从这项工作中学到了一些东西。首先，限制编程模型使其易于并行化和分布计算，并使此类计算具有容错性。第二，网络带宽是一种稀缺资源。因此，我们系统中的许多优化都以减少通过网络发送的数据量为目标:局域优化允许我们从本地磁盘读取数据，并将中间数据的单个副本写入本地磁盘以节省网络带宽。第三，冗余执行可用于减少慢机的影响，并处理机器故障和数据丢失</p><h2 id="a-word-frequency"><a class="markdownIt-Anchor" href="#a-word-frequency"></a> A Word Frequency</h2><p>本节包含一个程序，该程序计算在命令行指定的一组输入文件中每个唯一单词的出现次数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;mapreduce/mapreduce.h&quot;</span> </span><br><span class="hljs-comment">// User’s map function </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WordCounter</span> : <span class="hljs-keyword">public</span> Mapper &#123; <br><span class="hljs-keyword">public</span>: <br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Map</span><span class="hljs-params">(<span class="hljs-type">const</span> MapInput&amp; input)</span> </span>&#123; <br><span class="hljs-type">const</span> string&amp; text = input.<span class="hljs-built_in">value</span>(); <br><span class="hljs-type">const</span> <span class="hljs-type">int</span> n = text.<span class="hljs-built_in">size</span>(); <br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; ) &#123; <br><span class="hljs-comment">// Skip past leading whitespace </span><br><span class="hljs-keyword">while</span> ((i &lt; n) &amp;&amp; <span class="hljs-built_in">isspace</span>(text[i])) <br>i++; <br>                <span class="hljs-comment">// Find word end </span><br>                <span class="hljs-type">int</span> start = i; <br>                <span class="hljs-keyword">while</span> ((i &lt; n) &amp;&amp; !<span class="hljs-built_in">isspace</span>(text[i])) <br>                i++; <br>                <span class="hljs-keyword">if</span> (start &lt; i) <br>                <span class="hljs-built_in">Emit</span>(text.<span class="hljs-built_in">substr</span>(start,i-start),<span class="hljs-string">&quot;1&quot;</span>); <br>&#125; <br>&#125; <br>&#125;; <br><span class="hljs-built_in">REGISTER_MAPPER</span>(WordCounter); <br><span class="hljs-comment">// User’s reduce function </span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Adder</span> : <span class="hljs-keyword">public</span> Reducer &#123; <br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">Reduce</span><span class="hljs-params">(ReduceInput* input)</span> </span>&#123; <br><span class="hljs-comment">// Iterate over all entries with the </span><br><span class="hljs-comment">// same key and add the values </span><br>int64 value = <span class="hljs-number">0</span>; <br><span class="hljs-keyword">while</span> (!input-&gt;<span class="hljs-built_in">done</span>()) &#123; <br>value += <span class="hljs-built_in">StringToInt</span>(input-&gt;<span class="hljs-built_in">value</span>()); <br>input-&gt;<span class="hljs-built_in">NextValue</span>(); <br>&#125; <br><br><span class="hljs-comment">// Emit sum for input-&gt;key() </span><br><span class="hljs-built_in">Emit</span>(<span class="hljs-built_in">IntToString</span>(value)); <br>&#125; <br>&#125;; <br><span class="hljs-built_in">REGISTER_REDUCER</span>(Adder); <br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123; <br><span class="hljs-built_in">ParseCommandLineFlags</span>(argc, argv); <br><br>MapReduceSpecification spec; <br><span class="hljs-comment">// Store list of input files into &quot;spec&quot; </span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; argc; i++) &#123; <br>MapReduceInput* input = spec.<span class="hljs-built_in">add_input</span>(); <br>input-&gt;<span class="hljs-built_in">set_format</span>(<span class="hljs-string">&quot;text&quot;</span>); <br>input-&gt;<span class="hljs-built_in">set_filepattern</span>(argv[i]); <br>input-&gt;<span class="hljs-built_in">set_mapper_class</span>(<span class="hljs-string">&quot;WordCounter&quot;</span>); <br>&#125; <br><span class="hljs-comment">// Specify the output files: </span><br><span class="hljs-comment">///gfs/test/freq-00000-of-00100 </span><br><span class="hljs-comment">///gfs/test/freq-00001-of-00100 </span><br><span class="hljs-comment">//... </span><br>MapReduceOutput* out = spec.<span class="hljs-built_in">output</span>(); <br>out-&gt;<span class="hljs-built_in">set_filebase</span>(<span class="hljs-string">&quot;/gfs/test/freq&quot;</span>); <br>out-&gt;<span class="hljs-built_in">set_num_tasks</span>(<span class="hljs-number">100</span>); <br>out-&gt;<span class="hljs-built_in">set_format</span>(<span class="hljs-string">&quot;text&quot;</span>); <br>out-&gt;<span class="hljs-built_in">set_reducer_class</span>(<span class="hljs-string">&quot;Adder&quot;</span>); <br><br><span class="hljs-comment">// Optional: do partial sums within map </span><br><span class="hljs-comment">// tasks to save network bandwidth </span><br>out-&gt;<span class="hljs-built_in">set_combiner_class</span>(<span class="hljs-string">&quot;Adder&quot;</span>); <br><br><span class="hljs-comment">// Tuning parameters: use at most 2000 </span><br><span class="hljs-comment">// machines and 100 MB of memory per task </span><br>spec.<span class="hljs-built_in">set_machines</span>(<span class="hljs-number">2000</span>); <br>spec.<span class="hljs-built_in">set_map_megabytes</span>(<span class="hljs-number">100</span>); <br>spec.<span class="hljs-built_in">set_reduce_megabytes</span>(<span class="hljs-number">100</span>); <br><span class="hljs-comment">// Now run it MapReduceResult result; </span><br><span class="hljs-keyword">if</span> (!<span class="hljs-built_in">MapReduce</span>(spec, &amp;result)) <span class="hljs-built_in">abort</span>(); <br><span class="hljs-comment">// Done: ’result’ structure contains info </span><br><span class="hljs-comment">// about counters, time taken, number of </span><br><span class="hljs-comment">// machines used, etc. </span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125; <br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>mit6.824</category>
      
    </categories>
    
    
    <tags>
      
      <tag>分布式系统</tag>
      
      <tag>mit6.824</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>14th-March</title>
    <link href="/2024/03/14/14th-March/"/>
    <url>/2024/03/14/14th-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="to-do-list"><a class="markdownIt-Anchor" href="#to-do-list"></a> To-do List</h1><ul><li><p>[x] 算法</p><ul><li>[x]  链表和分治</li></ul></li><li><p>[ ] 项目</p><ul><li>[x] cmu15445</li><li>[ ] mit6.824</li><li>[ ] mit6.081</li></ul></li><li><p>[ ] 八股</p><ul><li>[x] 操作系统</li><li>[x] 计算机网络</li><li>[ ] 数据库</li><li>[ ] redis</li></ul></li><li><p>[x] 日常总结</p></li></ul><h2 id="算法"><a class="markdownIt-Anchor" href="#算法"></a> 算法</h2><p>今天主要是分治和链表的操作的结合，虽然没有什么很难的知识点，但却是是难了很多</p><h4 id="1排序链表"><a class="markdownIt-Anchor" href="#1排序链表"></a> 1.<a href="https://leetcode.cn/problems/sort-list/description/?envType=study-plan-v2&amp;envId=top-interview-150">排序链表</a></h4><p>题面：</p><p><img src="../imgs/14th-March/image-20240314203533498.png" alt="lc排序链表" /></p><p>题解：</p><p>​还记得合并两个有序链表，，，所以可以找到链表的中点，将链表拆成两个子链表<font color=red>(!快慢指针找中点)</font>,然后对两个子链表分别排序，最后再合并</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//分治</span><br><span class="hljs-function">ListNode* <span class="hljs-title">sortList</span><span class="hljs-params">(ListNode* head, ListNode* tail)</span> </span>&#123;<br>       <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">nullptr</span>) &#123;<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (head-&gt;next == tail) &#123;<br>           head-&gt;next = <span class="hljs-literal">nullptr</span>;<br>           <span class="hljs-keyword">return</span> head;<br>       &#125;<br>       ListNode* slow = head, *fast = head;<br>       <span class="hljs-keyword">while</span> (fast != tail) &#123;<br>           slow = slow-&gt;next;<br>           fast = fast-&gt;next;<br>           <span class="hljs-keyword">if</span> (fast != tail) &#123;<br>               fast = fast-&gt;next;<br>           &#125;<br>       &#125;<br>       ListNode* mid = slow;<br>       <span class="hljs-keyword">return</span> <span class="hljs-built_in">merge</span>(<span class="hljs-built_in">sortList</span>(head, mid), <span class="hljs-built_in">sortList</span>(mid, tail));<br>   &#125;<br>   <span class="hljs-comment">//合并两个有序链表</span><br>   <span class="hljs-function">ListNode* <span class="hljs-title">merge</span><span class="hljs-params">(ListNode* head1, ListNode* head2)</span> </span>&#123;<br>       ListNode* dummyHead = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ListNode</span>(<span class="hljs-number">0</span>);<br>       ListNode* temp = dummyHead, *temp1 = head1, *temp2 = head2;<br>       <span class="hljs-keyword">while</span> (temp1 != <span class="hljs-literal">nullptr</span> &amp;&amp; temp2 != <span class="hljs-literal">nullptr</span>) &#123;<br>           <span class="hljs-keyword">if</span> (temp1-&gt;val &lt;= temp2-&gt;val) &#123;<br>               temp-&gt;next = temp1;<br>               temp1 = temp1-&gt;next;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               temp-&gt;next = temp2;<br>               temp2 = temp2-&gt;next;<br>           &#125;<br>           temp = temp-&gt;next;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (temp1 != <span class="hljs-literal">nullptr</span>) &#123;<br>           temp-&gt;next = temp1;<br>       &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (temp2 != <span class="hljs-literal">nullptr</span>) &#123;<br>           temp-&gt;next = temp2;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dummyHead-&gt;next;<br>   &#125;<br></code></pre></td></tr></table></figure><h4 id="2环形子数组的最大和"><a class="markdownIt-Anchor" href="#2环形子数组的最大和"></a> 2.<a href="https://leetcode.cn/problems/maximum-sum-circular-subarray/solutions/2350660/huan-xing-zi-shu-zu-de-zui-da-he-by-leet-elou/?envType=study-plan-v2&amp;envId=top-interview-150">环形子数组的最大和</a></h4><p><img src="../imgs/14th-March/image-20240314205127381.png" alt="环形子数组的最大和" /></p><p>题解：</p><p>​。。。明明说有什么<strong>Kadane</strong>算法，但是确实一点都没看到 还是普通的滑窗感觉（抄的官解，懒得写了主要是）</p><p>​</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">maxSubarraySumCircular</span><span class="hljs-params">(vector&lt;<span class="hljs-type">int</span>&gt;&amp; nums)</span> </span>&#123;<br>        <span class="hljs-type">int</span> n = nums.<span class="hljs-built_in">size</span>();<br>        <span class="hljs-function">vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">leftMax</span><span class="hljs-params">(n)</span></span>;<br>        leftMax[<span class="hljs-number">0</span>] = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> leftSum = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> pre = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-type">int</span> res = nums[<span class="hljs-number">0</span>];<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">1</span>; i &lt; n; i++) &#123;<br>            pre = <span class="hljs-built_in">max</span>(pre + nums[i], nums[i]);<br>            res = <span class="hljs-built_in">max</span>(res, pre);<br>            leftSum += nums[i];<br>            leftMax[i] = <span class="hljs-built_in">max</span>(leftMax[i - <span class="hljs-number">1</span>], leftSum);<br>        &#125;<br><br>        <span class="hljs-type">int</span> rightSum = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = n - <span class="hljs-number">1</span>; i &gt; <span class="hljs-number">0</span>; i--) &#123;<br>            rightSum += nums[i];<br>            res = <span class="hljs-built_in">max</span>(res, rightSum + leftMax[i - <span class="hljs-number">1</span>]);<br>        &#125;<br>        <span class="hljs-keyword">return</span> res;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="项目"><a class="markdownIt-Anchor" href="#项目"></a> 项目</h2><p>今天主要是过了一边mapreduce，花了一下午。。。</p><p>中午主要把445的p3 task1解决了</p><p>seqscan insert delete indexscan</p><h2 id="八股"><a class="markdownIt-Anchor" href="#八股"></a> 八股</h2><h3 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h3><p><strong>DNS解析过程</strong></p><ol><li>先查询浏览器缓存是否有该域名对应的IP地址。</li><li>如果浏览器缓存中没有，会去计算机本地的Host文件中查询是否有对应的缓存。</li><li>如果Host文件中也没有则会向<strong>本地的DNS服务器</strong>发起一个DNS查询请求。</li><li>如果本地DNS解析器有该域名的IP地址，就会直接返回，进入过没有缓存该域名的解析记录，它会向<strong>根DNS服务器</strong>发出查询请求。根DNS服务器并不负责解析域名，但它能告诉本地DNS解析器应该向哪个顶级域名的DNS服务器继续查询。</li><li>本地DNS解析器接着向指定的<strong>顶级域名DNS服务器</strong>发出查询请求。权威DNS服务器是负责存储特定域名和IP地址映射的服务器。当权威DNS服务器收到查询请求时，它会查找”<a href="http://example.com">example.com</a>“域名对应的IP地址，并将结果返回给本地DNS解析器。</li><li>本地DNS解析器将收到的IP地址返回给浏览器，并且还会将域名解析结果缓存在本地，以便下次访问时更快地相应。</li><li>浏览器发起连接：本地DNS解析器已经将IP地址返回给您的计算机，您的浏览器可以使用该IP地址与目标服务器建立连接，开始获取网页内容。</li></ol><p><img src="../imgs/14th-March/image-20240314211600938.png" alt="DNS解析过程（1）" /></p><p><img src="../imgs/14th-March/image-20240314211634503.png" alt="DNS解析过程（2）" /></p><p><img src="../imgs/14th-March/image-20240314211744604.png" alt="DNS解析过程（3）" /></p><h4 id="递归查询和迭代查询"><a class="markdownIt-Anchor" href="#递归查询和迭代查询"></a> 递归查询和迭代查询</h4><p>（1）递归查询</p><p>在递归查询中，DNS客户端向上层DNS服务器发起查询请求，并要求这些服务器直接提供完整的解析结果。递归查询的特点是，DNS客户端只需要发送一个查询请求，然后等待完整的解析结果。上层DNS服务器会自行查询下一级的服务器，并将最终结果返回给DNS客户端。</p><p>（2）迭代查询</p><p>在迭代查询中，DNS客户端向上层DNS服务器发起查询请求，但不要求直接提供完整的解析结果。相反，DNS客户端只是询问上层服务器⼀个更⾼级的域名服务器的地址，然后再⾃⾏向那个更⾼级的服务器发起查询请求，以此类推，直到获取完整的解析结果为⽌。</p><p>递归查询适合普通⽤户和客户端，⽽迭代查询适⽤于DNS服务器之间的通信。</p><h3 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h3><h4 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h4><p><img src="../imgs/14th-March/image-20240314212242097.png" alt="调度算法总结" /></p><p>（1）先来先服务（<strong>FCFS</strong>）</p><p>每次从就绪队列选择最先进入队列的进程，然后一直运行，知道进程退出或被阻塞，才会继续从队列中选择第一个进程接着运行。</p><p>这种算法虽然看上去公平，但是如果有一个长作业需要处理，后面的短作业需要处理很长时间。</p><p>先来先服务的特点是算法简单，对长作业比较有利，对短作业不利，适用于CPU繁忙型的系统，而不适用于I/O繁忙型作业的系统。</p><p><img src="../imgs/14th-March/image-20240314212552297.png" alt="FCFS" /></p><p>（2）最短作业优先（SJF）</p><p>最短作业优先调度算法从就绪队列中选择一个估计运行时间最短的作业，将之调入到内存中运行，这有利于提高系统的吞吐量。</p><p>但是这对长作业十分不利，由于调度程序总是优先调度短作业，将会导致长作业长期不被调度，此外该算法也没有考虑到作业的紧迫程度，因此不能保证紧迫性作业会被及时处理。</p><p><img src="../imgs/14th-March/image-20240314212803783.png" alt="SJF" /></p><p>（3）高响应比优先调度算法</p><p>每次进行进程调度时，先计算<strong>响应比优先级</strong>，然后把<strong>响应比优先级</strong>最高的进程投入运行</p><p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mtext>优先权</mtext><mo>=</mo><mfrac><mrow><mtext>等待时间</mtext><mo>+</mo><mtext>要求服务时间</mtext></mrow><mtext>要求服务时间</mtext></mfrac></mrow><annotation encoding="application/x-tex">\text{优先权} = \frac{\text{等待时间} + \text{要求服务时间}}{\text{要求服务时间}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord text"><span class="mord cjk_fallback">优先权</span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.04633em;vertical-align:-0.686em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.36033em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">要求服务时间</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord text"><span class="mord cjk_fallback">等待时间</span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord text"><span class="mord cjk_fallback">要求服务时间</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.686em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p><p>根据公式可以知道</p><ul><li>作业的等待时间相同时，如果要求服务时间越短，则响应比更高，有利于短作业执行</li><li>当要求服务时间相同时，响应比由等待时间决定，如果等待时间越长，则响应比越高</li><li>对于长作业，作业的响应比可以随着等待时间的增加而提高</li></ul><p>（4）时间片轮转调度算法</p><p>每个进程被分配⼀个时间段，称为时间⽚（<strong>Quantum</strong>），即允许该进程在该时间段中运⾏。</p><ul><li>如果时间⽚⽤完，进程还在运⾏，那么将会把此进程从 CPU 释放出来，并把 CPU 分配给另外⼀个进程；</li><li>如果该进程在时间⽚结束前阻塞或结束，则 CPU立即进⾏切换；</li></ul><p>另外，时间⽚的⻓度就是⼀个很关键的点：</p><ul><li>如果时间片设的太短会导致过多的进程上下文切换，降低了CPU效率；</li><li>如果设的太长又可能引起对短作业进程的响应时间变长。</li></ul><p>一般来说，时间片设为20~50ms通常是一个比较合理的折中值。</p><p><img src="../imgs/14th-March/image-20240314213700722.png" alt="时间片轮转" /></p><p>（5）最高优先级调度算法</p><p>从就绪队列中选择最高优先级的进程进行运行，但进程的优先级可以分为静态优先级和动态优先级</p><ul><li>静态优先级：优先级在创建进程时已经确定，在进程运行期间保持不变，确定静态优先级的主要依据又进程类型，对资源的要求，用户要求。</li><li>动态优先级：进程运行过程中，根据进程运行时间和等待时间等因素调整进程的优先级</li></ul><p>但这种算法可能会导致低优先级的进程永远不被执行</p><p><img src="../imgs/14th-March/image-20240314214039380.png" alt="最高优先级调度" /></p><p>（6）多级队列调度算法</p><p>上⾯的各种调度算法是固定且单⼀的，⽆法满⾜系统中不同⽤户对进程调度策略的不同要求，多级队列调度算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列，每个队列可以实施不同的调度算法。</p><p>（7）多级反馈队列调度算法</p><p>多级反馈队列调度算法融合了时间⽚轮转调度算法和优先级调度算法，通过动态调整进程的优先级和时间⽚⼤⼩，多级反馈队列调度算法可以兼顾多⽅⾯的系统⽬标</p><p>多级反馈队列调度算法的实现思想如下：</p><ul><li>设置多个就绪队列，并为每个队列赋予不同的优先级。第1级队列的优先级最⾼，第2级队列的优先级次之，其余队列的优先级逐个降低。</li><li>赋予各个队列的进程运⾏时间⽚的⼤⼩各不相同。在优先级越⾼的队列中，每个进程的时间⽚就越⼩。例如，第 i+1 级队列的时间⽚要⽐第i级队列的时间⽚⻓1倍。</li><li>每个队列都采⽤FCFS算法。当新进程进⼊内存后，⾸先将它放⼊第1级队列的末尾，按FCFS原则等待调度。当轮到该进程执⾏时，如它能在该时间⽚内完成，便可撤离系统。若它在⼀个时间⽚结束时尚未完成，调度程序将其转⼊第2级队列的末尾等待调度：若它在第2级队列中运⾏⼀个时间⽚后仍未完成，再将它放⼊第3级队列…，依此类推。当进程最后被降到第n级队列后，在第n级队列中便采⽤时间⽚轮转⽅式运⾏。</li><li>按队列优先级调度。仅当第1级队列为空时，才调度第2级队列中的进程运⾏；仅当第 1~i-1 级队列均为空时，才会调度第i级队列中的进程运⾏。若处理机正在执⾏第i级队列中的某进程时，⼜有新进程进⼊任⼀优先级较⾼的队列，此时须⽴即把正在运⾏的进程放回到第级队列的末尾，⽽把处理机分配给新到的⾼优先级进程。</li></ul><p>多级反馈队列的优势有以下几点：</p><ul><li>终端型作业用户：短作业优先。</li><li>短批处理作业用户：周转时间较短</li><li>长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。</li></ul><p><img src="../imgs/14th-March/image-20240314214242047.png" alt="多级反馈队列调度" /></p><h4 id="golang"><a class="markdownIt-Anchor" href="#golang"></a> Golang</h4><h4 id="数组与切片有什么异同"><a class="markdownIt-Anchor" href="#数组与切片有什么异同"></a> 数组与切片有什么异同</h4><p>slice的底层数据是数组，slice是对数组的封装，它描述一个数组的片段。两者都可以通过下标来访问单个元素。</p><p>数组是定长的，长度定义好之后，不能再更改。在Go中，数组是不常见的，因为其长度是类型的一部分，限制了它的表达能力，比如[3]int和[4]int就是不同的类型。</p><p>而切片则非常灵活，它可以动态地扩容。切片的类型与长度无关。</p><p>数组就是一片连续的内存，slice实际上是一个结构体，包含三个字段：长度、容量、底层数组。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> slice <span class="hljs-keyword">struct</span> &#123;<br>array unsafe.Pointer <span class="hljs-comment">// 元素指针</span><br><span class="hljs-built_in">len</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 长度 </span><br><span class="hljs-built_in">cap</span>   <span class="hljs-type">int</span> <span class="hljs-comment">// 容量</span><br>&#125;<br></code></pre></td></tr></table></figure><p>slice的数据结构如下：</p><p><img src="../imgs/14th-March/0.png" alt="切片数据结构" /></p><p>注意，底层数组是可以被多个slice同时指向的，因此对一个slice的元素进行操作是有可能影响到其他slice的。</p><p>【引申1】 [3]int 和 [4]int 是同一个类型吗？</p><p>不是。因为数组的长度是类型的一部分，这是与 slice 不同的一点。</p><p>【引申2】 下面的代码输出是什么？</p><p>说明：例子来自**《Go学习笔记》第四版**，P43页。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice := []<span class="hljs-type">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>s1 := slice[<span class="hljs-number">2</span>:<span class="hljs-number">5</span>]<br>s2 := s1[<span class="hljs-number">2</span>:<span class="hljs-number">6</span>:<span class="hljs-number">7</span>]<br><br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">100</span>)<br>s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">200</span>)<br><br>s1[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span><br><br>fmt.Println(s1)<br>fmt.Println(s2)<br>fmt.Println(slice)<br>&#125;<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs tap">[2<span class="hljs-number"> 3 </span>20]<br>[4<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>100 200]<br>[0<span class="hljs-number"> 1 </span>2<span class="hljs-number"> 3 </span>20<span class="hljs-number"> 5 </span>6<span class="hljs-number"> 7 </span>100 9]<br></code></pre></td></tr></table></figure><p><code>s1</code>从slice索引2（闭区间）到索引5（开区间），长度为3，容器默认到数组结尾，为8.<code>s2</code>从<code>s1</code>的索引2闭区间到索引6（开区间），容量到索引7（开区间），为5</p><p><img src="../imgs/14th-March/1.png" alt="slice origin" /></p><p>接着，向 <code>s2</code> 尾部追加一个元素 100：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p><code>s2</code> 容量刚好够，直接追加。不过，这会修改原始数组对应位置的元素。这一改动，数组和 <code>s1</code> 都可以看得到。</p><p><img src="../imgs/14th-March/2.png" alt="append 100" /></p><p>再次向 <code>s2</code> 追加元素200：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s2 = <span class="hljs-built_in">append</span>(s2, <span class="hljs-number">100</span>)<br></code></pre></td></tr></table></figure><p>这时，<code>s2</code> 的容量不够用，该扩容了。于是，<code>s2</code> 另起炉灶，将原来的元素复制新的位置，扩大自己的容量。并且为了应对未来可能的 <code>append</code> 带来的再一次扩容，<code>s2</code> 会在此次扩容的时候多留一些 <code>buffer</code>，将新的容量将扩大为原始容量的2倍，也就是10了。</p><p><img src="../imgs/14th-March/3.png" alt="append 200" /></p><p>最后，修改 <code>s1</code> 索引为2位置的元素：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go">s1[<span class="hljs-number">2</span>] = <span class="hljs-number">20</span><br></code></pre></td></tr></table></figure><p>这次只会影响原始数组相应位置的元素。它影响不到 <code>s2</code> 了，人家已经远走高飞了。</p><p><img src="../imgs/14th-March/4.png" alt="s1[2]=20" /></p><p>打印 <code>s1</code> 的时候，只会打印出 <code>s1</code> 长度以内的元素。所以，只会打印出3个元素，虽然它的底层数组不止3个元素。</p><h2 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h2><p>周六上午十点蚂蚁笔试，下午两点饿了么笔试（不是很匹配其实），周日看能不能面得物</p><p>感觉markdown还是不太熟练 啥时候进修一下子</p>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>算法</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>13th-March</title>
    <link href="/2024/03/13/13th-March/"/>
    <url>/2024/03/13/13th-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="to-do-list"><a class="markdownIt-Anchor" href="#to-do-list"></a> To-do List</h2><ul><li><p>[x] 算法</p><ul><li>[x] bfs &amp;&amp; trie树</li></ul></li><li><p>[ ] 项目</p><ul><li>[x] cmu15445</li><li>[ ] mit6.824</li><li>[ ] mit6.081</li></ul></li><li><p>[ ] 八股</p><ul><li>[x] 操作系统</li><li>[x] 计算机网络</li><li>[ ] 数据库</li><li>[ ] redis</li></ul></li><li><p>[x] 日常总结</p></li></ul><h3 id="1算法"><a class="markdownIt-Anchor" href="#1算法"></a> 1.算法</h3><h4 id="ibfs"><a class="markdownIt-Anchor" href="#ibfs"></a> I.bfs</h4><p><a href="https://leetcode.cn/problems/word-ladder/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词接龙</a></p><p>题面：<img src="../imgs/13th-March/image-20240313171436208.png" alt="image-20240313171436208" /></p><p>解答：其实都是很经典的队列bfs 和其他同类型的其他两个几乎一样 但是我也不知道为什么他是hard</p><p>用队列存储状态 然后再递归 理解bfs的精髓就好</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">while</span> (!q.<span class="hljs-built_in">empty</span>()) &#123;<br>            <span class="hljs-type">int</span> sz = q.<span class="hljs-built_in">size</span>();<br>            <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; sz; i++) &#123;<br>                string curr = q.<span class="hljs-built_in">front</span>();<br>                q.<span class="hljs-built_in">pop</span>();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">0</span>; j &lt; l; j++) &#123;<br>                    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> k = <span class="hljs-number">0</span>; k &lt; <span class="hljs-number">26</span>; k++) &#123;<br>                        <span class="hljs-keyword">if</span> (<span class="hljs-string">&#x27;a&#x27;</span> + k != curr[j]) &#123;<br>                            string next = curr;<br>                            next[j] = <span class="hljs-string">&#x27;a&#x27;</span> + k;<br>                            <span class="hljs-keyword">if</span> (!visited.<span class="hljs-built_in">count</span>(next) &amp;&amp; cnt.<span class="hljs-built_in">count</span>(next)) &#123;<br>                                <span class="hljs-keyword">if</span> (next == end) &#123;<br>                                    <span class="hljs-keyword">return</span> step;<br>                                &#125;<br>                                q.<span class="hljs-built_in">emplace</span>(next);<br>                                visited.<span class="hljs-built_in">emplace</span>(next);<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            step++;<br>        &#125;<br></code></pre></td></tr></table></figure><h4 id="iitrie树"><a class="markdownIt-Anchor" href="#iitrie树"></a> II.Trie树</h4><p><a href="https://leetcode.cn/problems/word-search-ii/description/?envType=study-plan-v2&amp;envId=top-interview-150">单词搜索II</a></p><p>题面：</p><p><img src="../imgs/13th-March/image-20240313171824850.png" alt="image-20240313171824850" /></p><p>题解：就不放经典的Trie了，这个才是真正的应用，将每个单词insert，再遍历整个二维数组用dfs，能访问到的就加入答案</p><p>Trie模板：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">TrieNode</span> &#123;<br>    string word;<br>    unordered_map&lt;<span class="hljs-type">char</span>,TrieNode *&gt; children; <span class="hljs-comment">//还有就是可以用vector存 size26</span><br>    <span class="hljs-built_in">TrieNode</span>() &#123;<br>        <span class="hljs-keyword">this</span>-&gt;word = <span class="hljs-string">&quot;&quot;</span>;<br>    &#125;<br>&#125;;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">insert</span><span class="hljs-params">(TrieNode *root,<span class="hljs-type">const</span> string &amp; word)</span> </span>&#123;<br>    TrieNode *node = root;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> c : word) &#123;<br>        <span class="hljs-keyword">if</span> (!node-&gt;children.<span class="hljs-built_in">count</span>(c)) &#123;<br>            node-&gt;children[c] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">TrieNode</span>();<br>        &#125;<br>        node = node-&gt;children[c];<br>    &#125;<br>    node-&gt;word = word;<br>&#125;<br></code></pre></td></tr></table></figure><p>dfs代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt;&amp; board, <span class="hljs-type">int</span> x, <span class="hljs-type">int</span> y, TrieNode * root, set&lt;string&gt; &amp; res)</span> </span>&#123;<br>        <span class="hljs-type">char</span> ch = board[x][y];        <br>        <span class="hljs-keyword">if</span> (!root-&gt;children.<span class="hljs-built_in">count</span>(ch)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>        root = root-&gt;children[ch];<br>        <span class="hljs-keyword">if</span> (root-&gt;word.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>) &#123;<br>            res.<span class="hljs-built_in">insert</span>(root-&gt;word);<br>        &#125;<br><br>        board[x][y] = <span class="hljs-string">&#x27;#&#x27;</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; ++i) &#123;<br>            <span class="hljs-type">int</span> nx = x + dirs[i][<span class="hljs-number">0</span>];<br>            <span class="hljs-type">int</span> ny = y + dirs[i][<span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">if</span> (nx &gt;= <span class="hljs-number">0</span> &amp;&amp; nx &lt; board.<span class="hljs-built_in">size</span>() &amp;&amp; ny &gt;= <span class="hljs-number">0</span> &amp;&amp; ny &lt; board[<span class="hljs-number">0</span>].<span class="hljs-built_in">size</span>()) &#123;<br>                <span class="hljs-keyword">if</span> (board[nx][ny] != <span class="hljs-string">&#x27;#&#x27;</span>) &#123;<br>                    <span class="hljs-built_in">dfs</span>(board, nx, ny, root,res);<br>                &#125;<br>            &#125;<br>        &#125;<br>        board[x][y] = ch;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;      <br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2项目"><a class="markdownIt-Anchor" href="#2项目"></a> 2.项目</h3><h4 id="cmu15445"><a class="markdownIt-Anchor" href="#cmu15445"></a> cmu15445</h4><p>进度：p3task1 大概看了一下 主要是query plan？ 到时候再看怎么看看代码</p><h3 id="3八股"><a class="markdownIt-Anchor" href="#3八股"></a> 3.八股</h3><h4 id="计算机网络"><a class="markdownIt-Anchor" href="#计算机网络"></a> 计算机网络</h4><p>（1）在浏览器中输入URL并按下回车之后会发生什么</p><p>第一步：输入URL并解析</p><p>对URL进行解析，获得协议、主机、端口、路径等信息，并构造一个HTTP请求（强制缓存 or 协商缓存）</p><p>第二步：DNS域名解析</p><p>将域名解析为对应的IP地址</p><p>第三步：建立TCP三次握手链接</p><p>Q：为什么是三次，不是两次、四次？握手丢失会发生什么，过程中可以携带数据吗</p><p>第四步：浏览器发送HTTP/HTTPS请求到web服务器</p><p>Q：HTTP/HTTPS的区别，请求状态码1xx-5xx</p><p>第五步：服务器处理HTTP请求并返回HTTP报文</p><p>服务器接收请求并将其传递给请求处理程序并发送HTTP响应，内容：请求的网页以及状态码、压缩类型、如何缓存的页面、设置的cookie；</p><p>第六步：浏览器渲染页面</p><p>第七步：断开连接TCP4次握手</p><p><img src="../imgs/13th-March/image-20240313182738368.png" alt="image-20240313182738368" /></p><h4 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h4><h5 id="进程和线程"><a class="markdownIt-Anchor" href="#进程和线程"></a> 进程和线程</h5><h6 id="1进程基础"><a class="markdownIt-Anchor" href="#1进程基础"></a> 1.进程基础</h6><p>(1)进程的概念</p><p>我们编写的代码只是一个存储在硬盘的静态文件，通过编译后就会生成二进制可执行文件，当我们运行这个可执行文件后，它就会被装载到内存中，接着CPU会执行程序中的每一条指令，那么这个运行中的程序，就被称为 <strong>[进程]（process)</strong></p><p>所以说，进程是具有独立功能的程序在一个数据集合上运行的过程，是系统进行资源分配和调度的一个独立单位。</p><p>（2）进程控制块（PCB）</p><p>系统通过<strong>PCB</strong>来描述进程的基本情况和运行状态，进而控制和管理进程，它是进程存在的唯一标识，包括：进程描述信息、进程控制和管理信息、进程资源分配清单、CPU相关信息</p><p><strong>PCB</strong>通常是通过链表的方式进行组织，把具有相同状态的进程链在一起，组成各种队列。</p><p>（3）并发与并行</p><p>单个处理核在很短时间内分别执行多个进程，成为并发</p><p>多个处理核同时执行多个进程称为并行</p><p>对于并发来说，CPU需要从一个进程切换到另一个进程，在切换前必须要记录当前进程中运行的状态信息，以备下次切换回来的时候可以恢复执行</p><p><img src="../imgs/13th-March/image-20240313193807222.png" alt="image-20240313193807222" /></p><p>（4）进程的状态切换</p><p>我们知道了并发会执行进程的切换，这就需要进程有运行状态和停止状态，实际上某个进程在某个时刻所处的态分为一下三种：</p><ul><li><p><strong>运行态</strong>：该时刻进程占用CPU</p></li><li><p><strong>就绪态</strong>：可运行，由于其他进程处于运行状态而暂停运行</p></li><li><p><strong>阻塞态</strong>：该进程正在等待某一事件的发生（如IO操作）而暂时停止运行</p><p><img src="../imgs/13th-March/image-20240313194129133.png" alt="image-20240313194129133" /></p></li></ul><p>如果有大量处于阻塞状态的进程，进程可能会占用着物理内存空间，所以系统通常会把阻塞状态的进程的物理内存空间换出到硬盘，等需要再次运行的时候，再从硬盘换入到物理内存，那么就需要一个新的状态，来描述进程没有占用实际的物理内存空间的情况，这个状态就是挂起状态。这跟阻塞状态是不一样的，阻塞是等待某个时间的返回。</p><p>分为阻塞挂起和阻塞就绪状态</p><p>（5）进程的上下文切换</p><p>一个进程切换到另一个进程运行，称为进程的上下文切换，<strong>进程的上下文切换</strong>不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括内核堆栈、寄存器等内核空间的资源。</p><p>（6）进程的创建</p><p>一个进程可以创建另一个进程，此时创建者为父进程，被创建的进程为子进程，操作系统创建一个新进程的过程如下：</p><ul><li>为新进程分配一个独特的进程控制块（PCB）</li><li>为新进程分配所需要的资源，如内存、CPU时间等</li><li>初始化进程控制块（PCB）的各种字段，包括状态、优先级、寄存器初始值等。</li><li>将其状态设置为就绪状态，使其能够被调度执行。进程进入就绪队列，等待分配处理器时间。</li></ul><p>（7）进程的终止</p><ul><li>根据标识符，查找需要终止的进程的PCB</li><li>如果进程处于执行状态，则立即终止该进程的执行，然后将处理器资源分配给其他进程</li><li>如果还有子进程，则将其子进程交给1号进程接管</li><li>将该进程所拥有的全部资源都归还给操作系统</li><li>将其从PCB所在队列中删除</li></ul><p>（8）进程的阻塞</p><ul><li>找到被阻塞进程的标识符对应的PCB</li><li>如果该进程为运行状态，则保护其现场，将其状态转为阻塞状态，停止运行</li><li>将该PCB插入到等待队列中，将处理机资源调度给其他就绪进程</li></ul><p>（9）进程的唤醒</p><ul><li>在该事件的阻塞队列中找到相应进程的PCB</li><li>将其从阻塞队列中移出，并置为就绪状态</li><li>将PCB插入到就绪队列中，等待调度程序调度</li></ul><h6 id="2线程基础"><a class="markdownIt-Anchor" href="#2线程基础"></a> 2.线程基础</h6><p>（1）什么是线程？</p><p>线程是“轻量级线程”，是进程中的一个实体，是程序执行的最小单位，也是被系统独立调度和分配的基本单位。</p><p>线程是进程当中的一条执行流程，同一个进程内多个线程之间可以共享代码段、数据段、打开的文件等资源，但每个线程各自都有一套独立的寄存器和栈，这样可以确保线程的控制流是相互独立的。</p><p>（2）线程的特点</p><ul><li>线程是一个“轻量级线程”，一个进程中可以有多个线程，线程不拥有系统资源，但是也有PCB，创建线程使用的底层函数和进程一样，都是clone</li><li>各个线程之间可以并发执行</li><li>同一个进程中的各个线程共享该进程所拥有的资源</li><li>进程可以蜕变成线程</li></ul><p>实际上，无论是创建进程的fork，还是创建线程的pthread_create，底层实现都是调用同一个内核函数clone</p><p>linux内核是不区分线程和进程的，只在用户层面上进行区分。所以，线程所有操作函数pthread_*是库函数，而非系统调用</p><p>（3）进程和线程的比较</p><p>​<strong>进程是资源（包括内存、打开的文件等）分配的单位，线程是CPU调度的单位</strong></p><hr /><ul><li>资源：进程是系统中拥有资源的基本单位，而线程不拥有系统资源（只有寄存器和栈），但线程可以访问隶属进程的系统资源</li><li>调度：线程切换的代价远低于进程，在同一个进程中，线程的切换不会引起进程切换，而从一个进程中的线程切换到另一个进程的线程中，会引起进程切换</li><li>并发：进程可以并发执行，而一个进程中的多个线程之间也能并发执行，甚至不同进程中的线程也能并发执行，从而是的操作系统拥有更好的并发性，提高了系统资源的利用率和系统的吞吐量</li><li>独立性：每个进程都拥有独⽴的地址空间和资源、除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程都不可⻅，同⼀进程中的不同线程是为了提⾼并发性以及进⾏相互之间的合作⽽创建的，它们共享进程的地址空间和资源。</li><li>系统开销：线程所需要的开销比进程小</li></ul><p>（4）线程的状态：</p><ul><li>执行状态</li><li>就绪状态</li><li>阻塞状态</li></ul><p>（5）线程的实现</p><ol><li>用户线程：用户空间实现的线程，操作系统不直接参与</li><li>内核线程：操作系统管理、调度，PCB存放在内核中</li><li>轻量级线程：内核支持的用户线程</li></ol><p>（6）线程共享资源</p><ul><li>文件描述符表</li><li>每种信号的处理方式</li><li>当前工作目录</li><li>用户ID和组ID</li></ul><p>（7）线程非共享资源</p><ul><li>线程id</li><li>处理器现场和栈指针</li><li>独立的栈空间</li><li>errno变量（？这是什么）</li><li>信号屏蔽字</li><li>调度优先级</li></ul><p>（8）线程的优缺点</p><p><strong>优点:</strong></p><ul><li>提高程序并发性</li><li>开销小</li><li>数据通信、共享数据方便</li></ul><p><strong>缺点:</strong></p><ul><li>库函数，不稳定</li><li>调试、编写困难、gdb不支持</li><li>对信号支持不好</li></ul><p>（9）线程如何减少开销</p><ol><li>线程创建快、进程创建需要资源管理信息，比如内存管理信息和文件管理信息，而线程创建后是共享其所属进程的资源管理信息</li><li>线程终止时间快，需回收的仅有少量寄存器和私有的栈区</li><li>线程切换快，因为线程切换仅涉及到少量寄存器和栈区，而进程上下文切换有CPU寄存器和程序寄存器、虚拟内存空间、页表切换等</li><li>线程因为创建时共享了其所属进程绝大多数资源，因此天生具有很好的线程间通信交互效率</li></ol><h3 id="4总结"><a class="markdownIt-Anchor" href="#4总结"></a> 4.总结</h3><p>投递进度</p><table><thead><tr><th>公司</th><th>进度</th><th>备注</th></tr></thead><tbody><tr><td>字节</td><td>简历评估</td><td></td></tr><tr><td>快手</td><td>系统研发存储 已投</td><td></td></tr><tr><td>携程</td><td>已投</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>算法</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>12th-March</title>
    <link href="/2024/03/12/12th-March/"/>
    <url>/2024/03/12/12th-March/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="to-do-list"><a class="markdownIt-Anchor" href="#to-do-list"></a> To-do List</h2><ul><li><p>[x] 算法</p><ul><li>[x] graph</li></ul></li><li><p>[ ] 项目</p><ul><li>[x] cmu15445</li><li>[ ] mit6.824</li><li>[ ] mit6.081</li></ul></li><li><p>[ ] 八股</p><ul><li>[ ] 操作系统</li><li>[ ] 计算机网络</li><li>[ ] 数据库</li><li>[ ] redis</li></ul></li><li><p>[ ] 日常总结</p></li></ul><h3 id="1算法"><a class="markdownIt-Anchor" href="#1算法"></a> 1.算法</h3><h4 id="图论"><a class="markdownIt-Anchor" href="#图论"></a> 图论</h4><p>(1)<a href="https://leetcode.cn/problems/surrounded-regions/description/?envType=study-plan-v2&amp;envId=top-interview-150">leetcode被围绕的区域</a></p><p>题面：<img src="../imgs/12th-March/image-20240312215015214.png" alt="image-20240312215015214" /></p><p>解答：从边缘的点开始dfs，先标记为’A’,再重新遍历修改</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(vector&lt;vector&lt;<span class="hljs-type">char</span>&gt;&gt; &amp;board, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt;= n || j &lt; <span class="hljs-number">0</span> || j &gt;= m || board[i][j] != <span class="hljs-string">&#x27;O&#x27;</span>) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        board[i][j] = <span class="hljs-string">&#x27;A&#x27;</span>;<br>        <span class="hljs-keyword">if</span> (i - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; board[i<span class="hljs-number">-1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i - <span class="hljs-number">1</span>, j);<br>        <span class="hljs-keyword">if</span> (j - <span class="hljs-number">1</span> &gt;= <span class="hljs-number">0</span> &amp;&amp; board[i][j<span class="hljs-number">-1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i, j - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (i + <span class="hljs-number">1</span> &lt; n &amp;&amp; board[i+<span class="hljs-number">1</span>][j] == <span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i + <span class="hljs-number">1</span>, j);<br>        <span class="hljs-keyword">if</span> (j + <span class="hljs-number">1</span> &lt; m &amp;&amp; board[i][j+<span class="hljs-number">1</span>] == <span class="hljs-string">&#x27;O&#x27;</span>) <span class="hljs-built_in">dfs</span>(board, i, j + <span class="hljs-number">1</span>);<br>    &#125;<br></code></pre></td></tr></table></figure><p>(2)<a href="https://leetcode.cn/problems/course-schedule/description/?envType=study-plan-v2&amp;envId=top-interview-150">leetcode课程表</a></p><p>题面：</p><p><img src="../imgs/12th-March/image-20240312215238605.png" alt="image-20240312215238605" /></p><p>题解：主要是拓扑排序，要是自己写可能就记录每个点的入度？然后从0开始，再一个一个遍历。但是其他题解是dfs，仔细想了想确实精妙。从一个点开始dfs，遍历他所有的节点，然后记录状态，最后记录当前节点，并放入答案中。</p><p>dfs重要代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs C++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> u)</span> </span>&#123;<br>        visited[u] = <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> v: edges[u]) &#123;<br>            <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-built_in">dfs</span>(v);<br>                <span class="hljs-keyword">if</span> (!valid) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (visited[v] == <span class="hljs-number">1</span>) &#123;<br>                valid = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125;<br>        visited[u] = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2项目"><a class="markdownIt-Anchor" href="#2项目"></a> 2.项目</h3><h4 id="cmu15445"><a class="markdownIt-Anchor" href="#cmu15445"></a> cmu15445</h4><p>Query Planning</p><p>emmm懒得总结了 大概就是说logical优化和physical优化</p><h3 id="3八股"><a class="markdownIt-Anchor" href="#3八股"></a> 3.八股</h3><p>今天没看。。。下次再说</p><h3 id="4总结"><a class="markdownIt-Anchor" href="#4总结"></a> 4.总结</h3><p>今天搞的有点少。。主要是晚上全在鼓捣这玩意，先好好准备一下周末的蚂蚁笔试，饿了么也可以</p><p>投递进度</p><table><thead><tr><th>公司</th><th>进度</th><th>备注</th></tr></thead><tbody><tr><td>腾讯</td><td>已投递</td><td>等捞？</td></tr><tr><td>字节</td><td>已投递</td><td></td></tr><tr><td>百度</td><td>无消息 已投递</td><td></td></tr><tr><td>蚂蚁</td><td>3.16笔试</td><td></td></tr><tr><td>美团</td><td>笔试完</td><td></td></tr><tr><td>阿里云</td><td>已投递</td><td></td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>diary</category>
      
    </categories>
    
    
    <tags>
      
      <tag>diary</tag>
      
      <tag>算法</tag>
      
      <tag>八股</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
